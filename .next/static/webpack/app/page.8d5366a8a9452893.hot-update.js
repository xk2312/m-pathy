"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\nfunction buildCrystalM(ctx) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    // Wichtig: CSS-Pixel statt Gerätepixel verwenden\n    const rect = ctx.canvas.getBoundingClientRect();\n    const w = rect.width;\n    const h = rect.height;\n    console.log(\"[crystalEngine] start\", {\n        w,\n        h\n    });\n    // Geometrie (responsive)\n    const baseX = w * 0.30;\n    const baseY = h * 0.70;\n    const spanX = Math.max(160, w * 0.22);\n    const peakY = Math.min(baseY - h * 0.28, h * 0.42);\n    const mPoints = [\n        {\n            x: baseX,\n            y: baseY\n        },\n        {\n            x: baseX + spanX * 0.25,\n            y: peakY\n        },\n        {\n            x: baseX + spanX * 0.50,\n            y: baseY * 0.93\n        },\n        {\n            x: baseX + spanX * 0.75,\n            y: peakY\n        },\n        {\n            x: baseX + spanX,\n            y: baseY\n        }\n    ];\n    const arms = mPoints.map((p, i)=>({\n            sx: mPoints[0].x,\n            sy: mPoints[0].y,\n            tx: p.x,\n            ty: p.y,\n            t: i === 0 ? 9999 : 0,\n            done: i === 0\n        }));\n    const maxProgress = isMobile ? 30 : 42;\n    let rafId = 0;\n    function drawGoldPoint(x, y, r) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#ffd700\";\n        ctx.shadowColor = \"rgba(255,215,0,1)\";\n        ctx.shadowBlur = 18;\n        ctx.fill();\n    }\n    function frame() {\n        // Voll clear → keine graue Fläche\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        // Ankerpunkt\n        drawGoldPoint(mPoints[0].x, mPoints[0].y, isMobile ? 3 : 4);\n        let allDone = true;\n        for (const arm of arms){\n            if (!arm.done) {\n                arm.t++;\n                const p = Math.min(arm.t / maxProgress, 1);\n                const nx = arm.sx + (arm.tx - arm.sx) * p;\n                const ny = arm.sy + (arm.ty - arm.sy) * p;\n                ctx.beginPath();\n                ctx.moveTo(arm.sx, arm.sy);\n                ctx.lineTo(nx, ny);\n                ctx.strokeStyle = \"rgba(173,216,230,0.95)\";\n                ctx.lineWidth = isMobile ? 1.6 : 2.2;\n                ctx.shadowColor = \"rgba(173,216,230,1)\";\n                ctx.shadowBlur = 14;\n                ctx.stroke();\n                if (p === 1) arm.done = true;\n            }\n            if (!arm.done) allDone = false;\n        }\n        for (const arm of arms){\n            if (arm.done && !(arm.sx === arm.tx && arm.sy === arm.ty)) {\n                drawGoldPoint(arm.tx, arm.ty, isMobile ? 2.6 : 3.2);\n            }\n        }\n        if (!allDone) {\n            rafId = requestAnimationFrame(frame);\n        } else {\n            // finales Aufglühen\n            for (const p of mPoints)drawGoldPoint(p.x, p.y, isMobile ? 3 : 4);\n            console.log(\"[crystalEngine] done – M aufgebaut\");\n        }\n    }\n    // sofort los (ohne grauen Schleier)\n    rafId = requestAnimationFrame(frame);\n// optionales Cleanup zurückgeben:\n// return () => cancelAnimationFrame(rafId)\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLCtCQUErQjtBQUN4QixTQUFTQSxjQUFjQyxHQUE2QjtJQUN6RCxNQUFNQyxXQUFXLDRCQUE0QkMsSUFBSSxDQUFDQyxVQUFVQyxTQUFTO0lBRXJFLGlEQUFpRDtJQUNqRCxNQUFNQyxPQUFPTCxJQUFJTSxNQUFNLENBQUNDLHFCQUFxQjtJQUM3QyxNQUFNQyxJQUFJSCxLQUFLSSxLQUFLO0lBQ3BCLE1BQU1DLElBQUlMLEtBQUtNLE1BQU07SUFFckJDLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUI7UUFBRUw7UUFBR0U7SUFBRTtJQUU1Qyx5QkFBeUI7SUFDekIsTUFBTUksUUFBUU4sSUFBSTtJQUNsQixNQUFNTyxRQUFRTCxJQUFJO0lBQ2xCLE1BQU1NLFFBQVFDLEtBQUtDLEdBQUcsQ0FBQyxLQUFLVixJQUFJO0lBQ2hDLE1BQU1XLFFBQVFGLEtBQUtHLEdBQUcsQ0FBQ0wsUUFBUUwsSUFBSSxNQUFNQSxJQUFJO0lBRTdDLE1BQU1XLFVBQVU7UUFDZDtZQUFFQyxHQUFHUjtZQUFxQlMsR0FBR1I7UUFBTTtRQUNuQztZQUFFTyxHQUFHUixRQUFRRSxRQUFRO1lBQU1PLEdBQUdKO1FBQU07UUFDcEM7WUFBRUcsR0FBR1IsUUFBUUUsUUFBUTtZQUFNTyxHQUFHUixRQUFRO1FBQUs7UUFDM0M7WUFBRU8sR0FBR1IsUUFBUUUsUUFBUTtZQUFNTyxHQUFHSjtRQUFNO1FBQ3BDO1lBQUVHLEdBQUdSLFFBQVFFO1lBQWNPLEdBQUdSO1FBQU07S0FDckM7SUFHRCxNQUFNUyxPQUFjSCxRQUFRSSxHQUFHLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTztZQUN6Q0MsSUFBSVAsT0FBTyxDQUFDLEVBQUUsQ0FBQ0MsQ0FBQztZQUNoQk8sSUFBSVIsT0FBTyxDQUFDLEVBQUUsQ0FBQ0UsQ0FBQztZQUNoQk8sSUFBSUosRUFBRUosQ0FBQztZQUNQUyxJQUFJTCxFQUFFSCxDQUFDO1lBQ1BTLEdBQUdMLE1BQU0sSUFBSSxPQUFPO1lBQ3BCTSxNQUFNTixNQUFNO1FBQ2Q7SUFFQSxNQUFNTyxjQUFjakMsV0FBVyxLQUFLO0lBQ3BDLElBQUlrQyxRQUFRO0lBRVosU0FBU0MsY0FBY2QsQ0FBUyxFQUFFQyxDQUFTLEVBQUVjLENBQVM7UUFDcERyQyxJQUFJc0MsU0FBUztRQUNidEMsSUFBSXVDLEdBQUcsQ0FBQ2pCLEdBQUdDLEdBQUdjLEdBQUcsR0FBR3BCLEtBQUt1QixFQUFFLEdBQUc7UUFDOUJ4QyxJQUFJeUMsU0FBUyxHQUFHO1FBQ2hCekMsSUFBSTBDLFdBQVcsR0FBRztRQUNsQjFDLElBQUkyQyxVQUFVLEdBQUc7UUFDakIzQyxJQUFJNEMsSUFBSTtJQUNWO0lBRUEsU0FBU0M7UUFDUCxrQ0FBa0M7UUFDbEM3QyxJQUFJOEMsU0FBUyxDQUFDLEdBQUcsR0FBRzlDLElBQUlNLE1BQU0sQ0FBQ0csS0FBSyxFQUFFVCxJQUFJTSxNQUFNLENBQUNLLE1BQU07UUFFdkQsYUFBYTtRQUNieUIsY0FBY2YsT0FBTyxDQUFDLEVBQUUsQ0FBQ0MsQ0FBQyxFQUFFRCxPQUFPLENBQUMsRUFBRSxDQUFDRSxDQUFDLEVBQUV0QixXQUFXLElBQUk7UUFFekQsSUFBSThDLFVBQVU7UUFFZCxLQUFLLE1BQU1DLE9BQU94QixLQUFNO1lBQ3RCLElBQUksQ0FBQ3dCLElBQUlmLElBQUksRUFBRTtnQkFDYmUsSUFBSWhCLENBQUM7Z0JBQ0wsTUFBTU4sSUFBSVQsS0FBS0csR0FBRyxDQUFDNEIsSUFBSWhCLENBQUMsR0FBR0UsYUFBYTtnQkFDeEMsTUFBTWUsS0FBS0QsSUFBSXBCLEVBQUUsR0FBRyxDQUFDb0IsSUFBSWxCLEVBQUUsR0FBR2tCLElBQUlwQixFQUFFLElBQUlGO2dCQUN4QyxNQUFNd0IsS0FBS0YsSUFBSW5CLEVBQUUsR0FBRyxDQUFDbUIsSUFBSWpCLEVBQUUsR0FBR2lCLElBQUluQixFQUFFLElBQUlIO2dCQUV4QzFCLElBQUlzQyxTQUFTO2dCQUNidEMsSUFBSW1ELE1BQU0sQ0FBQ0gsSUFBSXBCLEVBQUUsRUFBRW9CLElBQUluQixFQUFFO2dCQUN6QjdCLElBQUlvRCxNQUFNLENBQUNILElBQUlDO2dCQUNmbEQsSUFBSXFELFdBQVcsR0FBRztnQkFDbEJyRCxJQUFJc0QsU0FBUyxHQUFHckQsV0FBVyxNQUFNO2dCQUNqQ0QsSUFBSTBDLFdBQVcsR0FBRztnQkFDbEIxQyxJQUFJMkMsVUFBVSxHQUFHO2dCQUNqQjNDLElBQUl1RCxNQUFNO2dCQUVWLElBQUk3QixNQUFNLEdBQUdzQixJQUFJZixJQUFJLEdBQUc7WUFDMUI7WUFDQSxJQUFJLENBQUNlLElBQUlmLElBQUksRUFBRWMsVUFBVTtRQUMzQjtRQUVBLEtBQUssTUFBTUMsT0FBT3hCLEtBQU07WUFDdEIsSUFBSXdCLElBQUlmLElBQUksSUFBSSxDQUFFZSxDQUFBQSxJQUFJcEIsRUFBRSxLQUFLb0IsSUFBSWxCLEVBQUUsSUFBSWtCLElBQUluQixFQUFFLEtBQUttQixJQUFJakIsRUFBRSxHQUFHO2dCQUN6REssY0FBY1ksSUFBSWxCLEVBQUUsRUFBRWtCLElBQUlqQixFQUFFLEVBQUU5QixXQUFXLE1BQU07WUFDakQ7UUFDRjtRQUVBLElBQUksQ0FBQzhDLFNBQVM7WUFDWlosUUFBUXFCLHNCQUFzQlg7UUFDaEMsT0FBTztZQUNMLG9CQUFvQjtZQUNwQixLQUFLLE1BQU1uQixLQUFLTCxRQUFTZSxjQUFjVixFQUFFSixDQUFDLEVBQUVJLEVBQUVILENBQUMsRUFBRXRCLFdBQVcsSUFBSTtZQUNoRVcsUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRjtJQUVBLG9DQUFvQztJQUNwQ3NCLFFBQVFxQixzQkFBc0JYO0FBRTlCLGtDQUFrQztBQUNsQywyQ0FBMkM7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL21vZHVsZXMvY3J5c3RhbEVuZ2luZS50cz80NmM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGFwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHNcbmV4cG9ydCBmdW5jdGlvbiBidWlsZENyeXN0YWxNKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGNvbnN0IGlzTW9iaWxlID0gL01vYml8QW5kcm9pZHxpUGhvbmV8aVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcblxuICAvLyBXaWNodGlnOiBDU1MtUGl4ZWwgc3RhdHQgR2Vyw6R0ZXBpeGVsIHZlcndlbmRlblxuICBjb25zdCByZWN0ID0gY3R4LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCB3ID0gcmVjdC53aWR0aFxuICBjb25zdCBoID0gcmVjdC5oZWlnaHRcblxuICBjb25zb2xlLmxvZygnW2NyeXN0YWxFbmdpbmVdIHN0YXJ0JywgeyB3LCBoIH0pXG5cbiAgLy8gR2VvbWV0cmllIChyZXNwb25zaXZlKVxuICBjb25zdCBiYXNlWCA9IHcgKiAwLjMwXG4gIGNvbnN0IGJhc2VZID0gaCAqIDAuNzBcbiAgY29uc3Qgc3BhblggPSBNYXRoLm1heCgxNjAsIHcgKiAwLjIyKVxuICBjb25zdCBwZWFrWSA9IE1hdGgubWluKGJhc2VZIC0gaCAqIDAuMjgsIGggKiAwLjQyKVxuXG4gIGNvbnN0IG1Qb2ludHMgPSBbXG4gICAgeyB4OiBiYXNlWCwgICAgICAgICAgICAgICB5OiBiYXNlWSB9LCAgICAgICAgLy8gMCBBbmtlclxuICAgIHsgeDogYmFzZVggKyBzcGFuWCAqIDAuMjUsIHk6IHBlYWtZIH0sICAgICAgIC8vIDEgUGVhayBsaW5rc1xuICAgIHsgeDogYmFzZVggKyBzcGFuWCAqIDAuNTAsIHk6IGJhc2VZICogMC45MyB9LC8vIDIgVGFsIE1pdHRlXG4gICAgeyB4OiBiYXNlWCArIHNwYW5YICogMC43NSwgeTogcGVha1kgfSwgICAgICAgLy8gMyBQZWFrIHJlY2h0c1xuICAgIHsgeDogYmFzZVggKyBzcGFuWCwgICAgICAgIHk6IGJhc2VZIH0sICAgICAgIC8vIDQgdW50ZW4gcmVjaHRzXG4gIF1cblxuICB0eXBlIEFybSA9IHsgc3g6IG51bWJlcjsgc3k6IG51bWJlcjsgdHg6IG51bWJlcjsgdHk6IG51bWJlcjsgdDogbnVtYmVyOyBkb25lOiBib29sZWFuIH1cbiAgY29uc3QgYXJtczogQXJtW10gPSBtUG9pbnRzLm1hcCgocCwgaSkgPT4gKHtcbiAgICBzeDogbVBvaW50c1swXS54LFxuICAgIHN5OiBtUG9pbnRzWzBdLnksXG4gICAgdHg6IHAueCxcbiAgICB0eTogcC55LFxuICAgIHQ6IGkgPT09IDAgPyA5OTk5IDogMCxcbiAgICBkb25lOiBpID09PSAwLFxuICB9KSlcblxuICBjb25zdCBtYXhQcm9ncmVzcyA9IGlzTW9iaWxlID8gMzAgOiA0MlxuICBsZXQgcmFmSWQgPSAwXG5cbiAgZnVuY3Rpb24gZHJhd0dvbGRQb2ludCh4OiBudW1iZXIsIHk6IG51bWJlciwgcjogbnVtYmVyKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LmFyYyh4LCB5LCByLCAwLCBNYXRoLlBJICogMilcbiAgICBjdHguZmlsbFN0eWxlID0gJyNmZmQ3MDAnXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMjU1LDIxNSwwLDEpJ1xuICAgIGN0eC5zaGFkb3dCbHVyID0gMThcbiAgICBjdHguZmlsbCgpXG4gIH1cblxuICBmdW5jdGlvbiBmcmFtZSgpIHtcbiAgICAvLyBWb2xsIGNsZWFyIOKGkiBrZWluZSBncmF1ZSBGbMOkY2hlXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjdHguY2FudmFzLndpZHRoLCBjdHguY2FudmFzLmhlaWdodClcblxuICAgIC8vIEFua2VycHVua3RcbiAgICBkcmF3R29sZFBvaW50KG1Qb2ludHNbMF0ueCwgbVBvaW50c1swXS55LCBpc01vYmlsZSA/IDMgOiA0KVxuXG4gICAgbGV0IGFsbERvbmUgPSB0cnVlXG5cbiAgICBmb3IgKGNvbnN0IGFybSBvZiBhcm1zKSB7XG4gICAgICBpZiAoIWFybS5kb25lKSB7XG4gICAgICAgIGFybS50KytcbiAgICAgICAgY29uc3QgcCA9IE1hdGgubWluKGFybS50IC8gbWF4UHJvZ3Jlc3MsIDEpXG4gICAgICAgIGNvbnN0IG54ID0gYXJtLnN4ICsgKGFybS50eCAtIGFybS5zeCkgKiBwXG4gICAgICAgIGNvbnN0IG55ID0gYXJtLnN5ICsgKGFybS50eSAtIGFybS5zeSkgKiBwXG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5tb3ZlVG8oYXJtLnN4LCBhcm0uc3kpXG4gICAgICAgIGN0eC5saW5lVG8obngsIG55KVxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgxNzMsMjE2LDIzMCwwLjk1KSdcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGlzTW9iaWxlID8gMS42IDogMi4yXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDE3MywyMTYsMjMwLDEpJ1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDE0XG4gICAgICAgIGN0eC5zdHJva2UoKVxuXG4gICAgICAgIGlmIChwID09PSAxKSBhcm0uZG9uZSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmICghYXJtLmRvbmUpIGFsbERvbmUgPSBmYWxzZVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXJtIG9mIGFybXMpIHtcbiAgICAgIGlmIChhcm0uZG9uZSAmJiAhKGFybS5zeCA9PT0gYXJtLnR4ICYmIGFybS5zeSA9PT0gYXJtLnR5KSkge1xuICAgICAgICBkcmF3R29sZFBvaW50KGFybS50eCwgYXJtLnR5LCBpc01vYmlsZSA/IDIuNiA6IDMuMilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFsbERvbmUpIHtcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5hbGVzIEF1Zmdsw7xoZW5cbiAgICAgIGZvciAoY29uc3QgcCBvZiBtUG9pbnRzKSBkcmF3R29sZFBvaW50KHAueCwgcC55LCBpc01vYmlsZSA/IDMgOiA0KVxuICAgICAgY29uc29sZS5sb2coJ1tjcnlzdGFsRW5naW5lXSBkb25lIOKAkyBNIGF1ZmdlYmF1dCcpXG4gICAgfVxuICB9XG5cbiAgLy8gc29mb3J0IGxvcyAob2huZSBncmF1ZW4gU2NobGVpZXIpXG4gIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKVxuXG4gIC8vIG9wdGlvbmFsZXMgQ2xlYW51cCB6dXLDvGNrZ2ViZW46XG4gIC8vIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZClcbn1cbiJdLCJuYW1lcyI6WyJidWlsZENyeXN0YWxNIiwiY3R4IiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicmVjdCIsImNhbnZhcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJjb25zb2xlIiwibG9nIiwiYmFzZVgiLCJiYXNlWSIsInNwYW5YIiwiTWF0aCIsIm1heCIsInBlYWtZIiwibWluIiwibVBvaW50cyIsIngiLCJ5IiwiYXJtcyIsIm1hcCIsInAiLCJpIiwic3giLCJzeSIsInR4IiwidHkiLCJ0IiwiZG9uZSIsIm1heFByb2dyZXNzIiwicmFmSWQiLCJkcmF3R29sZFBvaW50IiwiciIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiZmlsbCIsImZyYW1lIiwiY2xlYXJSZWN0IiwiYWxsRG9uZSIsImFybSIsIm54IiwibnkiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});