"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; },\n/* harmony export */   computeMAnchor: function() { return /* binding */ computeMAnchor; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n/** Linker unterer Anker exakt wie im M */ function computeMAnchor(w, h) {\n    const leftX = w * 0.28;\n    const baseY = h * 0.74;\n    return {\n        x: leftX,\n        y: baseY\n    };\n}\n/**\n * Pen-Sweep: Ein digitaler Stift fährt den Pfad P0→P1→P2→P3→P4 in ~5 s ab\n * und setzt unterwegs Punkte (mehrere parallele Reihen = Strichbreite)\n * mit Mindestabstand. Runde Caps + runde Joins; Valley-Plug füllt die V-Kerbe.\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    const { width: w, height: h } = ctx.canvas.getBoundingClientRect();\n    // Proportionen (aufrechte Säulen)\n    const baseY = h * 0.74;\n    const topY = h * 0.36;\n    const leftX = w * 0.28;\n    const rightX = w * 0.28 + Math.max(360, w * 0.32);\n    const midX = (leftX + rightX) / 2;\n    const valleyY = baseY - Math.max(90, h * 0.14);\n    const P = [\n        {\n            x: leftX,\n            y: baseY\n        },\n        {\n            x: leftX,\n            y: topY\n        },\n        {\n            x: midX,\n            y: valleyY\n        },\n        {\n            x: rightX,\n            y: topY\n        },\n        {\n            x: rightX,\n            y: baseY\n        }\n    ];\n    // Segmente + Geometrie\n    const segs = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ].map((s)=>{\n        const dx = s.b.x - s.a.x;\n        const dy = s.b.y - s.a.y;\n        const len = Math.hypot(dx, dy);\n        const tx = len ? dx / len : 0;\n        const ty = len ? dy / len : 0;\n        const nx = ty;\n        const ny = -tx;\n        return {\n            ...s,\n            dx,\n            dy,\n            len,\n            tx,\n            ty,\n            nx,\n            ny\n        };\n    });\n    const totalLen = segs.reduce((s, g)=>s + g.len, 0);\n    // Look & Rasterabstände\n    const dotR = isMobile ? 1.3 : 1.6;\n    const minGap = isMobile ? 1.8 : 2.2;\n    const stepAlong = Math.max(isMobile ? 2.4 : 2.0, dotR * 2 + (minGap - 0.6));\n    const gapAcross = Math.max(isMobile ? 4.8 : 4.2, dotR * 2 + minGap);\n    const widthPx = isMobile ? 28 : 56;\n    const rows = Math.max(1, Math.floor(widthPx / gapAcross));\n    const durationSec = 5;\n    // Zeitsteuerung\n    const start = performance.now();\n    let prevS = 0;\n    let raf = 0;\n    // Spatial Hash (Abstands-Garantie)\n    const cell = Math.min(stepAlong, gapAcross) * 0.9;\n    const placed = new Set();\n    const key = (x, y)=>\"\".concat(Math.round(x / cell), \":\").concat(Math.round(y / cell));\n    const drawDot = function(x, y) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : dotR;\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#6BD5FF\";\n        ctx.shadowColor = \"rgba(107,213,255,0.55)\";\n        ctx.shadowBlur = 4;\n        ctx.fill();\n    };\n    const tryDot = function(x, y) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : dotR;\n        const k = key(x, y);\n        if (placed.has(k)) return false;\n        placed.add(k);\n        drawDot(x, y, r);\n        return true;\n    };\n    // Erstpunkt (Anchor)\n    tryDot(anchor.x, anchor.y, dotR + 0.9);\n    const extras = [];\n    // Start-Cap (Halbkreis am P0)\n    if (segs[0]) pushRoundCap(extras, P[0], -segs[0].tx, -segs[0].ty, rows, gapAcross, dotR, stepAlong, 0);\n    // Joins an P1, P2, P3 (+ Valley-Plug an P2)\n    for(let i = 1; i < segs.length; i++){\n        const prev = segs[i - 1], next = segs[i];\n        const sAtCorner = segs.slice(0, i).reduce((s, g)=>s + g.len, 0);\n        pushRoundJoin(extras, P[i], prev, next, rows, gapAcross, dotR, stepAlong, sAtCorner);\n        if (i === 2) {\n            pushValleyPlug(extras, P[2], segs[1], segs[2], rows, gapAcross, dotR, sAtCorner);\n        }\n    }\n    // End-Cap (Halbkreis am P4)\n    const lenBeforeEnd = segs.reduce((s, g)=>s + g.len, 0);\n    pushRoundCap(extras, P[4], segs[segs.length - 1].tx, segs[segs.length - 1].ty, rows, gapAcross, dotR, stepAlong, lenBeforeEnd);\n    extras.sort((a, b)=>a.s - b.s);\n    let extraIdx = 0;\n    // PEN-SWEEP\n    function tick(now) {\n        const t = Math.min((now - start) / (durationSec * 1000), 1);\n        const sTarget = t * totalLen;\n        // entlang des Pfads Punkte setzen (mehrere Reihen = Strichbreite)\n        for(let s = prevS; s <= sTarget; s += stepAlong){\n            const pos = pointAtLength(s);\n            if (!pos) continue;\n            const { x, y, nx, ny } = pos;\n            const half = (rows - 1) / 2;\n            for(let r = 0; r < rows; r++){\n                const offset = (r - half) * gapAcross;\n                tryDot(x + nx * offset, y + ny * offset);\n            }\n        }\n        prevS = sTarget;\n        // Extras, deren s erreicht ist\n        while(extraIdx < extras.length && extras[extraIdx].s <= sTarget){\n            const e = extras[extraIdx++];\n            var _e_r;\n            tryDot(e.x, e.y, (_e_r = e.r) !== null && _e_r !== void 0 ? _e_r : dotR);\n        }\n        if (t < 1 || extraIdx < extras.length) {\n            raf = requestAnimationFrame(tick);\n        } else {\n            cancelAnimationFrame(raf);\n        }\n    }\n    raf = requestAnimationFrame(tick);\n    // ---------- Helpers -------------------------------------------------------\n    function pointAtLength(s) {\n        let acc = 0;\n        for (const g of segs){\n            if (s <= acc + g.len) {\n                const d = s - acc;\n                const t = g.len ? d / g.len : 0;\n                const x = g.a.x + g.dx * t;\n                const y = g.a.y + g.dy * t;\n                return {\n                    x,\n                    y,\n                    nx: g.nx,\n                    ny: g.ny\n                };\n            }\n            acc += g.len;\n        }\n        const last = segs[segs.length - 1];\n        return {\n            x: last.b.x,\n            y: last.b.y,\n            nx: last.ny,\n            ny: -last.nx\n        };\n    }\n    // runder End-Cap (Halbkreis)\n    function pushRoundCap(out, C, tx, ty, nRows, across, rDot, along, sBase) {\n        const half = (nRows - 1) / 2;\n        const radius = half * across;\n        const arcStart = Math.atan2(-ty, -tx) - Math.PI / 2;\n        const arcEnd = arcStart + Math.PI;\n        const ringStep = Math.max(rDot * 2 + minGap, across * 0.9);\n        const rings = Math.max(1, Math.floor(radius / ringStep));\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * ringStep;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const pts = Math.max(6, Math.floor(circ / (rDot * 2 + minGap)));\n            for(let i = 0; i <= pts; i++){\n                const a = arcStart + i / pts * (arcEnd - arcStart);\n                out.push({\n                    s: sBase + 0.001 * seq++,\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad\n                });\n            }\n        }\n    }\n    // runder Join (Sektor) zwischen zwei Segmenten am Eckpunkt C (stabil, inkl. Large-Arc)\n    function pushRoundJoin(out, C, prev, next, nRows, across, rDot, along, sAtCorner) {\n        const aIn = Math.atan2(prev.ny, prev.nx);\n        const aOut = Math.atan2(next.ny, next.nx);\n        // Tangenten (für konkav/konvex)\n        let tIn = Math.atan2(prev.ty, prev.tx);\n        let tOut = Math.atan2(next.ty, next.tx);\n        while(tOut - tIn <= -Math.PI)tOut += 2 * Math.PI;\n        while(tOut - tIn > Math.PI)tOut -= 2 * Math.PI;\n        const turn = tOut - tIn;\n        // Winkel-Differenz der Normalen auf [-π,π]\n        let delta = aOut - aIn;\n        while(delta <= -Math.PI)delta += 2 * Math.PI;\n        while(delta > Math.PI)delta -= 2 * Math.PI;\n        // konkav → großen Bogen nehmen\n        const useLargeArc = Math.abs(turn) > Math.PI / 2;\n        let startAngle = aIn;\n        let endAngle = aIn + delta;\n        if (useLargeArc) {\n            if (delta > 0) endAngle = aIn - (2 * Math.PI - delta);\n            else endAngle = aIn + (2 * Math.PI + delta);\n        }\n        const radius = (nRows - 1) * across / 2;\n        const ringStep = Math.max(rDot * 2 + minGap, across * 0.9);\n        const rings = Math.max(1, Math.floor(radius / ringStep));\n        const angStep = Math.max((rDot * 2 + minGap) / Math.max(radius, 1), Math.PI / 36);\n        const dir = endAngle >= startAngle ? 1 : -1;\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * ringStep;\n            for(let a = startAngle; dir > 0 ? a <= endAngle : a >= endAngle; a += dir * angStep){\n                out.push({\n                    s: sAtCorner + 0.001 * seq++,\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad\n                });\n            }\n        }\n        out.push({\n            s: sAtCorner + 0.002 * seq++,\n            x: C.x,\n            y: C.y,\n            r: rDot\n        });\n    }\n    // füllt die innere V-Ecke (Tal) weich\n    function pushValleyPlug(out, C, prev, next, nRows, across, rDot, sAtCorner) {\n        // Innen-Bisektor\n        let bx = -prev.tx + next.tx;\n        let by = -prev.ty + next.ty;\n        const bl = Math.hypot(bx, by) || 1;\n        bx /= bl;\n        by /= bl;\n        const innerR = (nRows - 1) * across * 0.48;\n        const cx = C.x + bx * (innerR * 0.35);\n        const cy = C.y + by * (innerR * 0.35);\n        const ringStep = Math.max(rDot * 2.0, across * 0.9);\n        const rings = Math.max(2, Math.floor(innerR / ringStep));\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r / rings * innerR;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const step = Math.max(rDot * 2.0, across * 0.9);\n            const n = Math.max(8, Math.floor(circ / step));\n            for(let i = 0; i < n; i++){\n                const a = i / n * Math.PI * 2;\n                out.push({\n                    s: sAtCorner + 0.001 * seq++,\n                    x: cx + Math.cos(a) * rad,\n                    y: cy + Math.sin(a) * rad\n                });\n            }\n        }\n        out.push({\n            s: sAtCorner + 0.002 * seq++,\n            x: cx,\n            y: cy,\n            r: rDot\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQkFBK0I7QUFHL0Isd0NBQXdDLEdBQ2pDLFNBQVNBLGVBQWVDLENBQVMsRUFBRUMsQ0FBUztJQUNqRCxNQUFNQyxRQUFRRixJQUFJO0lBQ2xCLE1BQU1HLFFBQVFGLElBQUk7SUFDbEIsT0FBTztRQUFFRyxHQUFHRjtRQUFPRyxHQUFHRjtJQUFNO0FBQzlCO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNHLGNBQWNDLEdBQTZCLEVBQUVDLE1BQVU7SUFDckUsTUFBTUMsV0FBVyw0QkFBNEJDLElBQUksQ0FBQ0MsVUFBVUMsU0FBUztJQUNyRSxNQUFNLEVBQUVDLE9BQU9iLENBQUMsRUFBRWMsUUFBUWIsQ0FBQyxFQUFFLEdBQUdNLElBQUlRLE1BQU0sQ0FBQ0MscUJBQXFCO0lBRWhFLGtDQUFrQztJQUNsQyxNQUFNYixRQUFRRixJQUFJO0lBQ2xCLE1BQU1nQixPQUFRaEIsSUFBSTtJQUNsQixNQUFNQyxRQUFRRixJQUFJO0lBQ2xCLE1BQU1rQixTQUFTbEIsSUFBSSxPQUFPbUIsS0FBS0MsR0FBRyxDQUFDLEtBQUtwQixJQUFJO0lBQzVDLE1BQU1xQixPQUFRLENBQUNuQixRQUFRZ0IsTUFBSyxJQUFLO0lBQ2pDLE1BQU1JLFVBQVVuQixRQUFRZ0IsS0FBS0MsR0FBRyxDQUFDLElBQUluQixJQUFJO0lBRXpDLE1BQU1zQixJQUFJO1FBQ1I7WUFBRW5CLEdBQUdGO1lBQVFHLEdBQUdGO1FBQU07UUFDdEI7WUFBRUMsR0FBR0Y7WUFBUUcsR0FBR1k7UUFBTTtRQUN0QjtZQUFFYixHQUFHaUI7WUFBUWhCLEdBQUdpQjtRQUFRO1FBQ3hCO1lBQUVsQixHQUFHYztZQUFRYixHQUFHWTtRQUFNO1FBQ3RCO1lBQUViLEdBQUdjO1lBQVFiLEdBQUdGO1FBQU07S0FDdkI7SUFFRCx1QkFBdUI7SUFDdkIsTUFBTXFCLE9BQU87UUFDWDtZQUFFQyxH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SztnQkFDMUIsTUFBTWpELElBQUksSUFBS2dILElBQUt0SCxLQUFLNEMsRUFBRSxHQUFHO2dCQUM5Qm1DLElBQUlpQixJQUFJLENBQUM7b0JBQUV2RixHQUFHa0QsWUFBWSxRQUFTaUM7b0JBQVEzRyxHQUFHa0ksS0FBS25ILEtBQUtpRyxHQUFHLENBQUMzRixLQUFLdUY7b0JBQUszRyxHQUFHa0ksS0FBS3BILEtBQUtrRyxHQUFHLENBQUM1RixLQUFLdUY7Z0JBQUk7WUFDbEc7UUFDRjtRQUNBZCxJQUFJaUIsSUFBSSxDQUFDO1lBQUV2RixHQUFHa0QsWUFBWSxRQUFTaUM7WUFBUTNHLEdBQUdrSTtZQUFJakksR0FBR2tJO1lBQUkzRSxHQUFHMEM7UUFBSztJQUNuRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHM/NDZjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzXG50eXBlIFhZID0geyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG5cbi8qKiBMaW5rZXIgdW50ZXJlciBBbmtlciBleGFrdCB3aWUgaW0gTSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVNQW5jaG9yKHc6IG51bWJlciwgaDogbnVtYmVyKTogWFkge1xuICBjb25zdCBsZWZ0WCA9IHcgKiAwLjI4XG4gIGNvbnN0IGJhc2VZID0gaCAqIDAuNzRcbiAgcmV0dXJuIHsgeDogbGVmdFgsIHk6IGJhc2VZIH1cbn1cblxuLyoqXG4gKiBQZW4tU3dlZXA6IEVpbiBkaWdpdGFsZXIgU3RpZnQgZsOkaHJ0IGRlbiBQZmFkIFAw4oaSUDHihpJQMuKGklAz4oaSUDQgaW4gfjUgcyBhYlxuICogdW5kIHNldHp0IHVudGVyd2VncyBQdW5rdGUgKG1laHJlcmUgcGFyYWxsZWxlIFJlaWhlbiA9IFN0cmljaGJyZWl0ZSlcbiAqIG1pdCBNaW5kZXN0YWJzdGFuZC4gUnVuZGUgQ2FwcyArIHJ1bmRlIEpvaW5zOyBWYWxsZXktUGx1ZyBmw7xsbHQgZGllIFYtS2VyYmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENyeXN0YWxNKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhbmNob3I6IFhZKSB7XG4gIGNvbnN0IGlzTW9iaWxlID0gL01vYml8QW5kcm9pZHxpUGhvbmV8aVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgY29uc3QgeyB3aWR0aDogdywgaGVpZ2h0OiBoIH0gPSBjdHguY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgLy8gUHJvcG9ydGlvbmVuIChhdWZyZWNodGUgU8OkdWxlbilcbiAgY29uc3QgYmFzZVkgPSBoICogMC43NFxuICBjb25zdCB0b3BZICA9IGggKiAwLjM2XG4gIGNvbnN0IGxlZnRYID0gdyAqIDAuMjhcbiAgY29uc3QgcmlnaHRYID0gdyAqIDAuMjggKyBNYXRoLm1heCgzNjAsIHcgKiAwLjMyKVxuICBjb25zdCBtaWRYICA9IChsZWZ0WCArIHJpZ2h0WCkgLyAyXG4gIGNvbnN0IHZhbGxleVkgPSBiYXNlWSAtIE1hdGgubWF4KDkwLCBoICogMC4xNClcblxuICBjb25zdCBQID0gW1xuICAgIHsgeDogbGVmdFgsICB5OiBiYXNlWSB9LCAgIC8vIDBcbiAgICB7IHg6IGxlZnRYLCAgeTogdG9wWSAgfSwgICAvLyAxXG4gICAgeyB4OiBtaWRYLCAgIHk6IHZhbGxleVkgfSwgLy8gMlxuICAgIHsgeDogcmlnaHRYLCB5OiB0b3BZICB9LCAgIC8vIDNcbiAgICB7IHg6IHJpZ2h0WCwgeTogYmFzZVkgfSwgICAvLyA0XG4gIF0gYXMgY29uc3RcblxuICAvLyBTZWdtZW50ZSArIEdlb21ldHJpZVxuICBjb25zdCBzZWdzID0gW1xuICAgIHsgYTogUFswXSwgYjogUFsxXSB9LFxuICAgIHsgYTogUFsxXSwgYjogUFsyXSB9LFxuICAgIHsgYTogUFsyXSwgYjogUFszXSB9LFxuICAgIHsgYTogUFszXSwgYjogUFs0XSB9LFxuICBdLm1hcChzID0+IHtcbiAgICBjb25zdCBkeCA9IHMuYi54IC0gcy5hLnhcbiAgICBjb25zdCBkeSA9IHMuYi55IC0gcy5hLnlcbiAgICBjb25zdCBsZW4gPSBNYXRoLmh5cG90KGR4LCBkeSlcbiAgICBjb25zdCB0eCA9IGxlbiA/IGR4IC8gbGVuIDogMFxuICAgIGNvbnN0IHR5ID0gbGVuID8gZHkgLyBsZW4gOiAwXG4gICAgY29uc3QgbnggPSAgdHlcbiAgICBjb25zdCBueSA9IC10eFxuICAgIHJldHVybiB7IC4uLnMsIGR4LCBkeSwgbGVuLCB0eCwgdHksIG54LCBueSB9XG4gIH0pXG5cbiAgY29uc3QgdG90YWxMZW4gPSBzZWdzLnJlZHVjZSgocywgZykgPT4gcyArIGcubGVuLCAwKVxuXG4gIC8vIExvb2sgJiBSYXN0ZXJhYnN0w6RuZGVcbiAgY29uc3QgZG90UiAgICAgICAgPSBpc01vYmlsZSA/IDEuMyA6IDEuNlxuICBjb25zdCBtaW5HYXAgICAgICA9IGlzTW9iaWxlID8gMS44IDogMi4yXG4gIGNvbnN0IHN0ZXBBbG9uZyAgID0gTWF0aC5tYXgoaXNNb2JpbGUgPyAyLjQgOiAyLjAsIGRvdFIgKiAyICsgKG1pbkdhcCAtIDAuNikpXG4gIGNvbnN0IGdhcEFjcm9zcyAgID0gTWF0aC5tYXgoaXNNb2JpbGUgPyA0LjggOiA0LjIsIGRvdFIgKiAyICsgbWluR2FwKVxuICBjb25zdCB3aWR0aFB4ICAgICA9IGlzTW9iaWxlID8gMjggOiA1NlxuICBjb25zdCByb3dzICAgICAgICA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3Iod2lkdGhQeCAvIGdhcEFjcm9zcykpXG4gIGNvbnN0IGR1cmF0aW9uU2VjID0gNVxuXG4gIC8vIFplaXRzdGV1ZXJ1bmdcbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICBsZXQgcHJldlMgPSAwXG4gIGxldCByYWYgPSAwXG5cbiAgLy8gU3BhdGlhbCBIYXNoIChBYnN0YW5kcy1HYXJhbnRpZSlcbiAgY29uc3QgY2VsbCA9IE1hdGgubWluKHN0ZXBBbG9uZywgZ2FwQWNyb3NzKSAqIDAuOVxuICBjb25zdCBwbGFjZWQgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCBrZXkgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IGAke01hdGgucm91bmQoeCAvIGNlbGwpfToke01hdGgucm91bmQoeSAvIGNlbGwpfWBcbiAgY29uc3QgZHJhd0RvdCA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgcjogbnVtYmVyID0gZG90UikgPT4ge1xuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjNkJENUZGJ1xuICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDEwNywyMTMsMjU1LDAuNTUpJ1xuICAgIGN0eC5zaGFkb3dCbHVyID0gNFxuICAgIGN0eC5maWxsKClcbiAgfVxuICBjb25zdCB0cnlEb3QgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHI6IG51bWJlciA9IGRvdFIpID0+IHtcbiAgICBjb25zdCBrID0ga2V5KHgsIHkpXG4gICAgaWYgKHBsYWNlZC5oYXMoaykpIHJldHVybiBmYWxzZVxuICAgIHBsYWNlZC5hZGQoaylcbiAgICBkcmF3RG90KHgsIHksIHIpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEVyc3RwdW5rdCAoQW5jaG9yKVxuICB0cnlEb3QoYW5jaG9yLngsIGFuY2hvci55LCBkb3RSICsgMC45KVxuXG4gIC8vIEV4dHJhcyAoQ2Fwcy9Kb2lucy9WYWxsZXktUGx1Zykgdm9ycmVjaG5lbiwgaW4gU3dlZXAgZWluc29ydGllcmVuXG4gIHR5cGUgRXh0cmEgPSB7IHM6IG51bWJlcjsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHI/OiBudW1iZXIgfVxuICBjb25zdCBleHRyYXM6IEV4dHJhW10gPSBbXVxuXG4gIC8vIFN0YXJ0LUNhcCAoSGFsYmtyZWlzIGFtIFAwKVxuICBpZiAoc2Vnc1swXSkgcHVzaFJvdW5kQ2FwKGV4dHJhcywgUFswXSwgLXNlZ3NbMF0udHgsIC1zZWdzWzBdLnR5LCByb3dzLCBnYXBBY3Jvc3MsIGRvdFIsIHN0ZXBBbG9uZywgMClcblxuICAvLyBKb2lucyBhbiBQMSwgUDIsIFAzICgrIFZhbGxleS1QbHVnIGFuIFAyKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gc2Vnc1tpIC0gMV0sIG5leHQgPSBzZWdzW2ldXG4gICAgY29uc3Qgc0F0Q29ybmVyID0gc2Vncy5zbGljZSgwLCBpKS5yZWR1Y2UoKHMsIGcpID0+IHMgKyBnLmxlbiwgMClcbiAgICBwdXNoUm91bmRKb2luKGV4dHJhcywgUFtpXSwgcHJldiwgbmV4dCwgcm93cywgZ2FwQWNyb3NzLCBkb3RSLCBzdGVwQWxvbmcsIHNBdENvcm5lcilcbiAgICBpZiAoaSA9PT0gMikge1xuICAgICAgcHVzaFZhbGxleVBsdWcoZXh0cmFzLCBQWzJdLCBzZWdzWzFdLCBzZWdzWzJdLCByb3dzLCBnYXBBY3Jvc3MsIGRvdFIsIHNBdENvcm5lcilcbiAgICB9XG4gIH1cblxuICAvLyBFbmQtQ2FwIChIYWxia3JlaXMgYW0gUDQpXG4gIGNvbnN0IGxlbkJlZm9yZUVuZCA9IHNlZ3MucmVkdWNlKChzLCBnKSA9PiBzICsgZy5sZW4sIDApXG4gIHB1c2hSb3VuZENhcChleHRyYXMsIFBbNF0sIHNlZ3Nbc2Vncy5sZW5ndGggLSAxXS50eCwgc2Vnc1tzZWdzLmxlbmd0aCAtIDFdLnR5LCByb3dzLCBnYXBBY3Jvc3MsIGRvdFIsIHN0ZXBBbG9uZywgbGVuQmVmb3JlRW5kKVxuXG4gIGV4dHJhcy5zb3J0KChhLCBiKSA9PiBhLnMgLSBiLnMpXG4gIGxldCBleHRyYUlkeCA9IDBcblxuICAvLyBQRU4tU1dFRVBcbiAgZnVuY3Rpb24gdGljayhub3c6IG51bWJlcikge1xuICAgIGNvbnN0IHQgPSBNYXRoLm1pbigobm93IC0gc3RhcnQpIC8gKGR1cmF0aW9uU2VjICogMTAwMCksIDEpXG4gICAgY29uc3Qgc1RhcmdldCA9IHQgKiB0b3RhbExlblxuXG4gICAgLy8gZW50bGFuZyBkZXMgUGZhZHMgUHVua3RlIHNldHplbiAobWVocmVyZSBSZWloZW4gPSBTdHJpY2hicmVpdGUpXG4gICAgZm9yIChsZXQgcyA9IHByZXZTOyBzIDw9IHNUYXJnZXQ7IHMgKz0gc3RlcEFsb25nKSB7XG4gICAgICBjb25zdCBwb3MgPSBwb2ludEF0TGVuZ3RoKHMpXG4gICAgICBpZiAoIXBvcykgY29udGludWVcbiAgICAgIGNvbnN0IHsgeCwgeSwgbngsIG55IH0gPSBwb3NcbiAgICAgIGNvbnN0IGhhbGYgPSAocm93cyAtIDEpIC8gMlxuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHIgLSBoYWxmKSAqIGdhcEFjcm9zc1xuICAgICAgICB0cnlEb3QoeCArIG54ICogb2Zmc2V0LCB5ICsgbnkgKiBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHByZXZTID0gc1RhcmdldFxuXG4gICAgLy8gRXh0cmFzLCBkZXJlbiBzIGVycmVpY2h0IGlzdFxuICAgIHdoaWxlIChleHRyYUlkeCA8IGV4dHJhcy5sZW5ndGggJiYgZXh0cmFzW2V4dHJhSWR4XS5zIDw9IHNUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGUgPSBleHRyYXNbZXh0cmFJZHgrK11cbiAgICAgIHRyeURvdChlLngsIGUueSwgZS5yID8/IGRvdFIpXG4gICAgfVxuXG4gICAgaWYgKHQgPCAxIHx8IGV4dHJhSWR4IDwgZXh0cmFzLmxlbmd0aCkge1xuICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZilcbiAgICB9XG4gIH1cbiAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXG5cbiAgLy8gLS0tLS0tLS0tLSBIZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBmdW5jdGlvbiBwb2ludEF0TGVuZ3RoKHM6IG51bWJlcik6XG4gICAgfCB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBueDogbnVtYmVyOyBueTogbnVtYmVyIH1cbiAgICB8IG51bGwge1xuICAgIGxldCBhY2MgPSAwXG4gICAgZm9yIChjb25zdCBnIG9mIHNlZ3MpIHtcbiAgICAgIGlmIChzIDw9IGFjYyArIGcubGVuKSB7XG4gICAgICAgIGNvbnN0IGQgPSBzIC0gYWNjXG4gICAgICAgIGNvbnN0IHQgPSBnLmxlbiA/IGQgLyBnLmxlbiA6IDBcbiAgICAgICAgY29uc3QgeCA9IGcuYS54ICsgZy5keCAqIHRcbiAgICAgICAgY29uc3QgeSA9IGcuYS55ICsgZy5keSAqIHRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSwgbng6IGcubngsIG55OiBnLm55IH1cbiAgICAgIH1cbiAgICAgIGFjYyArPSBnLmxlblxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gc2Vnc1tzZWdzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHsgeDogbGFzdC5iLngsIHk6IGxhc3QuYi55LCBueDogbGFzdC5ueSwgbnk6IC1sYXN0Lm54IH1cbiAgfVxuXG4gIC8vIHJ1bmRlciBFbmQtQ2FwIChIYWxia3JlaXMpXG4gIGZ1bmN0aW9uIHB1c2hSb3VuZENhcChcbiAgICBvdXQ6IEV4dHJhW10sIEM6IFhZLCB0eDogbnVtYmVyLCB0eTogbnVtYmVyLFxuICAgIG5Sb3dzOiBudW1iZXIsIGFjcm9zczogbnVtYmVyLCByRG90OiBudW1iZXIsIGFsb25nOiBudW1iZXIsIHNCYXNlOiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgaGFsZiA9IChuUm93cyAtIDEpIC8gMlxuICAgIGNvbnN0IHJhZGl1cyA9IGhhbGYgKiBhY3Jvc3NcbiAgICBjb25zdCBhcmNTdGFydCA9IE1hdGguYXRhbjIoLXR5LCAtdHgpIC0gTWF0aC5QSSAvIDJcbiAgICBjb25zdCBhcmNFbmQgICA9IGFyY1N0YXJ0ICsgTWF0aC5QSVxuXG4gICAgY29uc3QgcmluZ1N0ZXAgPSBNYXRoLm1heChyRG90ICogMiArIG1pbkdhcCwgYWNyb3NzICogMC45KVxuICAgIGNvbnN0IHJpbmdzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyYWRpdXMgLyByaW5nU3RlcCkpXG4gICAgbGV0IHNlcSA9IDBcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSByaW5nczsgcisrKSB7XG4gICAgICBjb25zdCByYWQgPSByICogcmluZ1N0ZXBcbiAgICAgIGNvbnN0IGNpcmMgPSAyICogTWF0aC5QSSAqIE1hdGgubWF4KHJhZCwgMSlcbiAgICAgIGNvbnN0IHB0cyA9IE1hdGgubWF4KDYsIE1hdGguZmxvb3IoY2lyYyAvIChyRG90ICogMiArIG1pbkdhcCkpKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcHRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFyY1N0YXJ0ICsgKGkgLyBwdHMpICogKGFyY0VuZCAtIGFyY1N0YXJ0KVxuICAgICAgICBvdXQucHVzaCh7IHM6IHNCYXNlICsgMC4wMDEgKiAoc2VxKyspLCB4OiBDLnggKyBNYXRoLmNvcyhhKSAqIHJhZCwgeTogQy55ICsgTWF0aC5zaW4oYSkgKiByYWQgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBydW5kZXIgSm9pbiAoU2VrdG9yKSB6d2lzY2hlbiB6d2VpIFNlZ21lbnRlbiBhbSBFY2twdW5rdCBDIChzdGFiaWwsIGlua2wuIExhcmdlLUFyYylcbiAgZnVuY3Rpb24gcHVzaFJvdW5kSm9pbihcbiAgICBvdXQ6IEV4dHJhW10sIEM6IFhZLCBwcmV2OiBhbnksIG5leHQ6IGFueSxcbiAgICBuUm93czogbnVtYmVyLCBhY3Jvc3M6IG51bWJlciwgckRvdDogbnVtYmVyLCBhbG9uZzogbnVtYmVyLCBzQXRDb3JuZXI6IG51bWJlclxuICApIHtcbiAgICBjb25zdCBhSW4gID0gTWF0aC5hdGFuMihwcmV2Lm55LCBwcmV2Lm54KVxuICAgIGNvbnN0IGFPdXQgPSBNYXRoLmF0YW4yKG5leHQubnksIG5leHQubngpXG5cbiAgICAvLyBUYW5nZW50ZW4gKGbDvHIga29ua2F2L2tvbnZleClcbiAgICBsZXQgdEluICA9IE1hdGguYXRhbjIocHJldi50eSwgcHJldi50eClcbiAgICBsZXQgdE91dCA9IE1hdGguYXRhbjIobmV4dC50eSwgbmV4dC50eClcbiAgICB3aGlsZSAodE91dCAtIHRJbiA8PSAtTWF0aC5QSSkgdE91dCArPSAyICogTWF0aC5QSVxuICAgIHdoaWxlICh0T3V0IC0gdEluID4gICBNYXRoLlBJKSB0T3V0IC09IDIgKiBNYXRoLlBJXG4gICAgY29uc3QgdHVybiA9IHRPdXQgLSB0SW5cblxuICAgIC8vIFdpbmtlbC1EaWZmZXJlbnogZGVyIE5vcm1hbGVuIGF1ZiBbLc+ALM+AXVxuICAgIGxldCBkZWx0YSA9IGFPdXQgLSBhSW5cbiAgICB3aGlsZSAoZGVsdGEgPD0gLU1hdGguUEkpIGRlbHRhICs9IDIgKiBNYXRoLlBJXG4gICAgd2hpbGUgKGRlbHRhID4gICBNYXRoLlBJKSBkZWx0YSAtPSAyICogTWF0aC5QSVxuXG4gICAgLy8ga29ua2F2IOKGkiBncm/Dn2VuIEJvZ2VuIG5laG1lblxuICAgIGNvbnN0IHVzZUxhcmdlQXJjID0gTWF0aC5hYnModHVybikgPiAoTWF0aC5QSSAvIDIpXG4gICAgbGV0IHN0YXJ0QW5nbGUgPSBhSW5cbiAgICBsZXQgZW5kQW5nbGUgICA9IGFJbiArIGRlbHRhXG4gICAgaWYgKHVzZUxhcmdlQXJjKSB7XG4gICAgICBpZiAoZGVsdGEgPiAwKSBlbmRBbmdsZSA9IGFJbiAtICgyICogTWF0aC5QSSAtIGRlbHRhKVxuICAgICAgZWxzZSAgICAgICAgICAgZW5kQW5nbGUgPSBhSW4gKyAoMiAqIE1hdGguUEkgKyBkZWx0YSlcbiAgICB9XG5cbiAgICBjb25zdCByYWRpdXMgICA9ICgoblJvd3MgLSAxKSAqIGFjcm9zcykgLyAyXG4gICAgY29uc3QgcmluZ1N0ZXAgPSBNYXRoLm1heChyRG90ICogMiArIG1pbkdhcCwgYWNyb3NzICogMC45KVxuICAgIGNvbnN0IHJpbmdzICAgID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyYWRpdXMgLyByaW5nU3RlcCkpXG4gICAgY29uc3QgYW5nU3RlcCAgPSBNYXRoLm1heCgockRvdCAqIDIgKyBtaW5HYXApIC8gTWF0aC5tYXgocmFkaXVzLCAxKSwgTWF0aC5QSSAvIDM2KVxuXG4gICAgY29uc3QgZGlyID0gZW5kQW5nbGUgPj0gc3RhcnRBbmdsZSA/IDEgOiAtMVxuICAgIGxldCBzZXEgPSAwXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gcmluZ3M7IHIrKykge1xuICAgICAgY29uc3QgcmFkID0gciAqIHJpbmdTdGVwXG4gICAgICBmb3IgKGxldCBhID0gc3RhcnRBbmdsZTsgZGlyID4gMCA/IGEgPD0gZW5kQW5nbGUgOiBhID49IGVuZEFuZ2xlOyBhICs9IGRpciAqIGFuZ1N0ZXApIHtcbiAgICAgICAgb3V0LnB1c2goe1xuICAgICAgICAgIHM6IHNBdENvcm5lciArIDAuMDAxICogKHNlcSsrKSxcbiAgICAgICAgICB4OiBDLnggKyBNYXRoLmNvcyhhKSAqIHJhZCxcbiAgICAgICAgICB5OiBDLnkgKyBNYXRoLnNpbihhKSAqIHJhZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBvdXQucHVzaCh7IHM6IHNBdENvcm5lciArIDAuMDAyICogKHNlcSsrKSwgeDogQy54LCB5OiBDLnksIHI6IHJEb3QgfSlcbiAgfVxuXG4gIC8vIGbDvGxsdCBkaWUgaW5uZXJlIFYtRWNrZSAoVGFsKSB3ZWljaFxuICBmdW5jdGlvbiBwdXNoVmFsbGV5UGx1ZyhcbiAgICBvdXQ6IEV4dHJhW10sIEM6IFhZLCBwcmV2OiBhbnksIG5leHQ6IGFueSxcbiAgICBuUm93czogbnVtYmVyLCBhY3Jvc3M6IG51bWJlciwgckRvdDogbnVtYmVyLCBzQXRDb3JuZXI6IG51bWJlclxuICApIHtcbiAgICAvLyBJbm5lbi1CaXNla3RvclxuICAgIGxldCBieCA9IC1wcmV2LnR4ICsgbmV4dC50eFxuICAgIGxldCBieSA9IC1wcmV2LnR5ICsgbmV4dC50eVxuICAgIGNvbnN0IGJsID0gTWF0aC5oeXBvdChieCwgYnkpIHx8IDE7IGJ4IC89IGJsOyBieSAvPSBibFxuXG4gICAgY29uc3QgaW5uZXJSID0gKChuUm93cyAtIDEpICogYWNyb3NzKSAqIDAuNDhcbiAgICBjb25zdCBjeCA9IEMueCArIGJ4ICogKGlubmVyUiAqIDAuMzUpXG4gICAgY29uc3QgY3kgPSBDLnkgKyBieSAqIChpbm5lclIgKiAwLjM1KVxuXG4gICAgY29uc3QgcmluZ1N0ZXAgPSBNYXRoLm1heChyRG90ICogMi4wLCBhY3Jvc3MgKiAwLjkpXG4gICAgY29uc3QgcmluZ3MgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKGlubmVyUiAvIHJpbmdTdGVwKSlcblxuICAgIGxldCBzZXEgPSAwXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gcmluZ3M7IHIrKykge1xuICAgICAgY29uc3QgcmFkID0gKHIgLyByaW5ncykgKiBpbm5lclJcbiAgICAgIGNvbnN0IGNpcmMgPSAyICogTWF0aC5QSSAqIE1hdGgubWF4KHJhZCwgMSlcbiAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heChyRG90ICogMi4wLCBhY3Jvc3MgKiAwLjkpXG4gICAgICBjb25zdCBuID0gTWF0aC5tYXgoOCwgTWF0aC5mbG9vcihjaXJjIC8gc3RlcCkpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCBhID0gKGkgLyBuKSAqIE1hdGguUEkgKiAyXG4gICAgICAgIG91dC5wdXNoKHsgczogc0F0Q29ybmVyICsgMC4wMDEgKiAoc2VxKyspLCB4OiBjeCArIE1hdGguY29zKGEpICogcmFkLCB5OiBjeSArIE1hdGguc2luKGEpICogcmFkIH0pXG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKHsgczogc0F0Q29ybmVyICsgMC4wMDIgKiAoc2VxKyspLCB4OiBjeCwgeTogY3ksIHI6IHJEb3QgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImNvbXB1dGVNQW5jaG9yIiwidyIsImgiLCJsZWZ0WCIsImJhc2VZIiwieCIsInkiLCJidWlsZENyeXN0YWxNIiwiY3R4IiwiYW5jaG9yIiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJjYW52YXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3BZIiwicmlnaHRYIiwiTWF0aCIsIm1heCIsIm1pZFgiLCJ2YWxsZXlZIiwiUCIsInNlZ3MiLCJhIiwiYiIsIm1hcCIsInMiLCJkeCIsImR5IiwibGVuIiwiaHlwb3QiLCJ0eCIsInR5IiwibngiLCJueSIsInRvdGFsTGVuIiwicmVkdWNlIiwiZyIsImRvdFIiLCJtaW5HYXAiLCJzdGVwQWxvbmciLCJnYXBBY3Jvc3MiLCJ3aWR0aFB4Iiwicm93cyIsImZsb29yIiwiZHVyYXRpb25TZWMiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwibm93IiwicHJldlMiLCJyYWYiLCJjZWxsIiwibWluIiwicGxhY2VkIiwiU2V0Iiwia2V5Iiwicm91bmQiLCJkcmF3RG90IiwiciIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiZmlsbCIsInRyeURvdCIsImsiLCJoYXMiLCJhZGQiLCJleHRyYXMiLCJwdXNoUm91bmRDYXAiLCJpIiwibGVuZ3RoIiwicHJldiIsIm5leHQiLCJzQXRDb3JuZXIiLCJzbGljZSIsInB1c2hSb3VuZEpvaW4iLCJwdXNoVmFsbGV5UGx1ZyIsImxlbkJlZm9yZUVuZCIsInNvcnQiLCJleHRyYUlkeCIsInRpY2siLCJ0Iiwic1RhcmdldCIsInBvcyIsInBvaW50QXRMZW5ndGgiLCJoYWxmIiwib2Zmc2V0IiwiZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiYWNjIiwiZCIsImxhc3QiLCJvdXQiLCJDIiwiblJvd3MiLCJhY3Jvc3MiLCJyRG90IiwiYWxvbmciLCJzQmFzZSIsInJhZGl1cyIsImFyY1N0YXJ0IiwiYXRhbjIiLCJhcmNFbmQiLCJyaW5nU3RlcCIsInJpbmdzIiwic2VxIiwicmFkIiwiY2lyYyIsInB0cyIsInB1c2giLCJjb3MiLCJzaW4iLCJhSW4iLCJhT3V0IiwidEluIiwidE91dCIsInR1cm4iLCJkZWx0YSIsInVzZUxhcmdlQXJjIiwiYWJzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYW5nU3RlcCIsImRpciIsImJ4IiwiYnkiLCJibCIsImlubmVyUiIsImN4IiwiY3kiLCJzdGVwIiwibiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});