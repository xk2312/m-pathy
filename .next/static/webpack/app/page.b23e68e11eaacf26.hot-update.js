"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n// Punkt-M (~3000 Punkte), Entfaltung vom Anchor. Keine Linien.\nfunction buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    // Geometrie in CSS-Pixeln planen (Canvas ist via setTransform DPR-korrigiert)\n    const rect = ctx.canvas.getBoundingClientRect();\n    const w = rect.width;\n    const h = rect.height;\n    // M-Kontrollpunkte (responsive)\n    const baseX = w * 0.30;\n    const baseY = h * 0.70;\n    const spanX = Math.max(200, w * 0.24);\n    const peakY = Math.min(baseY - h * 0.30, h * 0.40);\n    const P = [\n        {\n            x: baseX,\n            y: baseY\n        },\n        {\n            x: baseX + spanX * 0.25,\n            y: peakY\n        },\n        {\n            x: baseX + spanX * 0.50,\n            y: baseY * 0.93\n        },\n        {\n            x: baseX + spanX * 0.75,\n            y: peakY\n        },\n        {\n            x: baseX + spanX,\n            y: baseY\n        }\n    ];\n    // Segmente des M\n    const segs = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ];\n    // Punktwolke generieren (~3000 Desktop / ~1600 Mobile)\n    const totalLen = segs.reduce((s, param)=>{\n        let { a, b } = param;\n        return s + Math.hypot(b.x - a.x, b.y - a.y);\n    }, 0);\n    const targetCount = isMobile ? 1600 : 3000;\n    const density = targetCount / totalLen;\n    const points = [];\n    for (const { a, b } of segs){\n        const len = Math.hypot(b.x - a.x, b.y - a.y);\n        const n = Math.max(2, Math.floor(len * density));\n        for(let i = 0; i < n; i++){\n            const t = i / (n - 1);\n            let x = a.x + (b.x - a.x) * t;\n            let y = a.y + (b.y - a.y) * t;\n            // kleiner orthogonaler Jitter für kristallige Lebendigkeit\n            const nx = (b.y - a.y) / len;\n            const ny = -(b.x - a.x) / len;\n            const jitter = (isMobile ? 0.6 : 1.0) * (Math.random() - 0.5) * 2;\n            x += nx * jitter;\n            y += ny * jitter;\n            points.push({\n                x,\n                y\n            });\n        }\n    }\n    // Reihenfolge: Wellenfront vom Anchor + leichte Zufallsvarianz\n    points.sort((p1, p2)=>{\n        const d1 = Math.hypot(p1.x - anchor.x, p1.y - anchor.y);\n        const d2 = Math.hypot(p2.x - anchor.x, p2.y - anchor.y);\n        return d1 - d2 + (Math.random() - 0.5) * 8;\n    });\n    // erster Punkt (Meteor/Anchor)\n    drawGold(anchor.x, anchor.y, isMobile ? 2.6 : 3.2);\n    let idx = 0;\n    const perFrame = isMobile ? 60 : 120;\n    const r = isMobile ? 1.4 : 1.8;\n    function frame() {\n        // nicht clearen – Punkte akkumulieren\n        for(let i = 0; i < perFrame && idx < points.length; i++, idx++){\n            const p = points[idx];\n            drawGold(p.x, p.y, r);\n        }\n        if (idx < points.length) requestAnimationFrame(frame);\n    }\n    requestAnimationFrame(frame);\n    function drawGold(x, y, rad) {\n        ctx.beginPath();\n        ctx.arc(x, y, rad, 0, Math.PI * 2);\n        ctx.fillStyle = \"#ffd700\";\n        ctx.shadowColor = \"rgba(255,215,0,0.9)\";\n        ctx.shadowBlur = 12;\n        ctx.fill();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLCtCQUErQjtBQUcvQiwrREFBK0Q7QUFDeEQsU0FBU0EsY0FBY0MsR0FBNkIsRUFBRUMsTUFBVTtJQUNyRSxNQUFNQyxXQUFXLDRCQUE0QkMsSUFBSSxDQUFDQyxVQUFVQyxTQUFTO0lBRXJFLDhFQUE4RTtJQUM5RSxNQUFNQyxPQUFPTixJQUFJTyxNQUFNLENBQUNDLHFCQUFxQjtJQUM3QyxNQUFNQyxJQUFJSCxLQUFLSSxLQUFLO0lBQ3BCLE1BQU1DLElBQUlMLEtBQUtNLE1BQU07SUFFckIsZ0NBQWdDO0lBQ2hDLE1BQU1DLFFBQVFKLElBQUk7SUFDbEIsTUFBTUssUUFBUUgsSUFBSTtJQUNsQixNQUFNSSxRQUFRQyxLQUFLQyxHQUFHLENBQUMsS0FBS1IsSUFBSTtJQUNoQyxNQUFNUyxRQUFRRixLQUFLRyxHQUFHLENBQUNMLFFBQVFILElBQUksTUFBTUEsSUFBSTtJQUU3QyxNQUFNUyxJQUFJO1FBQ1I7WUFBRUMsR0FBR1I7WUFBcUJTLEdBQUdSO1FBQU07UUFDbkM7WUFBRU8sR0FBR1IsUUFBUUUsUUFBUTtZQUFNTyxHQUFHSjtRQUFNO1FBQ3BDO1lBQUVHLEdBQUdSLFFBQVFFLFFBQVE7WUFBTU8sR0FBR1IsUUFBUTtRQUFLO1FBQzNDO1lBQUVPLEdBQUdSLFFBQVFFLFFBQVE7WUFBTU8sR0FBR0o7UUFBTTtRQUNwQztZQUFFRyxHQUFHUixRQUFRRTtZQUFjTyxHQUFHUjtRQUFNO0tBQ3JDO0lBRUQsaUJBQWlCO0lBQ2pCLE1BQU1TLE9BQU87UUFDWDtZQUFFQyxHQUFHSixDQUFDLENBQUMsRUFBRTtZQUFFSyxHQUFHTCxDQUFDLENBQUMsRUFBRTtRQUFDO1FBQ25CO1lBQUVJLEdBQUdKLENBQUMsQ0FBQyxFQUFFO1lBQUVLLEdBQUdMLENBQUMsQ0FBQyxFQUFFO1FBQUM7UUFDbkI7WUFBRUksR0FBR0osQ0FBQyxDQUFDLEVB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QU9xQixNQUFNLEVBQUVFLHNCQUFzQkg7SUFDakQ7SUFDQUcsc0JBQXNCSDtJQUV0QixTQUFTSixTQUFTM0IsQ0FBUyxFQUFFQyxDQUFTLEVBQUVrQyxHQUFXO1FBQ2pEeEQsSUFBSXlELFNBQVM7UUFDYnpELElBQUkwRCxHQUFHLENBQUNyQyxHQUFHQyxHQUFHa0MsS0FBSyxHQUFHeEMsS0FBSzJDLEVBQUUsR0FBRztRQUNoQzNELElBQUk0RCxTQUFTLEdBQUc7UUFDaEI1RCxJQUFJNkQsV0FBVyxHQUFHO1FBQ2xCN0QsSUFBSThELFVBQVUsR0FBRztRQUNqQjlELElBQUkrRCxJQUFJO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzPzQ2YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXBwL21vZHVsZXMvY3J5c3RhbEVuZ2luZS50c1xudHlwZSBYWSA9IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuXG4vLyBQdW5rdC1NICh+MzAwMCBQdW5rdGUpLCBFbnRmYWx0dW5nIHZvbSBBbmNob3IuIEtlaW5lIExpbmllbi5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENyeXN0YWxNKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhbmNob3I6IFhZKSB7XG4gIGNvbnN0IGlzTW9iaWxlID0gL01vYml8QW5kcm9pZHxpUGhvbmV8aVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcblxuICAvLyBHZW9tZXRyaWUgaW4gQ1NTLVBpeGVsbiBwbGFuZW4gKENhbnZhcyBpc3QgdmlhIHNldFRyYW5zZm9ybSBEUFIta29ycmlnaWVydClcbiAgY29uc3QgcmVjdCA9IGN0eC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgY29uc3QgdyA9IHJlY3Qud2lkdGhcbiAgY29uc3QgaCA9IHJlY3QuaGVpZ2h0XG5cbiAgLy8gTS1Lb250cm9sbHB1bmt0ZSAocmVzcG9uc2l2ZSlcbiAgY29uc3QgYmFzZVggPSB3ICogMC4zMFxuICBjb25zdCBiYXNlWSA9IGggKiAwLjcwXG4gIGNvbnN0IHNwYW5YID0gTWF0aC5tYXgoMjAwLCB3ICogMC4yNClcbiAgY29uc3QgcGVha1kgPSBNYXRoLm1pbihiYXNlWSAtIGggKiAwLjMwLCBoICogMC40MClcblxuICBjb25zdCBQID0gW1xuICAgIHsgeDogYmFzZVgsICAgICAgICAgICAgICAgeTogYmFzZVkgfSxcbiAgICB7IHg6IGJhc2VYICsgc3BhblggKiAwLjI1LCB5OiBwZWFrWSB9LFxuICAgIHsgeDogYmFzZVggKyBzcGFuWCAqIDAuNTAsIHk6IGJhc2VZICogMC45MyB9LFxuICAgIHsgeDogYmFzZVggKyBzcGFuWCAqIDAuNzUsIHk6IHBlYWtZIH0sXG4gICAgeyB4OiBiYXNlWCArIHNwYW5YLCAgICAgICAgeTogYmFzZVkgfSxcbiAgXSBhcyBjb25zdFxuXG4gIC8vIFNlZ21lbnRlIGRlcyBNXG4gIGNvbnN0IHNlZ3MgPSBbXG4gICAgeyBhOiBQWzBdLCBiOiBQWzFdIH0sXG4gICAgeyBhOiBQWzFdLCBiOiBQWzJdIH0sXG4gICAgeyBhOiBQWzJdLCBiOiBQWzNdIH0sXG4gICAgeyBhOiBQWzNdLCBiOiBQWzRdIH0sXG4gIF1cblxuICAvLyBQdW5rdHdvbGtlIGdlbmVyaWVyZW4gKH4zMDAwIERlc2t0b3AgLyB+MTYwMCBNb2JpbGUpXG4gIGNvbnN0IHRvdGFsTGVuID0gc2Vncy5yZWR1Y2UoKHMsIHsgYSwgYiB9KSA9PiBzICsgTWF0aC5oeXBvdChiLnggLSBhLngsIGIueSAtIGEueSksIDApXG4gIGNvbnN0IHRhcmdldENvdW50ID0gaXNNb2JpbGUgPyAxNjAwIDogMzAwMFxuICBjb25zdCBkZW5zaXR5ID0gdGFyZ2V0Q291bnQgLyB0b3RhbExlblxuXG4gIGNvbnN0IHBvaW50czogWFlbXSA9IFtdXG4gIGZvciAoY29uc3QgeyBhLCBiIH0gb2Ygc2Vncykge1xuICAgIGNvbnN0IGxlbiA9IE1hdGguaHlwb3QoYi54IC0gYS54LCBiLnkgLSBhLnkpXG4gICAgY29uc3QgbiA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IobGVuICogZGVuc2l0eSkpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSBpIC8gKG4gLSAxKVxuICAgICAgbGV0IHggPSBhLnggKyAoYi54IC0gYS54KSAqIHRcbiAgICAgIGxldCB5ID0gYS55ICsgKGIueSAtIGEueSkgKiB0XG4gICAgICAvLyBrbGVpbmVyIG9ydGhvZ29uYWxlciBKaXR0ZXIgZsO8ciBrcmlzdGFsbGlnZSBMZWJlbmRpZ2tlaXRcbiAgICAgIGNvbnN0IG54ID0gKGIueSAtIGEueSkgLyBsZW5cbiAgICAgIGNvbnN0IG55ID0gLShiLnggLSBhLngpIC8gbGVuXG4gICAgICBjb25zdCBqaXR0ZXIgPSAoaXNNb2JpbGUgPyAwLjYgOiAxLjApICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMlxuICAgICAgeCArPSBueCAqIGppdHRlclxuICAgICAgeSArPSBueSAqIGppdHRlclxuICAgICAgcG9pbnRzLnB1c2goeyB4LCB5IH0pXG4gICAgfVxuICB9XG5cbiAgLy8gUmVpaGVuZm9sZ2U6IFdlbGxlbmZyb250IHZvbSBBbmNob3IgKyBsZWljaHRlIFp1ZmFsbHN2YXJpYW56XG4gIHBvaW50cy5zb3J0KChwMSwgcDIpID0+IHtcbiAgICBjb25zdCBkMSA9IE1hdGguaHlwb3QocDEueCAtIGFuY2hvci54LCBwMS55IC0gYW5jaG9yLnkpXG4gICAgY29uc3QgZDIgPSBNYXRoLmh5cG90KHAyLnggLSBhbmNob3IueCwgcDIueSAtIGFuY2hvci55KVxuICAgIHJldHVybiAoZDEgLSBkMikgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA4XG4gIH0pXG5cbiAgLy8gZXJzdGVyIFB1bmt0IChNZXRlb3IvQW5jaG9yKVxuICBkcmF3R29sZChhbmNob3IueCwgYW5jaG9yLnksIGlzTW9iaWxlID8gMi42IDogMy4yKVxuXG4gIGxldCBpZHggPSAwXG4gIGNvbnN0IHBlckZyYW1lID0gaXNNb2JpbGUgPyA2MCA6IDEyMFxuICBjb25zdCByID0gaXNNb2JpbGUgPyAxLjQgOiAxLjhcblxuICBmdW5jdGlvbiBmcmFtZSgpIHtcbiAgICAvLyBuaWNodCBjbGVhcmVuIOKAkyBQdW5rdGUgYWtrdW11bGllcmVuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJGcmFtZSAmJiBpZHggPCBwb2ludHMubGVuZ3RoOyBpKyssIGlkeCsrKSB7XG4gICAgICBjb25zdCBwID0gcG9pbnRzW2lkeF1cbiAgICAgIGRyYXdHb2xkKHAueCwgcC55LCByKVxuICAgIH1cbiAgICBpZiAoaWR4IDwgcG9pbnRzLmxlbmd0aCkgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKVxuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSlcblxuICBmdW5jdGlvbiBkcmF3R29sZCh4OiBudW1iZXIsIHk6IG51bWJlciwgcmFkOiBudW1iZXIpIHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguYXJjKHgsIHksIHJhZCwgMCwgTWF0aC5QSSAqIDIpXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZkNzAwJ1xuICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDI1NSwyMTUsMCwwLjkpJ1xuICAgIGN0eC5zaGFkb3dCbHVyID0gMTJcbiAgICBjdHguZmlsbCgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJidWlsZENyeXN0YWxNIiwiY3R4IiwiYW5jaG9yIiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicmVjdCIsImNhbnZhcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJiYXNlWCIsImJhc2VZIiwic3BhblgiLCJNYXRoIiwibWF4IiwicGVha1kiLCJtaW4iLCJQIiwieCIsInkiLCJzZWdzIiwiYSIsImIiLCJ0b3RhbExlbiIsInJlZHVjZSIsInMiLCJoeXBvdCIsInRhcmdldENvdW50IiwiZGVuc2l0eSIsInBvaW50cyIsImxlbiIsIm4iLCJmbG9vciIsImkiLCJ0IiwibngiLCJueSIsImppdHRlciIsInJhbmRvbSIsInB1c2giLCJzb3J0IiwicDEiLCJwMiIsImQxIiwiZDIiLCJkcmF3R29sZCIsImlkeCIsInBlckZyYW1lIiwiciIsImZyYW1lIiwibGVuZ3RoIiwicCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJhZCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});