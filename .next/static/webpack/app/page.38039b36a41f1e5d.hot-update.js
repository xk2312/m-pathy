"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; },\n/* harmony export */   computeMAnchor: function() { return /* binding */ computeMAnchor; }\n/* harmony export */ });\n/** Linker unterer Anker exakt wie im M */ function computeMAnchor(w, h) {\n    const leftX = w * 0.28;\n    const baseY = h * 0.74;\n    return {\n        x: leftX,\n        y: baseY\n    };\n}\n/**\n * Pen-Sweep mit runden Caps & runden Joins.\n * Ein digitaler Stift fährt den Pfad P0→P1→P2→P3→P4 in ~5s ab und\n * setzt unterwegs Rasterpunkte. An Start/Ende gibt es runde Caps,\n * an den Knicken runde „Join“-Sektoren — alles in die Sweep-Zeitreihe\n * einsortiert ⇒ aus einem Guss.\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    const { width: w, height: h } = ctx.canvas.getBoundingClientRect();\n    // Proportionen: aufrechte Säulen, edel\n    const baseY = h * 0.74;\n    const topY = h * 0.36;\n    const leftX = w * 0.28;\n    const rightX = w * 0.28 + Math.max(360, w * 0.32);\n    const midX = (leftX + rightX) / 2;\n    const valleyY = baseY - Math.max(90, h * 0.14);\n    const P = [\n        {\n            x: leftX,\n            y: baseY\n        },\n        {\n            x: leftX,\n            y: topY\n        },\n        {\n            x: midX,\n            y: valleyY\n        },\n        {\n            x: rightX,\n            y: topY\n        },\n        {\n            x: rightX,\n            y: baseY\n        }\n    ];\n    // Segmente plus Geometrie\n    const segs = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ].map((s)=>{\n        const dx = s.b.x - s.a.x;\n        const dy = s.b.y - s.a.y;\n        const len = Math.hypot(dx, dy);\n        const tx = len ? dx / len : 0;\n        const ty = len ? dy / len : 0;\n        const nx = ty;\n        const ny = -tx;\n        return {\n            ...s,\n            dx,\n            dy,\n            len,\n            tx,\n            ty,\n            nx,\n            ny\n        };\n    });\n    const totalLen = segs.reduce((s, g)=>s + g.len, 0);\n    // Look & Rasterabstände (breit, dicht, aber mit Lücken)\n    const dotR = isMobile ? 1.3 : 1.6;\n    const minGap = isMobile ? 1.8 : 2.2;\n    const stepAlong = Math.max(isMobile ? 2.4 : 2.0, dotR * 2 + (minGap - 0.6)) // Abstand auf Linie\n    ;\n    const gapAcross = Math.max(isMobile ? 4.8 : 4.2, dotR * 2 + minGap) // Abstand Reihen\n    ;\n    const widthPx = isMobile ? 28 : 56;\n    const rows = Math.max(1, Math.floor(widthPx / gapAcross)) // Pinselbreite (Reihen)\n    ;\n    const durationSec = 5;\n    // Zeitsteuerung (FPS-unabhängig)\n    const start = performance.now();\n    let prevS = 0;\n    let raf = 0;\n    // Spatial Hash für Abstands-Garantie\n    const cell = Math.min(stepAlong, gapAcross) * 0.9;\n    const placed = new Set();\n    const key = (x, y)=>\"\".concat(Math.round(x / cell), \":\").concat(Math.round(y / cell));\n    const tryDot = function(x, y) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : dotR;\n        const k = key(x, y);\n        if (placed.has(k)) return false;\n        placed.add(k);\n        drawDot(x, y, r);\n        return true;\n    };\n    // Erstpunkt (Anchor)\n    tryDot(anchor.x, anchor.y, dotR + 0.9);\n    const extras = [];\n    // Start-Cap (Halbkreis am P0, normal steht quer zum ersten Segment)\n    if (segs[0]) pushRoundCap(extras, P[0], -segs[0].tx, -segs[0].ty, rows, gapAcross, dotR, stepAlong, 0);\n    // Joins an P1, P2, P3 (rundes Eck – Sektor zwischen den Normen)\n    for(let i = 1; i < segs.length; i++){\n        const prev = segs[i - 1], next = segs[i];\n        pushRoundJoin(extras, P[i], prev, next, rows, gapAcross, dotR, stepAlong, segs.slice(0, i).reduce((s, g)=>s + g.len, 0));\n    }\n    // End-Cap (Halbkreis am P4)\n    const lenBeforeEnd = segs.slice(0, segs.length - 1).reduce((s, g)=>s + g.len, 0) + segs[segs.length - 1].len;\n    pushRoundCap(extras, P[4], segs[segs.length - 1].tx, segs[segs.length - 1].ty, rows, gapAcross, dotR, stepAlong, lenBeforeEnd);\n    // Gesamtliste: Sweep-Punkte + Extras (später in zeitlicher Reihenfolge gezeichnet)\n    extras.sort((a, b)=>a.s - b.s);\n    let extraIdx = 0;\n    // PEN-SWEEP\n    function tick(now) {\n        const t = Math.min((now - start) / (durationSec * 1000), 1);\n        const sTarget = t * totalLen;\n        // Linie abfahren, Punkte setzen\n        for(let s = prevS; s <= sTarget; s += stepAlong){\n            const pos = pointAtLength(s);\n            if (!pos) continue;\n            const { x, y, nx, ny } = pos;\n            const half = (rows - 1) / 2;\n            for(let r = 0; r < rows; r++){\n                const offset = (r - half) * gapAcross;\n                tryDot(x + nx * offset, y + ny * offset);\n            }\n        }\n        prevS = sTarget;\n        // Extras einspeisen, deren s innerhalb des aktuellen Fensters liegt\n        while(extraIdx < extras.length && extras[extraIdx].s <= sTarget){\n            const e = extras[extraIdx++];\n            var _e_r;\n            tryDot(e.x, e.y, (_e_r = e.r) !== null && _e_r !== void 0 ? _e_r : dotR);\n        }\n        if (t < 1 || extraIdx < extras.length) {\n            raf = requestAnimationFrame(tick);\n        } else {\n            cancelAnimationFrame(raf);\n        }\n    }\n    raf = requestAnimationFrame(tick);\n    // --- Helpers --------------------------------------------------------------\n    function pointAtLength(s) {\n        let acc = 0;\n        for (const g of segs){\n            if (s <= acc + g.len) {\n                const d = s - acc;\n                const t = g.len ? d / g.len : 0;\n                const x = g.a.x + g.dx * t;\n                const y = g.a.y + g.dy * t;\n                return {\n                    x,\n                    y,\n                    nx: g.nx,\n                    ny: g.ny\n                };\n            }\n            acc += g.len;\n        }\n        const last = segs[segs.length - 1];\n        return {\n            x: last.b.x,\n            y: last.b.y,\n            nx: last.ny,\n            ny: -last.nx\n        };\n    }\n    // runder End-Cap (Halbkreis) – sBase = Sweep-Position, an der Cap erscheinen soll\n    function pushRoundCap(out, C, tx, ty, nRows, across, rDot, along, sBase) {\n        const half = (nRows - 1) / 2;\n        const nx = ty, ny = -tx;\n        const radius = half * across;\n        const arcStart = Math.atan2(-ty, -tx) - Math.PI / 2 // hintere Norm\n        ;\n        const arcEnd = arcStart + Math.PI // Halbkreis\n        ;\n        const ringStep = Math.max(rDot * 2 + minGap, across * 0.9);\n        const rings = Math.max(1, Math.floor(radius / ringStep));\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * ringStep;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const pts = Math.max(6, Math.floor(circ / (rDot * 2 + minGap)));\n            for(let i = 0; i <= pts; i++){\n                const a = arcStart + i / pts * (arcEnd - arcStart);\n                out.push({\n                    s: sBase + 0.001 * seq++,\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad\n                });\n            }\n        }\n    }\n    // runder Join (Sektor) zwischen zwei Segmenten am Eckpunkt C\n    function pushRoundJoin(out, C, prev, next, nRows, across, rDot, along, sAtCorner) {\n        // Winkel der Normale vorher/nachher\n        const aIn = Math.atan2(prev.ny, prev.nx);\n        const aOut = Math.atan2(next.ny, next.nx);\n        // Richtung bestimmen, kleiner Bogen (0..π)\n        let delta = normalizeAngle(aOut - aIn);\n        if (delta > Math.PI) delta -= 2 * Math.PI;\n        const startAngle = aIn;\n        const endAngle = aIn + delta;\n        const radius = (nRows - 1) * across / 2;\n        const ringStep = Math.max(rDot * 2 + minGap, across * 0.9);\n        const rings = Math.max(1, Math.floor(radius / ringStep));\n        const angStep = Math.max((rDot * 2 + minGap) / Math.max(radius, 1), Math.PI / 36);\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * ringStep;\n            for(let a = startAngle; delta >= 0 ? a <= endAngle : a >= endAngle; a += delta >= 0 ? angStep : -angStep){\n                out.push({\n                    s: sAtCorner + 0.001 * seq++,\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad\n                });\n            }\n        }\n    }\n    function normalizeAngle(a) {\n        while(a < 0)a += Math.PI * 2;\n        while(a >= Math.PI * 2)a -= Math.PI * 2;\n        return a;\n    }\n    function drawDot(x, y, r) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#6BD5FF\";\n        ctx.shadowColor = \"rgba(107,213,255,0.55)\";\n        ctx.shadowBlur = 4;\n        ctx.fill();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQSx3Q0FBd0MsR0FDakMsU0FBU0EsZUFBZUMsQ0FBUyxFQUFFQyxDQUFTO0lBQ2pELE1BQU1DLFFBQVFGLElBQUk7SUFDbEIsTUFBTUcsUUFBUUYsSUFBSTtJQUNsQixPQUFPO1FBQUVHLEdBQUdGO1FBQU9HLEdBQUdGO0lBQU07QUFDOUI7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTRyxjQUFjQyxHQUE2QixFQUFFQyxNQUFVO0lBQ3JFLE1BQU1DLFdBQVcsNEJBQTRCQyxJQUFJLENBQUNDLFVBQVVDLFNBQVM7SUFDckUsTUFBTSxFQUFFQyxPQUFPYixDQUFDLEVBQUVjLFFBQVFiLENBQUMsRUFBRSxHQUFHTSxJQUFJUSxNQUFNLENBQUNDLHFCQUFxQjtJQUVoRSx1Q0FBdUM7SUFDdkMsTUFBTWIsUUFBUUYsSUFBSTtJQUNsQixNQUFNZ0IsT0FBUWhCLElBQUk7SUFDbEIsTUFBTUMsUUFBUUYsSUFBSTtJQUNsQixNQUFNa0IsU0FBU2xCLElBQUksT0FBT21CLEtBQUtDLEdBQUcsQ0FBQyxLQUFLcEIsSUFBSTtJQUM1QyxNQUFNcUIsT0FBUSxDQUFDbkIsUUFBUWdCLE1BQUssSUFBSztJQUNqQyxNQUFNSSxVQUFVbkIsUUFBUWdCLEtBQUtDLEdBQUcsQ0FBQyxJQUFJbkIsSUFBSTtJQUV6QyxNQUFNc0IsSUFBSTtRQUNSO1lBQUVuQixHQUFHRjtZQUFRRyxHQUFHRjtRQUFNO1FBQ3RCO1lBQUVDLEdBQUdGO1lBQVFHLEdBQUdZO1FBQU07UUFDdEI7WUFBRWIsR0FBR2lCO1lBQVFoQixHQUFHaUI7UUFBUTtRQUN4QjtZQUFFbEIsR0FBR2M7WUFBUWIsR0FBR1k7UUFBTTtRQUN0QjtZQUFFYixHQUFHYztZQUFRYixHQUFHRjtRQUFNO0tBQ3ZCO0lBRUQsMEJBQTBCO0lBQzFCLE1BQU1xQixPQUFPO1FBQ1g7WUFBRUMsR0FBR0YsQ0FBQyxD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LEtBQUtOLEtBQUtnRixFQUFFLEdBQUc7UUFDN0IsTUFBTzFFLEtBQUtOLEtBQUtnRixFQUFFLEdBQUcsRUFBRzFFLEtBQUtOLEtBQUtnRixFQUFFLEdBQUc7UUFDeEMsT0FBTzFFO0lBQ1Q7SUFFQSxTQUFTdUMsUUFBUTVELENBQVMsRUFBRUMsQ0FBUyxFQUFFdUQsQ0FBUztRQUM5Q3JELElBQUkrRyxTQUFTO1FBQ2IvRyxJQUFJZ0gsR0FBRyxDQUFDbkgsR0FBR0MsR0FBR3VELEdBQUcsR0FBR3pDLEtBQUtnRixFQUFFLEdBQUc7UUFDOUI1RixJQUFJaUgsU0FBUyxHQUFHO1FBQ2hCakgsSUFBSWtILFdBQVcsR0FBRztRQUNsQmxILElBQUltSCxVQUFVLEdBQUc7UUFDakJuSCxJQUFJb0gsSUFBSTtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL21vZHVsZXMvY3J5c3RhbEVuZ2luZS50cz80NmM5Il0sInNvdXJjZXNDb250ZW50IjpbInR5cGUgWFkgPSB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cblxuLyoqIExpbmtlciB1bnRlcmVyIEFua2VyIGV4YWt0IHdpZSBpbSBNICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZU1BbmNob3IodzogbnVtYmVyLCBoOiBudW1iZXIpOiBYWSB7XG4gIGNvbnN0IGxlZnRYID0gdyAqIDAuMjhcbiAgY29uc3QgYmFzZVkgPSBoICogMC43NFxuICByZXR1cm4geyB4OiBsZWZ0WCwgeTogYmFzZVkgfVxufVxuXG4vKipcbiAqIFBlbi1Td2VlcCBtaXQgcnVuZGVuIENhcHMgJiBydW5kZW4gSm9pbnMuXG4gKiBFaW4gZGlnaXRhbGVyIFN0aWZ0IGbDpGhydCBkZW4gUGZhZCBQMOKGklAx4oaSUDLihpJQM+KGklA0IGluIH41cyBhYiB1bmRcbiAqIHNldHp0IHVudGVyd2VncyBSYXN0ZXJwdW5rdGUuIEFuIFN0YXJ0L0VuZGUgZ2lidCBlcyBydW5kZSBDYXBzLFxuICogYW4gZGVuIEtuaWNrZW4gcnVuZGUg4oCeSm9pbuKAnC1TZWt0b3JlbiDigJQgYWxsZXMgaW4gZGllIFN3ZWVwLVplaXRyZWloZVxuICogZWluc29ydGllcnQg4oeSIGF1cyBlaW5lbSBHdXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRDcnlzdGFsTShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYW5jaG9yOiBYWSkge1xuICBjb25zdCBpc01vYmlsZSA9IC9Nb2JpfEFuZHJvaWR8aVBob25lfGlQYWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gIGNvbnN0IHsgd2lkdGg6IHcsIGhlaWdodDogaCB9ID0gY3R4LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gIC8vIFByb3BvcnRpb25lbjogYXVmcmVjaHRlIFPDpHVsZW4sIGVkZWxcbiAgY29uc3QgYmFzZVkgPSBoICogMC43NFxuICBjb25zdCB0b3BZICA9IGggKiAwLjM2XG4gIGNvbnN0IGxlZnRYID0gdyAqIDAuMjhcbiAgY29uc3QgcmlnaHRYID0gdyAqIDAuMjggKyBNYXRoLm1heCgzNjAsIHcgKiAwLjMyKVxuICBjb25zdCBtaWRYICA9IChsZWZ0WCArIHJpZ2h0WCkgLyAyXG4gIGNvbnN0IHZhbGxleVkgPSBiYXNlWSAtIE1hdGgubWF4KDkwLCBoICogMC4xNClcblxuICBjb25zdCBQID0gW1xuICAgIHsgeDogbGVmdFgsICB5OiBiYXNlWSB9LCAgIC8vIDBcbiAgICB7IHg6IGxlZnRYLCAgeTogdG9wWSAgfSwgICAvLyAxXG4gICAgeyB4OiBtaWRYLCAgIHk6IHZhbGxleVkgfSwgLy8gMlxuICAgIHsgeDogcmlnaHRYLCB5OiB0b3BZICB9LCAgIC8vIDNcbiAgICB7IHg6IHJpZ2h0WCwgeTogYmFzZVkgfSwgICAvLyA0XG4gIF0gYXMgY29uc3RcblxuICAvLyBTZWdtZW50ZSBwbHVzIEdlb21ldHJpZVxuICBjb25zdCBzZWdzID0gW1xuICAgIHsgYTogUFswXSwgYjogUFsxXSB9LFxuICAgIHsgYTogUFsxXSwgYjogUFsyXSB9LFxuICAgIHsgYTogUFsyXSwgYjogUFszXSB9LFxuICAgIHsgYTogUFszXSwgYjogUFs0XSB9LFxuICBdLm1hcChzID0+IHtcbiAgICBjb25zdCBkeCA9IHMuYi54IC0gcy5hLnhcbiAgICBjb25zdCBkeSA9IHMuYi55IC0gcy5hLnlcbiAgICBjb25zdCBsZW4gPSBNYXRoLmh5cG90KGR4LCBkeSlcbiAgICBjb25zdCB0eCA9IGxlbiA/IGR4IC8gbGVuIDogMFxuICAgIGNvbnN0IHR5ID0gbGVuID8gZHkgLyBsZW4gOiAwXG4gICAgY29uc3QgbnggPSAgdHlcbiAgICBjb25zdCBueSA9IC10eFxuICAgIHJldHVybiB7IC4uLnMsIGR4LCBkeSwgbGVuLCB0eCwgdHksIG54LCBueSB9XG4gIH0pXG5cbiAgY29uc3QgdG90YWxMZW4gPSBzZWdzLnJlZHVjZSgocywgZykgPT4gcyArIGcubGVuLCAwKVxuXG4gIC8vIExvb2sgJiBSYXN0ZXJhYnN0w6RuZGUgKGJyZWl0LCBkaWNodCwgYWJlciBtaXQgTMO8Y2tlbilcbiAgY29uc3QgZG90UiAgICAgICAgPSBpc01vYmlsZSA/IDEuMyA6IDEuNlxuICBjb25zdCBtaW5HYXAgICAgICA9IGlzTW9iaWxlID8gMS44IDogMi4yXG4gIGNvbnN0IHN0ZXBBbG9uZyAgID0gTWF0aC5tYXgoaXNNb2JpbGUgPyAyLjQgOiAyLjAsIGRvdFIgKiAyICsgKG1pbkdhcCAtIDAuNikpIC8vIEFic3RhbmQgYXVmIExpbmllXG4gIGNvbnN0IGdhcEFjcm9zcyAgID0gTWF0aC5tYXgoaXNNb2JpbGUgPyA0LjggOiA0LjIsIGRvdFIgKiAyICsgbWluR2FwKSAgICAgICAgIC8vIEFic3RhbmQgUmVpaGVuXG4gIGNvbnN0IHdpZHRoUHggICAgID0gaXNNb2JpbGUgPyAyOCA6IDU2XG4gIGNvbnN0IHJvd3MgICAgICAgID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih3aWR0aFB4IC8gZ2FwQWNyb3NzKSkgICAgICAgICAgICAgIC8vIFBpbnNlbGJyZWl0ZSAoUmVpaGVuKVxuICBjb25zdCBkdXJhdGlvblNlYyA9IDVcblxuICAvLyBaZWl0c3RldWVydW5nIChGUFMtdW5hYmjDpG5naWcpXG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgbGV0IHByZXZTID0gMFxuICBsZXQgcmFmID0gMFxuXG4gIC8vIFNwYXRpYWwgSGFzaCBmw7xyIEFic3RhbmRzLUdhcmFudGllXG4gIGNvbnN0IGNlbGwgPSBNYXRoLm1pbihzdGVwQWxvbmcsIGdhcEFjcm9zcykgKiAwLjlcbiAgY29uc3QgcGxhY2VkID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3Qga2V5ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBgJHtNYXRoLnJvdW5kKHggLyBjZWxsKX06JHtNYXRoLnJvdW5kKHkgLyBjZWxsKX1gXG4gIGNvbnN0IHRyeURvdCA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgciA9IGRvdFIpID0+IHtcbiAgICBjb25zdCBrID0ga2V5KHgsIHkpXG4gICAgaWYgKHBsYWNlZC5oYXMoaykpIHJldHVybiBmYWxzZVxuICAgIHBsYWNlZC5hZGQoaylcbiAgICBkcmF3RG90KHgsIHksIHIpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEVyc3RwdW5rdCAoQW5jaG9yKVxuICB0cnlEb3QoYW5jaG9yLngsIGFuY2hvci55LCBkb3RSICsgMC45KVxuXG4gIC8vIFByZWNvbXB1dGUgcnVuZGUgQ2FwcyAmIEpvaW5zIGFscyDigJ5FeHRyYXPigJwsIGRpZSBpbiBkZW4gU3dlZXAgZWluc29ydGllcnQgd2VyZGVuXG4gIHR5cGUgRXh0cmEgPSB7IHM6IG51bWJlcjsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHI/OiBudW1iZXIgfVxuICBjb25zdCBleHRyYXM6IEV4dHJhW10gPSBbXVxuXG4gIC8vIFN0YXJ0LUNhcCAoSGFsYmtyZWlzIGFtIFAwLCBub3JtYWwgc3RlaHQgcXVlciB6dW0gZXJzdGVuIFNlZ21lbnQpXG4gIGlmIChzZWdzWzBdKSBwdXNoUm91bmRDYXAoZXh0cmFzLCBQWzBdLCAtc2Vnc1swXS50eCwgLXNlZ3NbMF0udHksIHJvd3MsIGdhcEFjcm9zcywgZG90Uiwgc3RlcEFsb25nLCAwKVxuXG4gIC8vIEpvaW5zIGFuIFAxLCBQMiwgUDMgKHJ1bmRlcyBFY2sg4oCTIFNla3RvciB6d2lzY2hlbiBkZW4gTm9ybWVuKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gc2Vnc1tpIC0gMV0sIG5leHQgPSBzZWdzW2ldXG4gICAgcHVzaFJvdW5kSm9pbihleHRyYXMsIFBbaV0sIHByZXYsIG5leHQsIHJvd3MsIGdhcEFjcm9zcywgZG90Uiwgc3RlcEFsb25nLCBzZWdzLnNsaWNlKDAsIGkpLnJlZHVjZSgocywgZykgPT4gcyArIGcubGVuLCAwKSlcbiAgfVxuXG4gIC8vIEVuZC1DYXAgKEhhbGJrcmVpcyBhbSBQNClcbiAgY29uc3QgbGVuQmVmb3JlRW5kID0gc2Vncy5zbGljZSgwLCBzZWdzLmxlbmd0aCAtIDEpLnJlZHVjZSgocywgZykgPT4gcyArIGcubGVuLCAwKSArIHNlZ3Nbc2Vncy5sZW5ndGggLSAxXS5sZW5cbiAgcHVzaFJvdW5kQ2FwKGV4dHJhcywgUFs0XSwgc2Vnc1tzZWdzLmxlbmd0aCAtIDFdLnR4LCBzZWdzW3NlZ3MubGVuZ3RoIC0gMV0udHksIHJvd3MsIGdhcEFjcm9zcywgZG90Uiwgc3RlcEFsb25nLCBsZW5CZWZvcmVFbmQpXG5cbiAgLy8gR2VzYW10bGlzdGU6IFN3ZWVwLVB1bmt0ZSArIEV4dHJhcyAoc3DDpHRlciBpbiB6ZWl0bGljaGVyIFJlaWhlbmZvbGdlIGdlemVpY2huZXQpXG4gIGV4dHJhcy5zb3J0KChhLCBiKSA9PiBhLnMgLSBiLnMpXG4gIGxldCBleHRyYUlkeCA9IDBcblxuICAvLyBQRU4tU1dFRVBcbiAgZnVuY3Rpb24gdGljayhub3c6IG51bWJlcikge1xuICAgIGNvbnN0IHQgPSBNYXRoLm1pbigobm93IC0gc3RhcnQpIC8gKGR1cmF0aW9uU2VjICogMTAwMCksIDEpXG4gICAgY29uc3Qgc1RhcmdldCA9IHQgKiB0b3RhbExlblxuXG4gICAgLy8gTGluaWUgYWJmYWhyZW4sIFB1bmt0ZSBzZXR6ZW5cbiAgICBmb3IgKGxldCBzID0gcHJldlM7IHMgPD0gc1RhcmdldDsgcyArPSBzdGVwQWxvbmcpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHBvaW50QXRMZW5ndGgocylcbiAgICAgIGlmICghcG9zKSBjb250aW51ZVxuICAgICAgY29uc3QgeyB4LCB5LCBueCwgbnkgfSA9IHBvc1xuICAgICAgY29uc3QgaGFsZiA9IChyb3dzIC0gMSkgLyAyXG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAociAtIGhhbGYpICogZ2FwQWNyb3NzXG4gICAgICAgIHRyeURvdCh4ICsgbnggKiBvZmZzZXQsIHkgKyBueSAqIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldlMgPSBzVGFyZ2V0XG5cbiAgICAvLyBFeHRyYXMgZWluc3BlaXNlbiwgZGVyZW4gcyBpbm5lcmhhbGIgZGVzIGFrdHVlbGxlbiBGZW5zdGVycyBsaWVndFxuICAgIHdoaWxlIChleHRyYUlkeCA8IGV4dHJhcy5sZW5ndGggJiYgZXh0cmFzW2V4dHJhSWR4XS5zIDw9IHNUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGUgPSBleHRyYXNbZXh0cmFJZHgrK11cbiAgICAgIHRyeURvdChlLngsIGUueSwgZS5yID8/IGRvdFIpXG4gICAgfVxuXG4gICAgaWYgKHQgPCAxIHx8IGV4dHJhSWR4IDwgZXh0cmFzLmxlbmd0aCkge1xuICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZilcbiAgICB9XG4gIH1cbiAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXG5cbiAgLy8gLS0tIEhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBmdW5jdGlvbiBwb2ludEF0TGVuZ3RoKHM6IG51bWJlcik6XG4gICAgfCB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBueDogbnVtYmVyOyBueTogbnVtYmVyIH1cbiAgICB8IG51bGwge1xuICAgIGxldCBhY2MgPSAwXG4gICAgZm9yIChjb25zdCBnIG9mIHNlZ3MpIHtcbiAgICAgIGlmIChzIDw9IGFjYyArIGcubGVuKSB7XG4gICAgICAgIGNvbnN0IGQgPSBzIC0gYWNjXG4gICAgICAgIGNvbnN0IHQgPSBnLmxlbiA/IGQgLyBnLmxlbiA6IDBcbiAgICAgICAgY29uc3QgeCA9IGcuYS54ICsgZy5keCAqIHRcbiAgICAgICAgY29uc3QgeSA9IGcuYS55ICsgZy5keSAqIHRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSwgbng6IGcubngsIG55OiBnLm55IH1cbiAgICAgIH1cbiAgICAgIGFjYyArPSBnLmxlblxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gc2Vnc1tzZWdzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHsgeDogbGFzdC5iLngsIHk6IGxhc3QuYi55LCBueDogbGFzdC5ueSwgbnk6IC1sYXN0Lm54IH1cbiAgfVxuXG4gIC8vIHJ1bmRlciBFbmQtQ2FwIChIYWxia3JlaXMpIOKAkyBzQmFzZSA9IFN3ZWVwLVBvc2l0aW9uLCBhbiBkZXIgQ2FwIGVyc2NoZWluZW4gc29sbFxuICBmdW5jdGlvbiBwdXNoUm91bmRDYXAoXG4gICAgb3V0OiBFeHRyYVtdLCBDOiBYWSwgdHg6IG51bWJlciwgdHk6IG51bWJlcixcbiAgICBuUm93czogbnVtYmVyLCBhY3Jvc3M6IG51bWJlciwgckRvdDogbnVtYmVyLCBhbG9uZzogbnVtYmVyLCBzQmFzZTogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IGhhbGYgPSAoblJvd3MgLSAxKSAvIDJcbiAgICBjb25zdCBueCA9ICB0eSwgbnkgPSAtdHhcbiAgICBjb25zdCByYWRpdXMgPSBoYWxmICogYWNyb3NzXG4gICAgY29uc3QgYXJjU3RhcnQgPSBNYXRoLmF0YW4yKC10eSwgLXR4KSAtIE1hdGguUEkgLyAyIC8vIGhpbnRlcmUgTm9ybVxuICAgIGNvbnN0IGFyY0VuZCAgID0gYXJjU3RhcnQgKyBNYXRoLlBJICAgICAgICAgICAgICAgICAgLy8gSGFsYmtyZWlzXG5cbiAgICBjb25zdCByaW5nU3RlcCA9IE1hdGgubWF4KHJEb3QgKiAyICsgbWluR2FwLCBhY3Jvc3MgKiAwLjkpXG4gICAgY29uc3QgcmluZ3MgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJhZGl1cyAvIHJpbmdTdGVwKSlcbiAgICBsZXQgc2VxID0gMFxuICAgIGZvciAobGV0IHIgPSAwOyByIDw9IHJpbmdzOyByKyspIHtcbiAgICAgIGNvbnN0IHJhZCA9IHIgKiByaW5nU3RlcFxuICAgICAgY29uc3QgY2lyYyA9IDIgKiBNYXRoLlBJICogTWF0aC5tYXgocmFkLCAxKVxuICAgICAgY29uc3QgcHRzID0gTWF0aC5tYXgoNiwgTWF0aC5mbG9vcihjaXJjIC8gKHJEb3QgKiAyICsgbWluR2FwKSkpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBwdHM7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJjU3RhcnQgKyAoaSAvIHB0cykgKiAoYXJjRW5kIC0gYXJjU3RhcnQpXG4gICAgICAgIG91dC5wdXNoKHsgczogc0Jhc2UgKyAwLjAwMSAqIChzZXErKyksIHg6IEMueCArIE1hdGguY29zKGEpICogcmFkLCB5OiBDLnkgKyBNYXRoLnNpbihhKSAqIHJhZCB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJ1bmRlciBKb2luIChTZWt0b3IpIHp3aXNjaGVuIHp3ZWkgU2VnbWVudGVuIGFtIEVja3B1bmt0IENcbiAgZnVuY3Rpb24gcHVzaFJvdW5kSm9pbihcbiAgICBvdXQ6IEV4dHJhW10sIEM6IFhZLCBwcmV2OiBhbnksIG5leHQ6IGFueSxcbiAgICBuUm93czogbnVtYmVyLCBhY3Jvc3M6IG51bWJlciwgckRvdDogbnVtYmVyLCBhbG9uZzogbnVtYmVyLCBzQXRDb3JuZXI6IG51bWJlclxuICApIHtcbiAgICAvLyBXaW5rZWwgZGVyIE5vcm1hbGUgdm9yaGVyL25hY2hoZXJcbiAgICBjb25zdCBhSW4gID0gTWF0aC5hdGFuMihwcmV2Lm55LCBwcmV2Lm54KVxuICAgIGNvbnN0IGFPdXQgPSBNYXRoLmF0YW4yKG5leHQubnksIG5leHQubngpXG5cbiAgICAvLyBSaWNodHVuZyBiZXN0aW1tZW4sIGtsZWluZXIgQm9nZW4gKDAuLs+AKVxuICAgIGxldCBkZWx0YSA9IG5vcm1hbGl6ZUFuZ2xlKGFPdXQgLSBhSW4pXG4gICAgaWYgKGRlbHRhID4gTWF0aC5QSSkgZGVsdGEgLT0gMiAqIE1hdGguUElcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gYUluXG4gICAgY29uc3QgZW5kQW5nbGUgICA9IGFJbiArIGRlbHRhXG5cbiAgICBjb25zdCByYWRpdXMgPSAoKG5Sb3dzIC0gMSkgKiBhY3Jvc3MpIC8gMlxuICAgIGNvbnN0IHJpbmdTdGVwID0gTWF0aC5tYXgockRvdCAqIDIgKyBtaW5HYXAsIGFjcm9zcyAqIDAuOSlcbiAgICBjb25zdCByaW5ncyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmFkaXVzIC8gcmluZ1N0ZXApKVxuICAgIGNvbnN0IGFuZ1N0ZXAgPSBNYXRoLm1heCgockRvdCAqIDIgKyBtaW5HYXApIC8gTWF0aC5tYXgocmFkaXVzLCAxKSwgTWF0aC5QSSAvIDM2KVxuXG4gICAgbGV0IHNlcSA9IDBcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSByaW5nczsgcisrKSB7XG4gICAgICBjb25zdCByYWQgPSByICogcmluZ1N0ZXBcbiAgICAgIGZvciAobGV0IGEgPSBzdGFydEFuZ2xlOyBkZWx0YSA+PSAwID8gYSA8PSBlbmRBbmdsZSA6IGEgPj0gZW5kQW5nbGU7IGEgKz0gKGRlbHRhID49IDAgPyBhbmdTdGVwIDogLWFuZ1N0ZXApKSB7XG4gICAgICAgIG91dC5wdXNoKHsgczogc0F0Q29ybmVyICsgMC4wMDEgKiAoc2VxKyspLCB4OiBDLnggKyBNYXRoLmNvcyhhKSAqIHJhZCwgeTogQy55ICsgTWF0aC5zaW4oYSkgKiByYWQgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhOiBudW1iZXIpIHtcbiAgICB3aGlsZSAoYSA8IDApIGEgKz0gTWF0aC5QSSAqIDJcbiAgICB3aGlsZSAoYSA+PSBNYXRoLlBJICogMikgYSAtPSBNYXRoLlBJICogMlxuICAgIHJldHVybiBhXG4gIH1cblxuICBmdW5jdGlvbiBkcmF3RG90KHg6IG51bWJlciwgeTogbnVtYmVyLCByOiBudW1iZXIpIHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKVxuICAgIGN0eC5maWxsU3R5bGUgPSAnIzZCRDVGRidcbiAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgxMDcsMjEzLDI1NSwwLjU1KSdcbiAgICBjdHguc2hhZG93Qmx1ciA9IDRcbiAgICBjdHguZmlsbCgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjb21wdXRlTUFuY2hvciIsInciLCJoIiwibGVmdFgiLCJiYXNlWSIsIngiLCJ5IiwiYnVpbGRDcnlzdGFsTSIsImN0eCIsImFuY2hvciIsImlzTW9iaWxlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIndpZHRoIiwiaGVpZ2h0IiwiY2FudmFzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wWSIsInJpZ2h0WCIsIk1hdGgiLCJtYXgiLCJtaWRYIiwidmFsbGV5WSIsIlAiLCJzZWdzIiwiYSIsImIiLCJtYXAiLCJzIiwiZHgiLCJkeSIsImxlbiIsImh5cG90IiwidHgiLCJ0eSIsIm54IiwibnkiLCJ0b3RhbExlbiIsInJlZHVjZSIsImciLCJkb3RSIiwibWluR2FwIiwic3RlcEFsb25nIiwiZ2FwQWNyb3NzIiwid2lkdGhQeCIsInJvd3MiLCJmbG9vciIsImR1cmF0aW9uU2VjIiwic3RhcnQiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInByZXZTIiwicmFmIiwiY2VsbCIsIm1pbiIsInBsYWNlZCIsIlNldCIsImtleSIsInJvdW5kIiwidHJ5RG90IiwiciIsImsiLCJoYXMiLCJhZGQiLCJkcmF3RG90IiwiZXh0cmFzIiwicHVzaFJvdW5kQ2FwIiwiaSIsImxlbmd0aCIsInByZXYiLCJuZXh0IiwicHVzaFJvdW5kSm9pbiIsInNsaWNlIiwibGVuQmVmb3JlRW5kIiwic29ydCIsImV4dHJhSWR4IiwidGljayIsInQiLCJzVGFyZ2V0IiwicG9zIiwicG9pbnRBdExlbmd0aCIsImhhbGYiLCJvZmZzZXQiLCJlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJhY2MiLCJkIiwibGFzdCIsIm91dCIsIkMiLCJuUm93cyIsImFjcm9zcyIsInJEb3QiLCJhbG9uZyIsInNCYXNlIiwicmFkaXVzIiwiYXJjU3RhcnQiLCJhdGFuMiIsIlBJIiwiYXJjRW5kIiwicmluZ1N0ZXAiLCJyaW5ncyIsInNlcSIsInJhZCIsImNpcmMiLCJwdHMiLCJwdXNoIiwiY29zIiwic2luIiwic0F0Q29ybmVyIiwiYUluIiwiYU91dCIsImRlbHRhIiwibm9ybWFsaXplQW5nbGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhbmdTdGVwIiwiYmVnaW5QYXRoIiwiYXJjIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});