"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n/**\n * Punkt-M, Lichtenstein-Style:\n * - sehr viele Punkte (Desktop ~3500–4200, Mobile ~1800–2400)\n * - Aufbau in exakt ~5 Sekunden (gleichmäßig über Frames verteilt)\n * - Wellenfront vom Anchor (erster Meteor-Punkt)\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    // Geometrie in CSS-Pixeln planen\n    const rect = ctx.canvas.getBoundingClientRect();\n    const w = rect.width, h = rect.height;\n    // M-Kontrollpunkte (responsive)\n    const baseX = w * 0.30;\n    const baseY = h * 0.70;\n    const spanX = Math.max(260, w * 0.26);\n    const peakY = Math.min(baseY - h * 0.30, h * 0.40);\n    const P = [\n        {\n            x: baseX,\n            y: baseY\n        },\n        {\n            x: baseX + spanX * 0.25,\n            y: peakY\n        },\n        {\n            x: baseX + spanX * 0.50,\n            y: baseY * 0.93\n        },\n        {\n            x: baseX + spanX * 0.75,\n            y: peakY\n        },\n        {\n            x: baseX + spanX,\n            y: baseY\n        }\n    ];\n    const segs = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ];\n    // -------- Lichtenstein-Parameter (fein, dicht) ----------------------------\n    const spacingAlong = isMobile ? 6 : 4.5; // Abstand ALONG (Punkt zu Punkt auf Linie)\n    const thickness = isMobile ? 14 : 20; // visuelle Strichbreite in px\n    const spacingAcross = isMobile ? 7 : 6; // Abstand ACROSS (zwischen parallelen Reihen)\n    const dotRadius = isMobile ? 1.6 : 1.9; // Punktgröße\n    const shadowBlur = 1.5; // minimaler Glow (kein Verschmieren)\n    const durationSec = 5; // Ziel: 5 Sekunden Gesamtaufbau\n    // --------------------------------------------------------------------------\n    // Punktwolke erzeugen: mehrere punktierte Reihen quer zur Linie\n    const points = [];\n    for (const { a, b } of segs){\n        const dx = b.x - a.x;\n        const dy = b.y - a.y;\n        const len = Math.hypot(dx, dy);\n        if (len === 0) continue;\n        const tx = dx / len; // Tangente\n        const ty = dy / len;\n        const nx = ty; // Normale (links)\n        const ny = -tx;\n        const rows = Math.max(1, Math.round(thickness / spacingAcross));\n        const half = (rows - 1) / 2;\n        const steps = Math.max(2, Math.floor(len / spacingAlong));\n        for(let r = 0; r < rows; r++){\n            const offset = (r - half) * spacingAcross;\n            // versetze jede zweite Reihe leicht (stagger), damit es „gedruckt“ wirkt\n            const stagger = r % 2 * (spacingAlong * 0.5);\n            for(let i = 0; i <= steps; i++){\n                const d = i * spacingAlong + stagger;\n                if (d > len) continue;\n                const x = a.x + tx * d + nx * offset;\n                const y = a.y + ty * d + ny * offset;\n                points.push({\n                    x,\n                    y\n                });\n            }\n        }\n    }\n    // Reihenfolge: Wellenfront vom Anchor + minimale Varianz\n    points.sort((p1, p2)=>{\n        const d1 = Math.hypot(p1.x - anchor.x, p1.y - anchor.y);\n        const d2 = Math.hypot(p2.x - anchor.x, p2.y - anchor.y);\n        return d1 - d2 + (Math.random() - 0.5) * 2.5;\n    });\n    // Aufbau-Rate so wählen, dass ~5 Sekunden erreicht werden\n    // Annahme ~60 FPS -> durationSec * 60 Frames\n    const framesTarget = Math.max(1, Math.round(durationSec * 60));\n    const perFrame = Math.max(1, Math.ceil(points.length / framesTarget));\n    // erster Punkt (Meteor/Anchor)\n    drawDot(anchor.x, anchor.y, dotRadius + 0.8);\n    let idx = 0;\n    function frame() {\n        for(let i = 0; i < perFrame && idx < points.length; i++, idx++){\n            const p = points[idx];\n            drawDot(p.x, p.y, dotRadius);\n        }\n        if (idx < points.length) requestAnimationFrame(frame);\n    }\n    requestAnimationFrame(frame);\n    function drawDot(x, y, r) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#FFD700\";\n        ctx.shadowColor = \"rgba(255, 215, 0, 0.35)\";\n        ctx.shadowBlur = shadowBlur;\n        ctx.fill();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLCtCQUErQjtBQUcvQjs7Ozs7Q0FLQyxHQUNNLFNBQVNBLGNBQWNDLEdBQTZCLEVBQUVDLE1BQVU7SUFDckUsTUFBTUMsV0FBVyw0QkFBNEJDLElBQUksQ0FBQ0MsVUFBVUMsU0FBUztJQUVyRSxpQ0FBaUM7SUFDakMsTUFBTUMsT0FBT04sSUFBSU8sTUFBTSxDQUFDQyxxQkFBcUI7SUFDN0MsTUFBTUMsSUFBSUgsS0FBS0ksS0FBSyxFQUFFQyxJQUFJTCxLQUFLTSxNQUFNO0lBRXJDLGdDQUFnQztJQUNoQyxNQUFNQyxRQUFRSixJQUFJO0lBQ2xCLE1BQU1LLFFBQVFILElBQUk7SUFDbEIsTUFBTUksUUFBUUMsS0FBS0MsR0FBRyxDQUFDLEtBQUtSLElBQUk7SUFDaEMsTUFBTVMsUUFBUUYsS0FBS0csR0FBRyxDQUFDTCxRQUFRSCxJQUFJLE1BQU1BLElBQUk7SUFFN0MsTUFBTVMsSUFBSTtRQUNSO1lBQUVDLEdBQUdSO1lBQXFCUyxHQUFHUjtRQUFNO1FBQ25DO1lBQUVPLEdBQUdSLFFBQVFFLFFBQU07WUFBT08sR0FBR0o7UUFBTTtRQUNuQztZQUFFRyxHQUFHUixRQUFRRSxRQUFNO1lBQU9PLEdBQUdSLFFBQVE7UUFBSztRQUMxQztZQUFFTyxHQUFHUixRQUFRRSxRQUFNO1lBQU9PLEdBQUdKO1FBQU07UUFDbkM7WUFBRUcsR0FBR1IsUUFBUUU7WUFBYU8sR0FBR1I7UUFBTTtLQUNwQztJQUVELE1BQU1TLE9BQU87UUFDWDtZQUFFQyxHQUFHSixDQUFDLENBQUMsRUFBRTtZQUFFSyxHQUFHTCxDQUFDLENBQUMsRUFBRTtRQUFDO1FBQ25CO1lBQUVJLEdBQUdKLENBQUMsQ0FBQyxFQUFFO1lBQUVLLEdBQUdMLENBQUMsQ0FBQyxFQUFFO1FBQUM7UUFDbkI7WUFBRUksR0FBR0osQ0FBQyxDQUFDLEVBQUU7WUFBRUssR0FBR0wsQ0FB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QU9vQixDQUFDLEVBQUVwQixPQUFPcUIsQ0FBQyxFQUFFTyxZQUFZO0lBRXhDLElBQUlrQyxNQUFNO0lBQ1YsU0FBU0M7UUFDUCxJQUFLLElBQUlmLElBQUksR0FBR0EsSUFBSVUsWUFBWUksTUFBTS9CLE9BQU82QixNQUFNLEVBQUVaLEtBQUtjLE1BQU87WUFDL0QsTUFBTUUsSUFBSWpDLE1BQU0sQ0FBQytCLElBQUk7WUFDckJELFFBQVFHLEVBQUU1QyxDQUFDLEVBQUU0QyxFQUFFM0MsQ0FBQyxFQUFFTztRQUNwQjtRQUNBLElBQUlrQyxNQUFNL0IsT0FBTzZCLE1BQU0sRUFBRUssc0JBQXNCRjtJQUNqRDtJQUNBRSxzQkFBc0JGO0lBRXRCLFNBQVNGLFFBQVF6QyxDQUFTLEVBQUVDLENBQVMsRUFBRXdCLENBQVM7UUFDOUM5QyxJQUFJbUUsU0FBUztRQUNibkUsSUFBSW9FLEdBQUcsQ0FBQy9DLEdBQUdDLEdBQUd3QixHQUFHLEdBQUc5QixLQUFLcUQsRUFBRSxHQUFHO1FBQzlCckUsSUFBSXNFLFNBQVMsR0FBRztRQUNoQnRFLElBQUl1RSxXQUFXLEdBQUc7UUFDbEJ2RSxJQUFJOEIsVUFBVSxHQUFHQTtRQUNqQjlCLElBQUl3RSxJQUFJO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzPzQ2YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXBwL21vZHVsZXMvY3J5c3RhbEVuZ2luZS50c1xudHlwZSBYWSA9IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblxuLyoqXG4gKiBQdW5rdC1NLCBMaWNodGVuc3RlaW4tU3R5bGU6XG4gKiAtIHNlaHIgdmllbGUgUHVua3RlIChEZXNrdG9wIH4zNTAw4oCTNDIwMCwgTW9iaWxlIH4xODAw4oCTMjQwMClcbiAqIC0gQXVmYmF1IGluIGV4YWt0IH41IFNla3VuZGVuIChnbGVpY2htw6TDn2lnIMO8YmVyIEZyYW1lcyB2ZXJ0ZWlsdClcbiAqIC0gV2VsbGVuZnJvbnQgdm9tIEFuY2hvciAoZXJzdGVyIE1ldGVvci1QdW5rdClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ3J5c3RhbE0oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFuY2hvcjogWFkpIHtcbiAgY29uc3QgaXNNb2JpbGUgPSAvTW9iaXxBbmRyb2lkfGlQaG9uZXxpUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAvLyBHZW9tZXRyaWUgaW4gQ1NTLVBpeGVsbiBwbGFuZW5cbiAgY29uc3QgcmVjdCA9IGN0eC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHcgPSByZWN0LndpZHRoLCBoID0gcmVjdC5oZWlnaHQ7XG5cbiAgLy8gTS1Lb250cm9sbHB1bmt0ZSAocmVzcG9uc2l2ZSlcbiAgY29uc3QgYmFzZVggPSB3ICogMC4zMDtcbiAgY29uc3QgYmFzZVkgPSBoICogMC43MDtcbiAgY29uc3Qgc3BhblggPSBNYXRoLm1heCgyNjAsIHcgKiAwLjI2KTtcbiAgY29uc3QgcGVha1kgPSBNYXRoLm1pbihiYXNlWSAtIGggKiAwLjMwLCBoICogMC40MCk7XG5cbiAgY29uc3QgUCA9IFtcbiAgICB7IHg6IGJhc2VYLCAgICAgICAgICAgICAgIHk6IGJhc2VZIH0sICAgICAgICAgLy8gMFxuICAgIHsgeDogYmFzZVggKyBzcGFuWCowLjI1LCAgeTogcGVha1kgfSwgICAgICAgICAvLyAxXG4gICAgeyB4OiBiYXNlWCArIHNwYW5YKjAuNTAsICB5OiBiYXNlWSAqIDAuOTMgfSwgIC8vIDJcbiAgICB7IHg6IGJhc2VYICsgc3BhblgqMC43NSwgIHk6IHBlYWtZIH0sICAgICAgICAgLy8gM1xuICAgIHsgeDogYmFzZVggKyBzcGFuWCwgICAgICAgeTogYmFzZVkgfSwgICAgICAgICAvLyA0XG4gIF0gYXMgY29uc3Q7XG5cbiAgY29uc3Qgc2VncyA9IFtcbiAgICB7IGE6IFBbMF0sIGI6IFBbMV0gfSxcbiAgICB7IGE6IFBbMV0sIGI6IFBbMl0gfSxcbiAgICB7IGE6IFBbMl0sIGI6IFBbM10gfSxcbiAgICB7IGE6IFBbM10sIGI6IFBbNF0gfSxcbiAgXTtcblxuICAvLyAtLS0tLS0tLSBMaWNodGVuc3RlaW4tUGFyYW1ldGVyIChmZWluLCBkaWNodCkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25zdCBzcGFjaW5nQWxvbmcgPSBpc01vYmlsZSA/IDYgOiA0LjU7ICAgICAgICAvLyBBYnN0YW5kIEFMT05HIChQdW5rdCB6dSBQdW5rdCBhdWYgTGluaWUpXG4gIGNvbnN0IHRoaWNrbmVzcyAgICA9IGlzTW9iaWxlID8gMTQgOiAyMDsgICAgICAgIC8vIHZpc3VlbGxlIFN0cmljaGJyZWl0ZSBpbiBweFxuICBjb25zdCBzcGFjaW5nQWNyb3NzPSBpc01vYmlsZSA/IDcgOiA2OyAgICAgICAgICAvLyBBYnN0YW5kIEFDUk9TUyAoendpc2NoZW4gcGFyYWxsZWxlbiBSZWloZW4pXG4gIGNvbnN0IGRvdFJhZGl1cyAgICA9IGlzTW9iaWxlID8gMS42IDogMS45OyAgICAgIC8vIFB1bmt0Z3LDtsOfZVxuICBjb25zdCBzaGFkb3dCbHVyICAgPSAxLjU7ICAgICAgICAgICAgICAgICAgICAgICAvLyBtaW5pbWFsZXIgR2xvdyAoa2VpbiBWZXJzY2htaWVyZW4pXG4gIGNvbnN0IGR1cmF0aW9uU2VjICA9IDU7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFppZWw6IDUgU2VrdW5kZW4gR2VzYW10YXVmYmF1XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUHVua3R3b2xrZSBlcnpldWdlbjogbWVocmVyZSBwdW5rdGllcnRlIFJlaWhlbiBxdWVyIHp1ciBMaW5pZVxuICBjb25zdCBwb2ludHM6IFhZW10gPSBbXTtcblxuICBmb3IgKGNvbnN0IHsgYSwgYiB9IG9mIHNlZ3MpIHtcbiAgICBjb25zdCBkeCA9IGIueCAtIGEueDtcbiAgICBjb25zdCBkeSA9IGIueSAtIGEueTtcbiAgICBjb25zdCBsZW4gPSBNYXRoLmh5cG90KGR4LCBkeSk7XG4gICAgaWYgKGxlbiA9PT0gMCkgY29udGludWU7XG5cbiAgICBjb25zdCB0eCA9IGR4IC8gbGVuOyAgICAvLyBUYW5nZW50ZVxuICAgIGNvbnN0IHR5ID0gZHkgLyBsZW47XG4gICAgY29uc3QgbnggPSAgdHk7ICAgICAgICAgLy8gTm9ybWFsZSAobGlua3MpXG4gICAgY29uc3QgbnkgPSAtdHg7XG5cbiAgICBjb25zdCByb3dzID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZCh0aGlja25lc3MgLyBzcGFjaW5nQWNyb3NzKSk7XG4gICAgY29uc3QgaGFsZiA9IChyb3dzIC0gMSkgLyAyO1xuXG4gICAgY29uc3Qgc3RlcHMgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKGxlbiAvIHNwYWNpbmdBbG9uZykpO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAociAtIGhhbGYpICogc3BhY2luZ0Fjcm9zcztcbiAgICAgIC8vIHZlcnNldHplIGplZGUgendlaXRlIFJlaWhlIGxlaWNodCAoc3RhZ2dlciksIGRhbWl0IGVzIOKAnmdlZHJ1Y2t04oCcIHdpcmt0XG4gICAgICBjb25zdCBzdGFnZ2VyID0gKHIgJSAyKSAqIChzcGFjaW5nQWxvbmcgKiAwLjUpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc3RlcHM7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gaSAqIHNwYWNpbmdBbG9uZyArIHN0YWdnZXI7XG4gICAgICAgIGlmIChkID4gbGVuKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgeCA9IGEueCArIHR4ICogZCArIG54ICogb2Zmc2V0O1xuICAgICAgICBjb25zdCB5ID0gYS55ICsgdHkgKiBkICsgbnkgKiBvZmZzZXQ7XG4gICAgICAgIHBvaW50cy5wdXNoKHsgeCwgeSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWloZW5mb2xnZTogV2VsbGVuZnJvbnQgdm9tIEFuY2hvciArIG1pbmltYWxlIFZhcmlhbnpcbiAgcG9pbnRzLnNvcnQoKHAxLCBwMikgPT4ge1xuICAgIGNvbnN0IGQxID0gTWF0aC5oeXBvdChwMS54IC0gYW5jaG9yLngsIHAxLnkgLSBhbmNob3IueSk7XG4gICAgY29uc3QgZDIgPSBNYXRoLmh5cG90KHAyLnggLSBhbmNob3IueCwgcDIueSAtIGFuY2hvci55KTtcbiAgICByZXR1cm4gKGQxIC0gZDIpICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi41O1xuICB9KTtcblxuICAvLyBBdWZiYXUtUmF0ZSBzbyB3w6RobGVuLCBkYXNzIH41IFNla3VuZGVuIGVycmVpY2h0IHdlcmRlblxuICAvLyBBbm5haG1lIH42MCBGUFMgLT4gZHVyYXRpb25TZWMgKiA2MCBGcmFtZXNcbiAgY29uc3QgZnJhbWVzVGFyZ2V0ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChkdXJhdGlvblNlYyAqIDYwKSk7XG4gIGNvbnN0IHBlckZyYW1lID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHBvaW50cy5sZW5ndGggLyBmcmFtZXNUYXJnZXQpKTtcblxuICAvLyBlcnN0ZXIgUHVua3QgKE1ldGVvci9BbmNob3IpXG4gIGRyYXdEb3QoYW5jaG9yLngsIGFuY2hvci55LCBkb3RSYWRpdXMgKyAwLjgpO1xuXG4gIGxldCBpZHggPSAwO1xuICBmdW5jdGlvbiBmcmFtZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlckZyYW1lICYmIGlkeCA8IHBvaW50cy5sZW5ndGg7IGkrKywgaWR4KyspIHtcbiAgICAgIGNvbnN0IHAgPSBwb2ludHNbaWR4XTtcbiAgICAgIGRyYXdEb3QocC54LCBwLnksIGRvdFJhZGl1cyk7XG4gICAgfVxuICAgIGlmIChpZHggPCBwb2ludHMubGVuZ3RoKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG5cbiAgZnVuY3Rpb24gZHJhd0RvdCh4OiBudW1iZXIsIHk6IG51bWJlciwgcjogbnVtYmVyKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnI0ZGRDcwMCc7XG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMjU1LCAyMTUsIDAsIDAuMzUpJztcbiAgICBjdHguc2hhZG93Qmx1ciA9IHNoYWRvd0JsdXI7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImJ1aWxkQ3J5c3RhbE0iLCJjdHgiLCJhbmNob3IiLCJpc01vYmlsZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJyZWN0IiwiY2FudmFzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsImJhc2VYIiwiYmFzZVkiLCJzcGFuWCIsIk1hdGgiLCJtYXgiLCJwZWFrWSIsIm1pbiIsIlAiLCJ4IiwieSIsInNlZ3MiLCJhIiwiYiIsInNwYWNpbmdBbG9uZyIsInRoaWNrbmVzcyIsInNwYWNpbmdBY3Jvc3MiLCJkb3RSYWRpdXMiLCJzaGFkb3dCbHVyIiwiZHVyYXRpb25TZWMiLCJwb2ludHMiLCJkeCIsImR5IiwibGVuIiwiaHlwb3QiLCJ0eCIsInR5IiwibngiLCJueSIsInJvd3MiLCJyb3VuZCIsImhhbGYiLCJzdGVwcyIsImZsb29yIiwiciIsIm9mZnNldCIsInN0YWdnZXIiLCJpIiwiZCIsInB1c2giLCJzb3J0IiwicDEiLCJwMiIsImQxIiwiZDIiLCJyYW5kb20iLCJmcmFtZXNUYXJnZXQiLCJwZXJGcmFtZSIsImNlaWwiLCJsZW5ndGgiLCJkcmF3RG90IiwiaWR4IiwiZnJhbWUiLCJwIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsImZpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});