"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; },\n/* harmony export */   computeMAnchor: function() { return /* binding */ computeMAnchor; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n/** Linker unterer Anker exakt wie im M */ function computeMAnchor(w, h) {\n    const leftX = w * 0.28;\n    const baseY = h * 0.74;\n    return {\n        x: leftX,\n        y: baseY\n    };\n}\n/**\n * Pen-Sweep: Ein digitaler Stift fährt den Pfad P0→P1→P2→P3→P4 in ~5 s ab\n * und setzt unterwegs Punkte (mehrere parallele Reihen = Strichbreite)\n * mit Mindestabstand. Runde Caps + runde Joins; Valley-Plug füllt die V-Kerbe.\n * Zusätzlich: runde Außenkappen an den oberen Ecken (P1, P3).\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    const { width: w, height: h } = ctx.canvas.getBoundingClientRect();\n    // Proportionen (aufrechte Säulen, edel)\n    const baseY = h * 0.74;\n    const topY = h * 0.36;\n    const leftX = w * 0.28;\n    const rightX = w * 0.28 + Math.max(360, w * 0.32);\n    const midX = (leftX + rightX) / 2;\n    const valleyY = baseY - Math.max(90, h * 0.14);\n    const P = [\n        {\n            x: leftX,\n            y: baseY\n        },\n        {\n            x: leftX,\n            y: topY\n        },\n        {\n            x: midX,\n            y: valleyY\n        },\n        {\n            x: rightX,\n            y: topY\n        },\n        {\n            x: rightX,\n            y: baseY\n        } // 4\n    ];\n    // Segmente + Geometrie\n    const segs = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ].map((s)=>{\n        const dx = s.b.x - s.a.x;\n        const dy = s.b.y - s.a.y;\n        const len = Math.hypot(dx, dy);\n        const tx = len ? dx / len : 0;\n        const ty = len ? dy / len : 0;\n        const nx = ty;\n        const ny = -tx;\n        return {\n            ...s,\n            dx,\n            dy,\n            len,\n            tx,\n            ty,\n            nx,\n            ny\n        };\n    });\n    const totalLen = segs.reduce((s, g)=>s + g.len, 0);\n    // Look & Rasterabstände\n    const dotR = isMobile ? 1.3 : 1.6;\n    const minGap = isMobile ? 1.8 : 2.2;\n    const stepAlong = Math.max(isMobile ? 2.4 : 2.0, dotR * 2 + (minGap - 0.6));\n    const gapAcross = Math.max(isMobile ? 4.8 : 4.2, dotR * 2 + minGap);\n    const widthPx = isMobile ? 28 : 56;\n    const rows = Math.max(1, Math.floor(widthPx / gapAcross));\n    const durationSec = 5;\n    // Zeitsteuerung\n    const start = performance.now();\n    let prevS = 0;\n    let raf = 0;\n    // Spatial Hash (Abstands-Garantie)\n    const cell = Math.min(stepAlong, gapAcross) * 0.9;\n    const placed = new Set();\n    const key = (x, y)=>\"\".concat(Math.round(x / cell), \":\").concat(Math.round(y / cell));\n    const drawDot = function(x, y) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : dotR;\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#6BD5FF\";\n        ctx.shadowColor = \"rgba(107,213,255,0.55)\";\n        ctx.shadowBlur = 4;\n        ctx.fill();\n    };\n    const tryDot = function(x, y) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : dotR;\n        const k = key(x, y);\n        if (placed.has(k)) return false;\n        placed.add(k);\n        drawDot(x, y, r);\n        return true;\n    };\n    // Erstpunkt (Anchor)\n    tryDot(anchor.x, anchor.y, dotR + 0.9);\n    const extras = [];\n    // Start-Cap (Halbkreis am P0)\n    if (segs[0]) {\n        pushRoundCap(extras, P[0], -segs[0].tx, -segs[0].ty, rows, gapAcross, dotR, stepAlong, 0);\n    }\n    // Joins + Outer-Caps + Valley-Plug\n    for(let i = 1; i < segs.length; i++){\n        const prev = segs[i - 1];\n        const next = segs[i];\n        const sAtCorner = segs.slice(0, i).reduce((s, g)=>s + g.len, 0);\n        // Innen-Join\n        pushRoundJoin(extras, P[i], prev, next, rows, gapAcross, dotR, stepAlong, sAtCorner);\n        // Tal (innen) auffüllen\n        if (i === 2) {\n            pushValleyPlug(extras, P[2], segs[1], segs[2], rows, gapAcross, dotR, sAtCorner);\n        } else {\n            // Obere Außenkappen an P1 und P3\n            pushOuterCornerCap(extras, P[i], prev, next, rows, gapAcross, dotR, sAtCorner);\n        }\n    }\n    // End-Cap (Halbkreis am P4)\n    const lenBeforeEnd = segs.reduce((s, g)=>s + g.len, 0);\n    pushRoundCap(extras, P[4], segs[segs.length - 1].tx, segs[segs.length - 1].ty, rows, gapAcross, dotR, stepAlong, lenBeforeEnd);\n    // Sortieren, damit die Einblendung zeitlich in den Sweep passt\n    extras.sort((a, b)=>a.s - b.s);\n    let extraIdx = 0;\n    // PEN-SWEEP\n    function tick(now) {\n        const t = Math.min((now - start) / (durationSec * 1000), 1);\n        const sTarget = t * totalLen;\n        // entlang des Pfads Punkte setzen (mehrere Reihen = Strichbreite)\n        for(let s = prevS; s <= sTarget; s += stepAlong){\n            const pos = pointAtLength(s);\n            if (!pos) continue;\n            const { x, y, nx, ny } = pos;\n            const half = (rows - 1) / 2;\n            for(let r = 0; r < rows; r++){\n                const offset = (r - half) * gapAcross;\n                tryDot(x + nx * offset, y + ny * offset);\n            }\n        }\n        prevS = sTarget;\n        // Extras, deren s erreicht ist\n        while(extraIdx < extras.length && extras[extraIdx].s <= sTarget){\n            const e = extras[extraIdx++];\n            var _e_r;\n            tryDot(e.x, e.y, (_e_r = e.r) !== null && _e_r !== void 0 ? _e_r : dotR);\n        }\n        if (t < 1 || extraIdx < extras.length) {\n            raf = requestAnimationFrame(tick);\n        } else {\n            cancelAnimationFrame(raf);\n        }\n    }\n    raf = requestAnimationFrame(tick);\n    // ---------- Helpers -------------------------------------------------------\n    function pointAtLength(s) {\n        let acc = 0;\n        for (const g of segs){\n            if (s <= acc + g.len) {\n                const d = s - acc;\n                const t = g.len ? d / g.len : 0;\n                const x = g.a.x + g.dx * t;\n                const y = g.a.y + g.dy * t;\n                return {\n                    x,\n                    y,\n                    nx: g.nx,\n                    ny: g.ny\n                };\n            }\n            acc += g.len;\n        }\n        const last = segs[segs.length - 1];\n        return {\n            x: last.b.x,\n            y: last.b.y,\n            nx: last.ny,\n            ny: -last.nx\n        };\n    }\n    // runder End-/Start-Cap (Halbkreis)\n    function pushRoundCap(out, C, tx, ty, nRows, across, rDot, along, sBase) {\n        const half = (nRows - 1) / 2;\n        const radius = half * across;\n        const arcStart = Math.atan2(-ty, -tx) - Math.PI / 2;\n        const arcEnd = arcStart + Math.PI;\n        const ringStep = Math.max(rDot * 2 + minGap, across * 0.9);\n        const rings = Math.max(1, Math.floor(radius / ringStep));\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * ringStep;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const pts = Math.max(6, Math.floor(circ / (rDot * 2 + minGap)));\n            for(let i = 0; i <= pts; i++){\n                const a = arcStart + i / pts * (arcEnd - arcStart);\n                out.push({\n                    s: sBase + 0.001 * seq++,\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad\n                });\n            }\n        }\n    }\n    // runder Join (Sektor) zwischen zwei Segmenten am Eckpunkt C (inkl. Large-Arc)\n    function pushRoundJoin(out, C, prev, next, nRows, across, rDot, along, sAtCorner) {\n        const aIn = Math.atan2(prev.ny, prev.nx);\n        const aOut = Math.atan2(next.ny, next.nx);\n        // Tangenten (für konkav/konvex)\n        let tIn = Math.atan2(prev.ty, prev.tx);\n        let tOut = Math.atan2(next.ty, next.tx);\n        while(tOut - tIn <= -Math.PI)tOut += 2 * Math.PI;\n        while(tOut - tIn > Math.PI)tOut -= 2 * Math.PI;\n        const turn = tOut - tIn;\n        // Winkel-Differenz der Normalen auf [-π,π]\n        let delta = aOut - aIn;\n        while(delta <= -Math.PI)delta += 2 * Math.PI;\n        while(delta > Math.PI)delta -= 2 * Math.PI;\n        // konkav → großen Bogen nehmen\n        const useLargeArc = Math.abs(turn) > Math.PI / 2;\n        let startAngle = aIn;\n        let endAngle = aIn + delta;\n        if (useLargeArc) {\n            if (delta > 0) endAngle = aIn - (2 * Math.PI - delta);\n            else endAngle = aIn + (2 * Math.PI + delta);\n        }\n        const radius = (nRows - 1) * across / 2;\n        const ringStep = Math.max(rDot * 2 + minGap, across * 0.9);\n        const rings = Math.max(1, Math.floor(radius / ringStep));\n        const angStep = Math.max((rDot * 2 + minGap) / Math.max(radius, 1), Math.PI / 36);\n        const dir = endAngle >= startAngle ? 1 : -1;\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * ringStep;\n            for(let a = startAngle; dir > 0 ? a <= endAngle : a >= endAngle; a += dir * angStep){\n                out.push({\n                    s: sAtCorner + 0.001 * seq++,\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad\n                });\n            }\n        }\n        out.push({\n            s: sAtCorner + 0.002 * seq++,\n            x: C.x,\n            y: C.y,\n            r: rDot\n        });\n    }\n    // füllt die innere V-Ecke (Tal) weich\n    function pushValleyPlug(out, C, prev, next, nRows, across, rDot, sAtCorner) {\n        // Innen-Bisektor\n        let bx = -prev.tx + next.tx;\n        let by = -prev.ty + next.ty;\n        const bl = Math.hypot(bx, by) || 1;\n        bx /= bl;\n        by /= bl;\n        const innerR = (nRows - 1) * across * 0.48;\n        const cx = C.x + bx * (innerR * 0.35);\n        const cy = C.y + by * (innerR * 0.35);\n        const ringStep = Math.max(rDot * 2.0, across * 0.9);\n        const rings = Math.max(2, Math.floor(innerR / ringStep));\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r / rings * innerR;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const step = Math.max(rDot * 2.0, across * 0.9);\n            const n = Math.max(8, Math.floor(circ / step));\n            for(let i = 0; i < n; i++){\n                const a = i / n * Math.PI * 2;\n                out.push({\n                    s: sAtCorner + 0.001 * seq++,\n                    x: cx + Math.cos(a) * rad,\n                    y: cy + Math.sin(a) * rad\n                });\n            }\n        }\n        out.push({\n            s: sAtCorner + 0.002 * seq++,\n            x: cx,\n            y: cy,\n            r: rDot\n        });\n    }\n    // runde Außenkappe an konvexen oberen Ecken (P1, P3)\n    function pushOuterCornerCap(out, C, prev, next, nRows, across, rDot, sAtCorner) {\n        const radius = (nRows - 1) * across / 2;\n        // Außen-Bisektor aus den linken Normalen\n        let bx = prev.nx + next.nx;\n        let by = prev.ny + next.ny;\n        const bl = Math.hypot(bx, by) || 1;\n        bx /= bl;\n        by /= bl;\n        // Halbkreis nach außen (orthogonal zum Bisektor)\n        const baseAngle = Math.atan2(by, bx);\n        const arcStart = baseAngle - Math.PI / 2;\n        const arcEnd = baseAngle + Math.PI / 2;\n        const ringStep = Math.max(rDot * 2 + minGap, across * 0.9);\n        const rings = Math.max(1, Math.floor(radius / ringStep));\n        let seq = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * ringStep;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const pts = Math.max(6, Math.floor(circ / (rDot * 2 + minGap)));\n            for(let i = 0; i <= pts; i++){\n                const a = arcStart + i / pts * (arcEnd - arcStart);\n                out.push({\n                    s: sAtCorner + 0.001 * seq++,\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad\n                });\n            }\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQkFBK0I7QUFHL0Isd0NBQXdDLEdBQ2pDLFNBQVNBLGVBQWVDLENBQVMsRUFBRUMsQ0FBUztJQUNqRCxNQUFNQyxRQUFRRixJQUFJO0lBQ2xCLE1BQU1HLFFBQVFGLElBQUk7SUFDbEIsT0FBTztRQUFFRyxHQUFHRjtRQUFPRyxHQUFHRjtJQUFNO0FBQzlCO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTRyxjQUFjQyxHQUE2QixFQUFFQyxNQUFVO0lBQ3JFLE1BQU1DLFdBQVcsNEJBQTRCQyxJQUFJLENBQUNDLFVBQVVDLFNBQVM7SUFDckUsTUFBTSxFQUFFQyxPQUFPYixDQUFDLEVBQUVjLFFBQVFiLENBQUMsRUFBRSxHQUFHTSxJQUFJUSxNQUFNLENBQUNDLHFCQUFxQjtJQUVoRSx3Q0FBd0M7SUFDeEMsTUFBTWIsUUFBUUYsSUFBSTtJQUNsQixNQUFNZ0IsT0FBT2hCLElBQUk7SUFDakIsTUFBTUMsUUFBUUYsSUFBSTtJQUNsQixNQUFNa0IsU0FBU2xCLElBQUksT0FBT21CLEtBQUtDLEdBQUcsQ0FBQyxLQUFLcEIsSUFBSTtJQUM1QyxNQUFNcUIsT0FBTyxDQUFDbkIsUUFBUWdCLE1BQUssSUFBSztJQUNoQyxNQUFNSSxVQUFVbkIsUUFBUWdCLEtBQUtDLEdBQUcsQ0FBQyxJQUFJbkIsSUFBSTtJQUV6QyxNQUFNc0IsSUFBSTtRQUNSO1lBQUVuQixHQUFHRjtZQUFPRyxHQUFHRjtRQUFNO1FBQ3JCO1lBQUVDLEdBQUdGO1lBQU9HLEdBQUdZO1FBQUs7UUFDcEI7WUFBRWIsR0FBR2lCO1lBQU1oQixHQUFHaUI7UUFBUTtRQUN0QjtZQUFFbEIsR0FBR2M7WUFBUWIsR0FBR1k7UUFBSztRQUNyQjtZQUFFYixHQUFHYztZQUFRYixHQUFHRjtRQUFNLEVBQUUsSUFBSTtLQUM3QjtJQUVELHVCQUF1QjtJQUN2QixNQUFNcUIsT0FBTztR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V0FBV2dDLFlBQVl4SCxLQUFLNEMsRUFBRSxHQUFHO1FBQ3ZDLE1BQU04QyxTQUFTOEIsWUFBWXhILEtBQUs0QyxFQUFFLEdBQUc7UUFFckMsTUFBTStDLFdBQVczRixLQUFLQyxHQUFHLENBQUNtRixPQUFPLElBQUk5RCxRQUFRNkQsU0FBUztRQUN0RCxNQUFNUyxRQUFRNUYsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUsyQixLQUFLLENBQUM0RCxTQUFTSTtRQUM5QyxJQUFJRSxNQUFNO1FBQ1YsSUFBSyxJQUFJcEQsSUFBSSxHQUFHQSxLQUFLbUQsT0FBT25ELElBQUs7WUFDL0IsTUFBTXFELE1BQU1yRCxJQUFJa0Q7WUFDaEIsTUFBTUksT0FBTyxJQUFJL0YsS0FBSzRDLEVBQUUsR0FBRzVDLEtBQUtDLEdBQUcsQ0FBQzZGLEtBQUs7WUFDekMsTUFBTUUsTUFBTWhHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLMkIsS0FBSyxDQUFDb0UsT0FBUVgsQ0FBQUEsT0FBTyxJQUFJOUQsTUFBSztZQUMzRCxJQUFLLElBQUlpQyxJQUFJLEdBQUdBLEtBQUt5QyxLQUFLekMsSUFBSztnQkFDN0IsTUFBTWpELElBQUlrRixXQUFXLElBQUtRLE1BQVFOLENBQUFBLFNBQVNGLFFBQU87Z0JBQ2xEUixJQUFJaUIsSUFBSSxDQUFDO29CQUNQeEYsR0FBR2tELFlBQVksUUFBU2tDO29CQUN4QjVHLEdBQUdnRyxFQUFFaEcsQ0FBQyxHQUFHZSxLQUFLa0csR0FBRyxDQUFDNUYsS0FBS3dGO29CQUN2QjVHLEdBQUcrRixFQUFFL0YsQ0FBQyxHQUFHYyxLQUFLbUcsR0FBRyxDQUFDN0YsS0FBS3dGO2dCQUN6QjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHM/NDZjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzXG50eXBlIFhZID0geyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG5cbi8qKiBMaW5rZXIgdW50ZXJlciBBbmtlciBleGFrdCB3aWUgaW0gTSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVNQW5jaG9yKHc6IG51bWJlciwgaDogbnVtYmVyKTogWFkge1xuICBjb25zdCBsZWZ0WCA9IHcgKiAwLjI4XG4gIGNvbnN0IGJhc2VZID0gaCAqIDAuNzRcbiAgcmV0dXJuIHsgeDogbGVmdFgsIHk6IGJhc2VZIH1cbn1cblxuLyoqXG4gKiBQZW4tU3dlZXA6IEVpbiBkaWdpdGFsZXIgU3RpZnQgZsOkaHJ0IGRlbiBQZmFkIFAw4oaSUDHihpJQMuKGklAz4oaSUDQgaW4gfjUgcyBhYlxuICogdW5kIHNldHp0IHVudGVyd2VncyBQdW5rdGUgKG1laHJlcmUgcGFyYWxsZWxlIFJlaWhlbiA9IFN0cmljaGJyZWl0ZSlcbiAqIG1pdCBNaW5kZXN0YWJzdGFuZC4gUnVuZGUgQ2FwcyArIHJ1bmRlIEpvaW5zOyBWYWxsZXktUGx1ZyBmw7xsbHQgZGllIFYtS2VyYmUuXG4gKiBadXPDpHR6bGljaDogcnVuZGUgQXXDn2Vua2FwcGVuIGFuIGRlbiBvYmVyZW4gRWNrZW4gKFAxLCBQMykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENyeXN0YWxNKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhbmNob3I6IFhZKSB7XG4gIGNvbnN0IGlzTW9iaWxlID0gL01vYml8QW5kcm9pZHxpUGhvbmV8aVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgY29uc3QgeyB3aWR0aDogdywgaGVpZ2h0OiBoIH0gPSBjdHguY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgLy8gUHJvcG9ydGlvbmVuIChhdWZyZWNodGUgU8OkdWxlbiwgZWRlbClcbiAgY29uc3QgYmFzZVkgPSBoICogMC43NFxuICBjb25zdCB0b3BZID0gaCAqIDAuMzZcbiAgY29uc3QgbGVmdFggPSB3ICogMC4yOFxuICBjb25zdCByaWdodFggPSB3ICogMC4yOCArIE1hdGgubWF4KDM2MCwgdyAqIDAuMzIpXG4gIGNvbnN0IG1pZFggPSAobGVmdFggKyByaWdodFgpIC8gMlxuICBjb25zdCB2YWxsZXlZID0gYmFzZVkgLSBNYXRoLm1heCg5MCwgaCAqIDAuMTQpXG5cbiAgY29uc3QgUCA9IFtcbiAgICB7IHg6IGxlZnRYLCB5OiBiYXNlWSB9LCAvLyAwXG4gICAgeyB4OiBsZWZ0WCwgeTogdG9wWSB9LCAvLyAxXG4gICAgeyB4OiBtaWRYLCB5OiB2YWxsZXlZIH0sIC8vIDJcbiAgICB7IHg6IHJpZ2h0WCwgeTogdG9wWSB9LCAvLyAzXG4gICAgeyB4OiByaWdodFgsIHk6IGJhc2VZIH0gLy8gNFxuICBdIGFzIGNvbnN0XG5cbiAgLy8gU2VnbWVudGUgKyBHZW9tZXRyaWVcbiAgY29uc3Qgc2VncyA9IFtcbiAgICB7IGE6IFBbMF0sIGI6IFBbMV0gfSxcbiAgICB7IGE6IFBbMV0sIGI6IFBbMl0gfSxcbiAgICB7IGE6IFBbMl0sIGI6IFBbM10gfSxcbiAgICB7IGE6IFBbM10sIGI6IFBbNF0gfVxuICBdLm1hcChzID0+IHtcbiAgICBjb25zdCBkeCA9IHMuYi54IC0gcy5hLnhcbiAgICBjb25zdCBkeSA9IHMuYi55IC0gcy5hLnlcbiAgICBjb25zdCBsZW4gPSBNYXRoLmh5cG90KGR4LCBkeSlcbiAgICBjb25zdCB0eCA9IGxlbiA/IGR4IC8gbGVuIDogMFxuICAgIGNvbnN0IHR5ID0gbGVuID8gZHkgLyBsZW4gOiAwXG4gICAgY29uc3QgbnggPSB0eVxuICAgIGNvbnN0IG55ID0gLXR4XG4gICAgcmV0dXJuIHsgLi4ucywgZHgsIGR5LCBsZW4sIHR4LCB0eSwgbngsIG55IH1cbiAgfSlcblxuICBjb25zdCB0b3RhbExlbiA9IHNlZ3MucmVkdWNlKChzLCBnKSA9PiBzICsgZy5sZW4sIDApXG5cbiAgLy8gTG9vayAmIFJhc3RlcmFic3TDpG5kZVxuICBjb25zdCBkb3RSID0gaXNNb2JpbGUgPyAxLjMgOiAxLjZcbiAgY29uc3QgbWluR2FwID0gaXNNb2JpbGUgPyAxLjggOiAyLjJcbiAgY29uc3Qgc3RlcEFsb25nID0gTWF0aC5tYXgoaXNNb2JpbGUgPyAyLjQgOiAyLjAsIGRvdFIgKiAyICsgKG1pbkdhcCAtIDAuNikpXG4gIGNvbnN0IGdhcEFjcm9zcyA9IE1hdGgubWF4KGlzTW9iaWxlID8gNC44IDogNC4yLCBkb3RSICogMiArIG1pbkdhcClcbiAgY29uc3Qgd2lkdGhQeCA9IGlzTW9iaWxlID8gMjggOiA1NlxuICBjb25zdCByb3dzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih3aWR0aFB4IC8gZ2FwQWNyb3NzKSlcbiAgY29uc3QgZHVyYXRpb25TZWMgPSA1XG5cbiAgLy8gWmVpdHN0ZXVlcnVuZ1xuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIGxldCBwcmV2UyA9IDBcbiAgbGV0IHJhZiA9IDBcblxuICAvLyBTcGF0aWFsIEhhc2ggKEFic3RhbmRzLUdhcmFudGllKVxuICBjb25zdCBjZWxsID0gTWF0aC5taW4oc3RlcEFsb25nLCBnYXBBY3Jvc3MpICogMC45XG4gIGNvbnN0IHBsYWNlZCA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IGtleSA9ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gYCR7TWF0aC5yb3VuZCh4IC8gY2VsbCl9OiR7TWF0aC5yb3VuZCh5IC8gY2VsbCl9YFxuICBjb25zdCBkcmF3RG90ID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCByOiBudW1iZXIgPSBkb3RSKSA9PiB7XG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LmFyYyh4LCB5LCByLCAwLCBNYXRoLlBJICogMilcbiAgICBjdHguZmlsbFN0eWxlID0gJyM2QkQ1RkYnXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMTA3LDIxMywyNTUsMC41NSknXG4gICAgY3R4LnNoYWRvd0JsdXIgPSA0XG4gICAgY3R4LmZpbGwoKVxuICB9XG4gIGNvbnN0IHRyeURvdCA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgcjogbnVtYmVyID0gZG90UikgPT4ge1xuICAgIGNvbnN0IGsgPSBrZXkoeCwgeSlcbiAgICBpZiAocGxhY2VkLmhhcyhrKSkgcmV0dXJuIGZhbHNlXG4gICAgcGxhY2VkLmFkZChrKVxuICAgIGRyYXdEb3QoeCwgeSwgcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gRXJzdHB1bmt0IChBbmNob3IpXG4gIHRyeURvdChhbmNob3IueCwgYW5jaG9yLnksIGRvdFIgKyAwLjkpXG5cbiAgLy8gRXh0cmFzIChDYXBzL0pvaW5zL1ZhbGxleS1QbHVnL091dGVyLUNhcHMpXG4gIHR5cGUgRXh0cmEgPSB7IHM6IG51bWJlcjsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHI/OiBudW1iZXIgfVxuICBjb25zdCBleHRyYXM6IEV4dHJhW10gPSBbXVxuXG4gIC8vIFN0YXJ0LUNhcCAoSGFsYmtyZWlzIGFtIFAwKVxuICBpZiAoc2Vnc1swXSkge1xuICAgIHB1c2hSb3VuZENhcChleHRyYXMsIFBbMF0sIC1zZWdzWzBdLnR4LCAtc2Vnc1swXS50eSwgcm93cywgZ2FwQWNyb3NzLCBkb3RSLCBzdGVwQWxvbmcsIDApXG4gIH1cblxuICAvLyBKb2lucyArIE91dGVyLUNhcHMgKyBWYWxsZXktUGx1Z1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gc2Vnc1tpIC0gMV1cbiAgICBjb25zdCBuZXh0ID0gc2Vnc1tpXVxuICAgIGNvbnN0IHNBdENvcm5lciA9IHNlZ3Muc2xpY2UoMCwgaSkucmVkdWNlKChzLCBnKSA9PiBzICsgZy5sZW4sIDApXG5cbiAgICAvLyBJbm5lbi1Kb2luXG4gICAgcHVzaFJvdW5kSm9pbihleHRyYXMsIFBbaV0sIHByZXYsIG5leHQsIHJvd3MsIGdhcEFjcm9zcywgZG90Uiwgc3RlcEFsb25nLCBzQXRDb3JuZXIpXG5cbiAgICAvLyBUYWwgKGlubmVuKSBhdWZmw7xsbGVuXG4gICAgaWYgKGkgPT09IDIpIHtcbiAgICAgIHB1c2hWYWxsZXlQbHVnKGV4dHJhcywgUFsyXSwgc2Vnc1sxXSwgc2Vnc1syXSwgcm93cywgZ2FwQWNyb3NzLCBkb3RSLCBzQXRDb3JuZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iZXJlIEF1w59lbmthcHBlbiBhbiBQMSB1bmQgUDNcbiAgICAgIHB1c2hPdXRlckNvcm5lckNhcChleHRyYXMsIFBbaV0sIHByZXYsIG5leHQsIHJvd3MsIGdhcEFjcm9zcywgZG90Uiwgc0F0Q29ybmVyKVxuICAgIH1cbiAgfVxuXG4gIC8vIEVuZC1DYXAgKEhhbGJrcmVpcyBhbSBQNClcbiAgY29uc3QgbGVuQmVmb3JlRW5kID0gc2Vncy5yZWR1Y2UoKHMsIGcpID0+IHMgKyBnLmxlbiwgMClcbiAgcHVzaFJvdW5kQ2FwKFxuICAgIGV4dHJhcyxcbiAgICBQWzRdLFxuICAgIHNlZ3Nbc2Vncy5sZW5ndGggLSAxXS50eCxcbiAgICBzZWdzW3NlZ3MubGVuZ3RoIC0gMV0udHksXG4gICAgcm93cyxcbiAgICBnYXBBY3Jvc3MsXG4gICAgZG90UixcbiAgICBzdGVwQWxvbmcsXG4gICAgbGVuQmVmb3JlRW5kXG4gIClcblxuICAvLyBTb3J0aWVyZW4sIGRhbWl0IGRpZSBFaW5ibGVuZHVuZyB6ZWl0bGljaCBpbiBkZW4gU3dlZXAgcGFzc3RcbiAgZXh0cmFzLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgbGV0IGV4dHJhSWR4ID0gMFxuXG4gIC8vIFBFTi1TV0VFUFxuICBmdW5jdGlvbiB0aWNrKG5vdzogbnVtYmVyKSB7XG4gICAgY29uc3QgdCA9IE1hdGgubWluKChub3cgLSBzdGFydCkgLyAoZHVyYXRpb25TZWMgKiAxMDAwKSwgMSlcbiAgICBjb25zdCBzVGFyZ2V0ID0gdCAqIHRvdGFsTGVuXG5cbiAgICAvLyBlbnRsYW5nIGRlcyBQZmFkcyBQdW5rdGUgc2V0emVuIChtZWhyZXJlIFJlaWhlbiA9IFN0cmljaGJyZWl0ZSlcbiAgICBmb3IgKGxldCBzID0gcHJldlM7IHMgPD0gc1RhcmdldDsgcyArPSBzdGVwQWxvbmcpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHBvaW50QXRMZW5ndGgocylcbiAgICAgIGlmICghcG9zKSBjb250aW51ZVxuICAgICAgY29uc3QgeyB4LCB5LCBueCwgbnkgfSA9IHBvc1xuICAgICAgY29uc3QgaGFsZiA9IChyb3dzIC0gMSkgLyAyXG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAociAtIGhhbGYpICogZ2FwQWNyb3NzXG4gICAgICAgIHRyeURvdCh4ICsgbnggKiBvZmZzZXQsIHkgKyBueSAqIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldlMgPSBzVGFyZ2V0XG5cbiAgICAvLyBFeHRyYXMsIGRlcmVuIHMgZXJyZWljaHQgaXN0XG4gICAgd2hpbGUgKGV4dHJhSWR4IDwgZXh0cmFzLmxlbmd0aCAmJiBleHRyYXNbZXh0cmFJZHhdLnMgPD0gc1RhcmdldCkge1xuICAgICAgY29uc3QgZSA9IGV4dHJhc1tleHRyYUlkeCsrXVxuICAgICAgdHJ5RG90KGUueCwgZS55LCBlLnIgPz8gZG90UilcbiAgICB9XG5cbiAgICBpZiAodCA8IDEgfHwgZXh0cmFJZHggPCBleHRyYXMubGVuZ3RoKSB7XG4gICAgICByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljaylcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKVxuICAgIH1cbiAgfVxuICByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljaylcblxuICAvLyAtLS0tLS0tLS0tIEhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGZ1bmN0aW9uIHBvaW50QXRMZW5ndGgoXG4gICAgczogbnVtYmVyXG4gICk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IG54OiBudW1iZXI7IG55OiBudW1iZXIgfSB8IG51bGwge1xuICAgIGxldCBhY2MgPSAwXG4gICAgZm9yIChjb25zdCBnIG9mIHNlZ3MpIHtcbiAgICAgIGlmIChzIDw9IGFjYyArIGcubGVuKSB7XG4gICAgICAgIGNvbnN0IGQgPSBzIC0gYWNjXG4gICAgICAgIGNvbnN0IHQgPSBnLmxlbiA/IGQgLyBnLmxlbiA6IDBcbiAgICAgICAgY29uc3QgeCA9IGcuYS54ICsgZy5keCAqIHRcbiAgICAgICAgY29uc3QgeSA9IGcuYS55ICsgZy5keSAqIHRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSwgbng6IGcubngsIG55OiBnLm55IH1cbiAgICAgIH1cbiAgICAgIGFjYyArPSBnLmxlblxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gc2Vnc1tzZWdzLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIHsgeDogbGFzdC5iLngsIHk6IGxhc3QuYi55LCBueDogbGFzdC5ueSwgbnk6IC1sYXN0Lm54IH1cbiAgfVxuXG4gIC8vIHJ1bmRlciBFbmQtL1N0YXJ0LUNhcCAoSGFsYmtyZWlzKVxuICBmdW5jdGlvbiBwdXNoUm91bmRDYXAoXG4gICAgb3V0OiBFeHRyYVtdLFxuICAgIEM6IFhZLFxuICAgIHR4OiBudW1iZXIsXG4gICAgdHk6IG51bWJlcixcbiAgICBuUm93czogbnVtYmVyLFxuICAgIGFjcm9zczogbnVtYmVyLFxuICAgIHJEb3Q6IG51bWJlcixcbiAgICBhbG9uZzogbnVtYmVyLFxuICAgIHNCYXNlOiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgaGFsZiA9IChuUm93cyAtIDEpIC8gMlxuICAgIGNvbnN0IHJhZGl1cyA9IGhhbGYgKiBhY3Jvc3NcbiAgICBjb25zdCBhcmNTdGFydCA9IE1hdGguYXRhbjIoLXR5LCAtdHgpIC0gTWF0aC5QSSAvIDJcbiAgICBjb25zdCBhcmNFbmQgPSBhcmNTdGFydCArIE1hdGguUElcblxuICAgIGNvbnN0IHJpbmdTdGVwID0gTWF0aC5tYXgockRvdCAqIDIgKyBtaW5HYXAsIGFjcm9zcyAqIDAuOSlcbiAgICBjb25zdCByaW5ncyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmFkaXVzIC8gcmluZ1N0ZXApKVxuICAgIGxldCBzZXEgPSAwXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gcmluZ3M7IHIrKykge1xuICAgICAgY29uc3QgcmFkID0gciAqIHJpbmdTdGVwXG4gICAgICBjb25zdCBjaXJjID0gMiAqIE1hdGguUEkgKiBNYXRoLm1heChyYWQsIDEpXG4gICAgICBjb25zdCBwdHMgPSBNYXRoLm1heCg2LCBNYXRoLmZsb29yKGNpcmMgLyAockRvdCAqIDIgKyBtaW5HYXApKSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHB0czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcmNTdGFydCArIChpIC8gcHRzKSAqIChhcmNFbmQgLSBhcmNTdGFydClcbiAgICAgICAgb3V0LnB1c2goe1xuICAgICAgICAgIHM6IHNCYXNlICsgMC4wMDEgKiAoc2VxKyspLFxuICAgICAgICAgIHg6IEMueCArIE1hdGguY29zKGEpICogcmFkLFxuICAgICAgICAgIHk6IEMueSArIE1hdGguc2luKGEpICogcmFkXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcnVuZGVyIEpvaW4gKFNla3Rvcikgendpc2NoZW4gendlaSBTZWdtZW50ZW4gYW0gRWNrcHVua3QgQyAoaW5rbC4gTGFyZ2UtQXJjKVxuICBmdW5jdGlvbiBwdXNoUm91bmRKb2luKFxuICAgIG91dDogRXh0cmFbXSxcbiAgICBDOiBYWSxcbiAgICBwcmV2OiBhbnksXG4gICAgbmV4dDogYW55LFxuICAgIG5Sb3dzOiBudW1iZXIsXG4gICAgYWNyb3NzOiBudW1iZXIsXG4gICAgckRvdDogbnVtYmVyLFxuICAgIGFsb25nOiBudW1iZXIsXG4gICAgc0F0Q29ybmVyOiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgYUluID0gTWF0aC5hdGFuMihwcmV2Lm55LCBwcmV2Lm54KVxuICAgIGNvbnN0IGFPdXQgPSBNYXRoLmF0YW4yKG5leHQubnksIG5leHQubngpXG5cbiAgICAvLyBUYW5nZW50ZW4gKGbDvHIga29ua2F2L2tvbnZleClcbiAgICBsZXQgdEluID0gTWF0aC5hdGFuMihwcmV2LnR5LCBwcmV2LnR4KVxuICAgIGxldCB0T3V0ID0gTWF0aC5hdGFuMihuZXh0LnR5LCBuZXh0LnR4KVxuICAgIHdoaWxlICh0T3V0IC0gdEluIDw9IC1NYXRoLlBJKSB0T3V0ICs9IDIgKiBNYXRoLlBJXG4gICAgd2hpbGUgKHRPdXQgLSB0SW4gPiBNYXRoLlBJKSB0T3V0IC09IDIgKiBNYXRoLlBJXG4gICAgY29uc3QgdHVybiA9IHRPdXQgLSB0SW5cblxuICAgIC8vIFdpbmtlbC1EaWZmZXJlbnogZGVyIE5vcm1hbGVuIGF1ZiBbLc+ALM+AXVxuICAgIGxldCBkZWx0YSA9IGFPdXQgLSBhSW5cbiAgICB3aGlsZSAoZGVsdGEgPD0gLU1hdGguUEkpIGRlbHRhICs9IDIgKiBNYXRoLlBJXG4gICAgd2hpbGUgKGRlbHRhID4gTWF0aC5QSSkgZGVsdGEgLT0gMiAqIE1hdGguUElcblxuICAgIC8vIGtvbmthdiDihpIgZ3Jvw59lbiBCb2dlbiBuZWhtZW5cbiAgICBjb25zdCB1c2VMYXJnZUFyYyA9IE1hdGguYWJzKHR1cm4pID4gTWF0aC5QSSAvIDJcbiAgICBsZXQgc3RhcnRBbmdsZSA9IGFJblxuICAgIGxldCBlbmRBbmdsZSA9IGFJbiArIGRlbHRhXG4gICAgaWYgKHVzZUxhcmdlQXJjKSB7XG4gICAgICBpZiAoZGVsdGEgPiAwKSBlbmRBbmdsZSA9IGFJbiAtICgyICogTWF0aC5QSSAtIGRlbHRhKVxuICAgICAgZWxzZSBlbmRBbmdsZSA9IGFJbiArICgyICogTWF0aC5QSSArIGRlbHRhKVxuICAgIH1cblxuICAgIGNvbnN0IHJhZGl1cyA9ICgoblJvd3MgLSAxKSAqIGFjcm9zcykgLyAyXG4gICAgY29uc3QgcmluZ1N0ZXAgPSBNYXRoLm1heChyRG90ICogMiArIG1pbkdhcCwgYWNyb3NzICogMC45KVxuICAgIGNvbnN0IHJpbmdzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyYWRpdXMgLyByaW5nU3RlcCkpXG4gICAgY29uc3QgYW5nU3RlcCA9IE1hdGgubWF4KChyRG90ICogMiArIG1pbkdhcCkgLyBNYXRoLm1heChyYWRpdXMsIDEpLCBNYXRoLlBJIC8gMzYpXG5cbiAgICBjb25zdCBkaXIgPSBlbmRBbmdsZSA+PSBzdGFydEFuZ2xlID8gMSA6IC0xXG4gICAgbGV0IHNlcSA9IDBcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSByaW5nczsgcisrKSB7XG4gICAgICBjb25zdCByYWQgPSByICogcmluZ1N0ZXBcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBhID0gc3RhcnRBbmdsZTtcbiAgICAgICAgZGlyID4gMCA/IGEgPD0gZW5kQW5nbGUgOiBhID49IGVuZEFuZ2xlO1xuICAgICAgICBhICs9IGRpciAqIGFuZ1N0ZXBcbiAgICAgICkge1xuICAgICAgICBvdXQucHVzaCh7XG4gICAgICAgICAgczogc0F0Q29ybmVyICsgMC4wMDEgKiAoc2VxKyspLFxuICAgICAgICAgIHg6IEMueCArIE1hdGguY29zKGEpICogcmFkLFxuICAgICAgICAgIHk6IEMueSArIE1hdGguc2luKGEpICogcmFkXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKHsgczogc0F0Q29ybmVyICsgMC4wMDIgKiAoc2VxKyspLCB4OiBDLngsIHk6IEMueSwgcjogckRvdCB9KVxuICB9XG5cbiAgLy8gZsO8bGx0IGRpZSBpbm5lcmUgVi1FY2tlIChUYWwpIHdlaWNoXG4gIGZ1bmN0aW9uIHB1c2hWYWxsZXlQbHVnKFxuICAgIG91dDogRXh0cmFbXSxcbiAgICBDOiBYWSxcbiAgICBwcmV2OiBhbnksXG4gICAgbmV4dDogYW55LFxuICAgIG5Sb3dzOiBudW1iZXIsXG4gICAgYWNyb3NzOiBudW1iZXIsXG4gICAgckRvdDogbnVtYmVyLFxuICAgIHNBdENvcm5lcjogbnVtYmVyXG4gICkge1xuICAgIC8vIElubmVuLUJpc2VrdG9yXG4gICAgbGV0IGJ4ID0gLXByZXYudHggKyBuZXh0LnR4XG4gICAgbGV0IGJ5ID0gLXByZXYudHkgKyBuZXh0LnR5XG4gICAgY29uc3QgYmwgPSBNYXRoLmh5cG90KGJ4LCBieSkgfHwgMVxuICAgIGJ4IC89IGJsXG4gICAgYnkgLz0gYmxcblxuICAgIGNvbnN0IGlubmVyUiA9IChuUm93cyAtIDEpICogYWNyb3NzICogMC40OFxuICAgIGNvbnN0IGN4ID0gQy54ICsgYnggKiAoaW5uZXJSICogMC4zNSlcbiAgICBjb25zdCBjeSA9IEMueSArIGJ5ICogKGlubmVyUiAqIDAuMzUpXG5cbiAgICBjb25zdCByaW5nU3RlcCA9IE1hdGgubWF4KHJEb3QgKiAyLjAsIGFjcm9zcyAqIDAuOSlcbiAgICBjb25zdCByaW5ncyA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IoaW5uZXJSIC8gcmluZ1N0ZXApKVxuXG4gICAgbGV0IHNlcSA9IDBcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSByaW5nczsgcisrKSB7XG4gICAgICBjb25zdCByYWQgPSAociAvIHJpbmdzKSAqIGlubmVyUlxuICAgICAgY29uc3QgY2lyYyA9IDIgKiBNYXRoLlBJICogTWF0aC5tYXgocmFkLCAxKVxuICAgICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KHJEb3QgKiAyLjAsIGFjcm9zcyAqIDAuOSlcbiAgICAgIGNvbnN0IG4gPSBNYXRoLm1heCg4LCBNYXRoLmZsb29yKGNpcmMgLyBzdGVwKSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSAoaSAvIG4pICogTWF0aC5QSSAqIDJcbiAgICAgICAgb3V0LnB1c2goe1xuICAgICAgICAgIHM6IHNBdENvcm5lciArIDAuMDAxICogKHNlcSsrKSxcbiAgICAgICAgICB4OiBjeCArIE1hdGguY29zKGEpICogcmFkLFxuICAgICAgICAgIHk6IGN5ICsgTWF0aC5zaW4oYSkgKiByYWRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0LnB1c2goeyBzOiBzQXRDb3JuZXIgKyAwLjAwMiAqIChzZXErKyksIHg6IGN4LCB5OiBjeSwgcjogckRvdCB9KVxuICB9XG5cbiAgLy8gcnVuZGUgQXXDn2Vua2FwcGUgYW4ga29udmV4ZW4gb2JlcmVuIEVja2VuIChQMSwgUDMpXG4gIGZ1bmN0aW9uIHB1c2hPdXRlckNvcm5lckNhcChcbiAgICBvdXQ6IEV4dHJhW10sXG4gICAgQzogWFksXG4gICAgcHJldjogYW55LFxuICAgIG5leHQ6IGFueSxcbiAgICBuUm93czogbnVtYmVyLFxuICAgIGFjcm9zczogbnVtYmVyLFxuICAgIHJEb3Q6IG51bWJlcixcbiAgICBzQXRDb3JuZXI6IG51bWJlclxuICApIHtcbiAgICBjb25zdCByYWRpdXMgPSAoKG5Sb3dzIC0gMSkgKiBhY3Jvc3MpIC8gMlxuXG4gICAgLy8gQXXDn2VuLUJpc2VrdG9yIGF1cyBkZW4gbGlua2VuIE5vcm1hbGVuXG4gICAgbGV0IGJ4ID0gcHJldi5ueCArIG5leHQubnhcbiAgICBsZXQgYnkgPSBwcmV2Lm55ICsgbmV4dC5ueVxuICAgIGNvbnN0IGJsID0gTWF0aC5oeXBvdChieCwgYnkpIHx8IDFcbiAgICBieCAvPSBibFxuICAgIGJ5IC89IGJsXG5cbiAgICAvLyBIYWxia3JlaXMgbmFjaCBhdcOfZW4gKG9ydGhvZ29uYWwgenVtIEJpc2VrdG9yKVxuICAgIGNvbnN0IGJhc2VBbmdsZSA9IE1hdGguYXRhbjIoYnksIGJ4KVxuICAgIGNvbnN0IGFyY1N0YXJ0ID0gYmFzZUFuZ2xlIC0gTWF0aC5QSSAvIDJcbiAgICBjb25zdCBhcmNFbmQgPSBiYXNlQW5nbGUgKyBNYXRoLlBJIC8gMlxuXG4gICAgY29uc3QgcmluZ1N0ZXAgPSBNYXRoLm1heChyRG90ICogMiArIG1pbkdhcCwgYWNyb3NzICogMC45KVxuICAgIGNvbnN0IHJpbmdzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyYWRpdXMgLyByaW5nU3RlcCkpXG4gICAgbGV0IHNlcSA9IDBcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSByaW5nczsgcisrKSB7XG4gICAgICBjb25zdCByYWQgPSByICogcmluZ1N0ZXBcbiAgICAgIGNvbnN0IGNpcmMgPSAyICogTWF0aC5QSSAqIE1hdGgubWF4KHJhZCwgMSlcbiAgICAgIGNvbnN0IHB0cyA9IE1hdGgubWF4KDYsIE1hdGguZmxvb3IoY2lyYyAvIChyRG90ICogMiArIG1pbkdhcCkpKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcHRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFyY1N0YXJ0ICsgKGkgLyBwdHMpICogKGFyY0VuZCAtIGFyY1N0YXJ0KVxuICAgICAgICBvdXQucHVzaCh7XG4gICAgICAgICAgczogc0F0Q29ybmVyICsgMC4wMDEgKiAoc2VxKyspLFxuICAgICAgICAgIHg6IEMueCArIE1hdGguY29zKGEpICogcmFkLFxuICAgICAgICAgIHk6IEMueSArIE1hdGguc2luKGEpICogcmFkXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZU1BbmNob3IiLCJ3IiwiaCIsImxlZnRYIiwiYmFzZVkiLCJ4IiwieSIsImJ1aWxkQ3J5c3RhbE0iLCJjdHgiLCJhbmNob3IiLCJpc01vYmlsZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcFkiLCJyaWdodFgiLCJNYXRoIiwibWF4IiwibWlkWCIsInZhbGxleVkiLCJQIiwic2VncyIsImEiLCJiIiwibWFwIiwicyIsImR4IiwiZHkiLCJsZW4iLCJoeXBvdCIsInR4IiwidHkiLCJueCIsIm55IiwidG90YWxMZW4iLCJyZWR1Y2UiLCJnIiwiZG90UiIsIm1pbkdhcCIsInN0ZXBBbG9uZyIsImdhcEFjcm9zcyIsIndpZHRoUHgiLCJyb3dzIiwiZmxvb3IiLCJkdXJhdGlvblNlYyIsInN0YXJ0IiwicGVyZm9ybWFuY2UiLCJub3ciLCJwcmV2UyIsInJhZiIsImNlbGwiLCJtaW4iLCJwbGFjZWQiLCJTZXQiLCJrZXkiLCJyb3VuZCIsImRyYXdEb3QiLCJyIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJmaWxsIiwidHJ5RG90IiwiayIsImhhcyIsImFkZCIsImV4dHJhcyIsInB1c2hSb3VuZENhcCIsImkiLCJsZW5ndGgiLCJwcmV2IiwibmV4dCIsInNBdENvcm5lciIsInNsaWNlIiwicHVzaFJvdW5kSm9pbiIsInB1c2hWYWxsZXlQbHVnIiwicHVzaE91dGVyQ29ybmVyQ2FwIiwibGVuQmVmb3JlRW5kIiwic29ydCIsImV4dHJhSWR4IiwidGljayIsInQiLCJzVGFyZ2V0IiwicG9zIiwicG9pbnRBdExlbmd0aCIsImhhbGYiLCJvZmZzZXQiLCJlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJhY2MiLCJkIiwibGFzdCIsIm91dCIsIkMiLCJuUm93cyIsImFjcm9zcyIsInJEb3QiLCJhbG9uZyIsInNCYXNlIiwicmFkaXVzIiwiYXJjU3RhcnQiLCJhdGFuMiIsImFyY0VuZCIsInJpbmdTdGVwIiwicmluZ3MiLCJzZXEiLCJyYWQiLCJjaXJjIiwicHRzIiwicHVzaCIsImNvcyIsInNpbiIsImFJbiIsImFPdXQiLCJ0SW4iLCJ0T3V0IiwidHVybiIsImRlbHRhIiwidXNlTGFyZ2VBcmMiLCJhYnMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhbmdTdGVwIiwiZGlyIiwiYngiLCJieSIsImJsIiwiaW5uZXJSIiwiY3giLCJjeSIsInN0ZXAiLCJuIiwiYmFzZUFuZ2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});