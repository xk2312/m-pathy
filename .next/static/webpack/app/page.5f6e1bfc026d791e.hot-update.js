"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n// „Kristalline Entfaltung“: Aus dem Ankerpunkt unten links wachsen\n// kristallartige Arme zu den M-Punkten und setzen goldene Punkte.\nfunction buildCrystalM(ctx) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    const w = ctx.canvas.width;\n    const h = ctx.canvas.height;\n    console.log(\"[crystalEngine] start\");\n    // === Responsive Geometrie für ein harmonisches M ===========================\n    // Ankerpunkt: unten links (korrespondiert mit Meteor-Impact)\n    const baseX = w * 0.30;\n    const baseY = h * 0.70;\n    // Gesamtbreite und Spitzenhöhe des M (anpassbar)\n    const spanX = Math.max(160, w * 0.22) // horizontale Spannweite\n    ;\n    const peakY = Math.min(baseY - h * 0.28, h * 0.42) // Höhe der oberen Peaks\n    ;\n    // 5 Schlüsselpunkte (nur Punkte, keine Linien – Kristallarme übernehmen Wege)\n    const mPoints = [\n        {\n            x: baseX,\n            y: baseY\n        },\n        {\n            x: baseX + spanX * 0.25,\n            y: peakY\n        },\n        {\n            x: baseX + spanX * 0.50,\n            y: baseY * 0.93\n        },\n        {\n            x: baseX + spanX * 0.75,\n            y: peakY\n        },\n        {\n            x: baseX + spanX,\n            y: baseY\n        }\n    ];\n    // Von Punkt 0 (Anker) zu allen anderen Punkten wachsen lassen\n    const arms = mPoints.map((p, i)=>({\n            sx: mPoints[0].x,\n            sy: mPoints[0].y,\n            tx: p.x,\n            ty: p.y,\n            t: i === 0 ? 9999 : 0,\n            done: i === 0\n        }));\n    // === Sofort sichtbarer Ankerpunkt =========================================\n    drawGoldPoint(mPoints[0].x, mPoints[0].y, isMobile ? 3 : 4);\n    const maxProgress = isMobile ? 30 : 42 // Frames pro Arm\n    ;\n    let rafId = 0;\n    function drawFrame() {\n        // Weiches Clear für Nachleuchten (Kristall-Trail)\n        ctx.fillStyle = \"rgba(0,0,0,0.22)\";\n        ctx.fillRect(0, 0, w, h);\n        // Ankerpunkt erneut rendern, damit er nie „verschwindet“\n        drawGoldPoint(mPoints[0].x, mPoints[0].y, isMobile ? 3 : 4);\n        let allDone = true;\n        for (const arm of arms){\n            if (!arm.done) {\n                arm.t++;\n                const p = Math.min(arm.t / maxProgress, 1);\n                const nx = arm.sx + (arm.tx - arm.sx) * p;\n                const ny = arm.sy + (arm.ty - arm.sy) * p;\n                // Kristallarm zeichnen\n                ctx.beginPath();\n                ctx.moveTo(arm.sx, arm.sy);\n                ctx.lineTo(nx, ny);\n                ctx.strokeStyle = \"rgba(173,216,230,0.95)\" // hell-kristallblau\n                ;\n                ctx.lineWidth = isMobile ? 1.6 : 2.2;\n                ctx.shadowColor = \"rgba(173,216,230,1)\";\n                ctx.shadowBlur = 14;\n                ctx.stroke();\n                if (p === 1) arm.done = true;\n            }\n            if (!arm.done) allDone = false;\n        }\n        // Endpunkte als goldene Punkte setzen\n        for (const arm of arms){\n            if (arm.done && !(arm.sx === arm.tx && arm.sy === arm.ty)) {\n                drawGoldPoint(arm.tx, arm.ty, isMobile ? 2.6 : 3.2);\n            }\n        }\n        if (!allDone) {\n            rafId = requestAnimationFrame(drawFrame);\n        } else {\n            // finale Stabilisierung: Punkte noch einmal kräftig leuchten lassen\n            for (const p of mPoints)drawGoldPoint(p.x, p.y, isMobile ? 3 : 4);\n            console.log(\"[crystalEngine] done – M aufgebaut\");\n        }\n    }\n    // Kleiner Delay, damit der Meteor-Rahmen „steht“\n    setTimeout(()=>rafId = requestAnimationFrame(drawFrame), 80);\n    // === Helpers ==============================================================\n    function drawGoldPoint(x, y, r) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#ffd700\";\n        ctx.shadowColor = \"rgba(255,215,0,1)\";\n        ctx.shadowBlur = 18;\n        ctx.fill();\n    }\n// Option: bei Bedarf Cleanup zurückgeben\n// return () => cancelAnimationFrame(rafId)\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLCtCQUErQjtBQUMvQixtRUFBbUU7QUFDbkUsa0VBQWtFO0FBRTNELFNBQVNBLGNBQWNDLEdBQTZCO0lBQ3pELE1BQU1DLFdBQVcsNEJBQTRCQyxJQUFJLENBQUNDLFVBQVVDLFNBQVM7SUFDckUsTUFBTUMsSUFBSUwsSUFBSU0sTUFBTSxDQUFDQyxLQUFLO0lBQzFCLE1BQU1DLElBQUlSLElBQUlNLE1BQU0sQ0FBQ0csTUFBTTtJQUUzQkMsUUFBUUMsR0FBRyxDQUFDO0lBRVosOEVBQThFO0lBQzlFLDZEQUE2RDtJQUM3RCxNQUFNQyxRQUFRUCxJQUFJO0lBQ2xCLE1BQU1RLFFBQVFMLElBQUk7SUFFbEIsaURBQWlEO0lBQ2pELE1BQU1NLFFBQVFDLEtBQUtDLEdBQUcsQ0FBQyxLQUFLWCxJQUFJLE1BQW1CLHlCQUF5Qjs7SUFDNUUsTUFBTVksUUFBUUYsS0FBS0csR0FBRyxDQUFDTCxRQUFRTCxJQUFJLE1BQU1BLElBQUksTUFBTSx3QkFBd0I7O0lBRTNFLDhFQUE4RTtJQUM5RSxNQUFNVyxVQUFVO1FBQ2Q7WUFBRUMsR0FBR1I7WUFBaUJTLEdBQUdSO1FBQU07UUFDL0I7WUFBRU8sR0FBR1IsUUFBUUUsUUFBTTtZQUFNTyxHQUFHSjtRQUFNO1FBQ2xDO1lBQUVHLEdBQUdSLFFBQVFFLFFBQU07WUFBTU8sR0FBR1IsUUFBTTtRQUFLO1FBQ3ZDO1lBQUVPLEdBQUdSLFFBQVFFLFFBQU07WUFBTU8sR0FBR0o7UUFBTTtRQUNsQztZQUFFRyxHQUFHUixRQUFRRTtZQUFZTyxHQUFHUjtRQUFNO0tBQ25DO0lBR0QsOERBQThEO0lBQzlELE1BQU1TLE9BQWNILFFBQVFJLEdBQUcsQ0FBQyxDQUFDQyxHQUFHQyxJQUFPO1lBQ3pDQyxJQUFJUCxPQUFPLENBQUMsRUFBRSxDQUFDQyxDQUFDO1lBQ2hCTyxJQUFJUixPQUFPLENBQUMsRUFBRSxD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RztRQUNqQmhELElBQUl1RCxJQUFJO0lBQ1Y7QUFFQSx5Q0FBeUM7QUFDekMsMkNBQTJDO0FBQzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHM/NDZjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzXG4vLyDigJ5LcmlzdGFsbGluZSBFbnRmYWx0dW5n4oCcOiBBdXMgZGVtIEFua2VycHVua3QgdW50ZW4gbGlua3Mgd2FjaHNlblxuLy8ga3Jpc3RhbGxhcnRpZ2UgQXJtZSB6dSBkZW4gTS1QdW5rdGVuIHVuZCBzZXR6ZW4gZ29sZGVuZSBQdW5rdGUuXG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENyeXN0YWxNKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGNvbnN0IGlzTW9iaWxlID0gL01vYml8QW5kcm9pZHxpUGhvbmV8aVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgY29uc3QgdyA9IGN0eC5jYW52YXMud2lkdGhcbiAgY29uc3QgaCA9IGN0eC5jYW52YXMuaGVpZ2h0XG5cbiAgY29uc29sZS5sb2coJ1tjcnlzdGFsRW5naW5lXSBzdGFydCcpXG5cbiAgLy8gPT09IFJlc3BvbnNpdmUgR2VvbWV0cmllIGbDvHIgZWluIGhhcm1vbmlzY2hlcyBNID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBBbmtlcnB1bmt0OiB1bnRlbiBsaW5rcyAoa29ycmVzcG9uZGllcnQgbWl0IE1ldGVvci1JbXBhY3QpXG4gIGNvbnN0IGJhc2VYID0gdyAqIDAuMzBcbiAgY29uc3QgYmFzZVkgPSBoICogMC43MFxuXG4gIC8vIEdlc2FtdGJyZWl0ZSB1bmQgU3BpdHplbmjDtmhlIGRlcyBNIChhbnBhc3NiYXIpXG4gIGNvbnN0IHNwYW5YID0gTWF0aC5tYXgoMTYwLCB3ICogMC4yMikgICAgICAgICAgICAgIC8vIGhvcml6b250YWxlIFNwYW5ud2VpdGVcbiAgY29uc3QgcGVha1kgPSBNYXRoLm1pbihiYXNlWSAtIGggKiAwLjI4LCBoICogMC40MikgLy8gSMO2aGUgZGVyIG9iZXJlbiBQZWFrc1xuXG4gIC8vIDUgU2NobMO8c3NlbHB1bmt0ZSAobnVyIFB1bmt0ZSwga2VpbmUgTGluaWVuIOKAkyBLcmlzdGFsbGFybWUgw7xiZXJuZWhtZW4gV2VnZSlcbiAgY29uc3QgbVBvaW50cyA9IFtcbiAgICB7IHg6IGJhc2VYLCAgICAgICAgICAgeTogYmFzZVkgfSwgICAgICAvLyAwOiB1bnRlbiBsaW5rcyAoQW5rZXIpXG4gICAgeyB4OiBiYXNlWCArIHNwYW5YKjAuMjUsIHk6IHBlYWtZIH0sICAgLy8gMTogbGlua2VyIFBlYWtcbiAgICB7IHg6IGJhc2VYICsgc3BhblgqMC41MCwgeTogYmFzZVkqMC45MyB9LCAvLyAyOiBtaXR0bGVyZXMgVGFsIGxlaWNodCBvYmVyaGFsYiBCYXNlbGluZVxuICAgIHsgeDogYmFzZVggKyBzcGFuWCowLjc1LCB5OiBwZWFrWSB9LCAgIC8vIDM6IHJlY2h0ZXIgUGVha1xuICAgIHsgeDogYmFzZVggKyBzcGFuWCwgICAgICB5OiBiYXNlWSB9LCAgIC8vIDQ6IHVudGVuIHJlY2h0c1xuICBdXG5cbiAgdHlwZSBBcm0gPSB7IHN4OiBudW1iZXI7IHN5OiBudW1iZXI7IHR4OiBudW1iZXI7IHR5OiBudW1iZXI7IHQ6IG51bWJlcjsgZG9uZTogYm9vbGVhbiB9XG4gIC8vIFZvbiBQdW5rdCAwIChBbmtlcikgenUgYWxsZW4gYW5kZXJlbiBQdW5rdGVuIHdhY2hzZW4gbGFzc2VuXG4gIGNvbnN0IGFybXM6IEFybVtdID0gbVBvaW50cy5tYXAoKHAsIGkpID0+ICh7XG4gICAgc3g6IG1Qb2ludHNbMF0ueCxcbiAgICBzeTogbVBvaW50c1swXS55LFxuICAgIHR4OiBwLngsXG4gICAgdHk6IHAueSxcbiAgICB0OiBpID09PSAwID8gOTk5OSA6IDAsIC8vIEFybSAwIGV4aXN0aWVydCBuaWNodCAoQW5rZXItPkFua2VyKSwgbWFya2llcmVuIGFscyDigJ5mZXJ0aWfigJxcbiAgICBkb25lOiBpID09PSAwXG4gIH0pKVxuXG4gIC8vID09PSBTb2ZvcnQgc2ljaHRiYXJlciBBbmtlcnB1bmt0ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGRyYXdHb2xkUG9pbnQobVBvaW50c1swXS54LCBtUG9pbnRzWzBdLnksIGlzTW9iaWxlID8gMyA6IDQpXG5cbiAgY29uc3QgbWF4UHJvZ3Jlc3MgPSBpc01vYmlsZSA/IDMwIDogNDIgLy8gRnJhbWVzIHBybyBBcm1cbiAgbGV0IHJhZklkID0gMFxuXG4gIGZ1bmN0aW9uIGRyYXdGcmFtZSgpIHtcbiAgICAvLyBXZWljaGVzIENsZWFyIGbDvHIgTmFjaGxldWNodGVuIChLcmlzdGFsbC1UcmFpbClcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC4yMiknXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpXG5cbiAgICAvLyBBbmtlcnB1bmt0IGVybmV1dCByZW5kZXJuLCBkYW1pdCBlciBuaWUg4oCedmVyc2Nod2luZGV04oCcXG4gICAgZHJhd0dvbGRQb2ludChtUG9pbnRzWzBdLngsIG1Qb2ludHNbMF0ueSwgaXNNb2JpbGUgPyAzIDogNClcblxuICAgIGxldCBhbGxEb25lID0gdHJ1ZVxuXG4gICAgZm9yIChjb25zdCBhcm0gb2YgYXJtcykge1xuICAgICAgaWYgKCFhcm0uZG9uZSkge1xuICAgICAgICBhcm0udCsrXG4gICAgICAgIGNvbnN0IHAgPSBNYXRoLm1pbihhcm0udCAvIG1heFByb2dyZXNzLCAxKVxuICAgICAgICBjb25zdCBueCA9IGFybS5zeCArIChhcm0udHggLSBhcm0uc3gpICogcFxuICAgICAgICBjb25zdCBueSA9IGFybS5zeSArIChhcm0udHkgLSBhcm0uc3kpICogcFxuXG4gICAgICAgIC8vIEtyaXN0YWxsYXJtIHplaWNobmVuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHgubW92ZVRvKGFybS5zeCwgYXJtLnN5KVxuICAgICAgICBjdHgubGluZVRvKG54LCBueSlcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMTczLDIxNiwyMzAsMC45NSknIC8vIGhlbGwta3Jpc3RhbGxibGF1XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBpc01vYmlsZSA/IDEuNiA6IDIuMlxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgxNzMsMjE2LDIzMCwxKSdcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxNFxuICAgICAgICBjdHguc3Ryb2tlKClcblxuICAgICAgICBpZiAocCA9PT0gMSkgYXJtLmRvbmUgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWFybS5kb25lKSBhbGxEb25lID0gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBFbmRwdW5rdGUgYWxzIGdvbGRlbmUgUHVua3RlIHNldHplblxuICAgIGZvciAoY29uc3QgYXJtIG9mIGFybXMpIHtcbiAgICAgIGlmIChhcm0uZG9uZSAmJiAhKGFybS5zeCA9PT0gYXJtLnR4ICYmIGFybS5zeSA9PT0gYXJtLnR5KSkge1xuICAgICAgICBkcmF3R29sZFBvaW50KGFybS50eCwgYXJtLnR5LCBpc01vYmlsZSA/IDIuNiA6IDMuMilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFsbERvbmUpIHtcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdGcmFtZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluYWxlIFN0YWJpbGlzaWVydW5nOiBQdW5rdGUgbm9jaCBlaW5tYWwga3LDpGZ0aWcgbGV1Y2h0ZW4gbGFzc2VuXG4gICAgICBmb3IgKGNvbnN0IHAgb2YgbVBvaW50cykgZHJhd0dvbGRQb2ludChwLngsIHAueSwgaXNNb2JpbGUgPyAzIDogNClcbiAgICAgIGNvbnNvbGUubG9nKCdbY3J5c3RhbEVuZ2luZV0gZG9uZSDigJMgTSBhdWZnZWJhdXQnKVxuICAgIH1cbiAgfVxuXG4gIC8vIEtsZWluZXIgRGVsYXksIGRhbWl0IGRlciBNZXRlb3ItUmFobWVuIOKAnnN0ZWh04oCcXG4gIHNldFRpbWVvdXQoKCkgPT4gKHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdGcmFtZSkpLCA4MClcblxuICAvLyA9PT0gSGVscGVycyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBkcmF3R29sZFBvaW50KHg6IG51bWJlciwgeTogbnVtYmVyLCByOiBudW1iZXIpIHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKVxuICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZDcwMCdcbiAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgyNTUsMjE1LDAsMSknXG4gICAgY3R4LnNoYWRvd0JsdXIgPSAxOFxuICAgIGN0eC5maWxsKClcbiAgfVxuXG4gIC8vIE9wdGlvbjogYmVpIEJlZGFyZiBDbGVhbnVwIHp1csO8Y2tnZWJlblxuICAvLyByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpXG59XG4iXSwibmFtZXMiOlsiYnVpbGRDcnlzdGFsTSIsImN0eCIsImlzTW9iaWxlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInciLCJjYW52YXMiLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJjb25zb2xlIiwibG9nIiwiYmFzZVgiLCJiYXNlWSIsInNwYW5YIiwiTWF0aCIsIm1heCIsInBlYWtZIiwibWluIiwibVBvaW50cyIsIngiLCJ5IiwiYXJtcyIsIm1hcCIsInAiLCJpIiwic3giLCJzeSIsInR4IiwidHkiLCJ0IiwiZG9uZSIsImRyYXdHb2xkUG9pbnQiLCJtYXhQcm9ncmVzcyIsInJhZklkIiwiZHJhd0ZyYW1lIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJhbGxEb25lIiwiYXJtIiwibngiLCJueSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwic3Ryb2tlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsInIiLCJhcmMiLCJQSSIsImZpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});