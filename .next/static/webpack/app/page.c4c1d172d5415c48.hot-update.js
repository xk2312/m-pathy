"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n/**\n * Dotted-M, majestätisch:\n * - Vertikale Außen-Säulen (x links/rechts exakt vertikal)\n * - Sehr hohe Punktdichte + doppelte Breite, aber mit klaren Abständen\n * - Sequenzieller Aufbau P0→P1→P2→P3→P4 in ~5 s (FPS-unabhängig)\n * - Elektrisches Blau mit Glow\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    // Canvas in CSS-Pixeln\n    const rect = ctx.canvas.getBoundingClientRect();\n    const w = rect.width, h = rect.height;\n    // Proportionen: breiter & höher für \"erhaben\"\n    const baseY = h * 0.74; // Baseline etwas tiefer\n    const topY = h * 0.36; // Spitzenhöhe\n    const leftX = w * 0.28;\n    const rightX = w * 0.28 + Math.max(360, w * 0.32); // kräftige Spannweite\n    const midX = (leftX + rightX) / 2;\n    const valleyY = baseY - Math.max(90, h * 0.14); // Tal etwas über Baseline\n    // Kontrollpunkte mit VERTIKALEN Außenkanten\n    const P = [\n        {\n            x: leftX,\n            y: baseY\n        },\n        {\n            x: leftX,\n            y: topY\n        },\n        {\n            x: midX,\n            y: valleyY\n        },\n        {\n            x: rightX,\n            y: topY\n        },\n        {\n            x: rightX,\n            y: baseY\n        }\n    ];\n    const segments = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ];\n    // ---- Look & Abstandskontrolle (doppelt so dicht & breit) -----------------\n    const dotRadius = isMobile ? 1.3 : 1.6; // Punktgröße\n    const minGap = isMobile ? 1.8 : 2.2; // Mindestabstand zwischen Punkten\n    const alongGap = Math.max(isMobile ? 2.4 : 2.0, dotRadius * 2 + (minGap - 0.6));\n    const acrossGap = Math.max(isMobile ? 4.8 : 4.2, dotRadius * 2 + minGap);\n    const targetWidth = isMobile ? 28 : 56; // doppelte optische Dicke\n    const maxRows = Math.max(1, Math.floor(targetWidth / acrossGap));\n    const durationSec = 5;\n    const dots = [];\n    let pathOffset = 0;\n    for (const { a, b } of segments){\n        const dx = b.x - a.x, dy = b.y - a.y;\n        const len = Math.hypot(dx, dy);\n        if (len <= 0) continue;\n        const tx = dx / len, ty = dy / len; // Tangente\n        const nx = ty, ny = -tx; // Normale (links)\n        const rows = Math.max(1, maxRows);\n        const half = (rows - 1) / 2;\n        const steps = Math.max(2, Math.floor(len / alongGap));\n        for(let r = 0; r < rows; r++){\n            const offset = (r - half) * acrossGap;\n            const stagger = r % 2 * (alongGap * 0.5); // Rastergefühl\n            for(let i = 0; i <= steps; i++){\n                const d = i * alongGap + stagger;\n                if (d > len) continue;\n                const x = a.x + tx * d + nx * offset;\n                const y = a.y + ty * d + ny * offset;\n                dots.push({\n                    x,\n                    y,\n                    s: pathOffset + d\n                });\n            }\n        }\n        pathOffset += len;\n    }\n    // Strikt entlang der Struktur (links → rechts)\n    dots.sort((p, q)=>p.s - q.s);\n    // Zeitgesteuerter Aufbau (~5 s), FPS-unabhängig\n    const total = dots.length;\n    const start = performance.now();\n    let drawn = 0;\n    // Erster Punkt = Meteor-Anchor (blau)\n    drawDot(anchor.x, anchor.y, dotRadius + 0.9);\n    function tick(now) {\n        const t = Math.min((now - start) / 1000 / durationSec, 1);\n        const target = Math.floor(t * total);\n        for(; drawn < target && drawn < total; drawn++){\n            const p = dots[drawn];\n            drawDot(p.x, p.y, dotRadius);\n        }\n        if (drawn < total) requestAnimationFrame(tick);\n    }\n    requestAnimationFrame(tick);\n    function drawDot(x, y, r) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        // Elektrisches Blau\n        ctx.fillStyle = \"#6BD5FF\";\n        ctx.shadowColor = \"rgba(107, 213, 255, 0.55)\"; // weicher blauer Glow\n        ctx.shadowBlur = 4;\n        ctx.fill();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLCtCQUErQjtBQUcvQjs7Ozs7O0NBTUMsR0FDTSxTQUFTQSxjQUFjQyxHQUE2QixFQUFFQyxNQUFVO0lBQ3JFLE1BQU1DLFdBQVcsNEJBQTRCQyxJQUFJLENBQUNDLFVBQVVDLFNBQVM7SUFFckUsdUJBQXVCO0lBQ3ZCLE1BQU1DLE9BQU9OLElBQUlPLE1BQU0sQ0FBQ0MscUJBQXFCO0lBQzdDLE1BQU1DLElBQUlILEtBQUtJLEtBQUssRUFBRUMsSUFBSUwsS0FBS00sTUFBTTtJQUVyQyw4Q0FBOEM7SUFDOUMsTUFBTUMsUUFBUUYsSUFBSSxNQUFzQix3QkFBd0I7SUFDaEUsTUFBTUcsT0FBUUgsSUFBSSxNQUFzQixjQUFjO0lBQ3RELE1BQU1JLFFBQVFOLElBQUk7SUFDbEIsTUFBTU8sU0FBU1AsSUFBSSxPQUFPUSxLQUFLQyxHQUFHLENBQUMsS0FBS1QsSUFBSSxPQUFPLHNCQUFzQjtJQUN6RSxNQUFNVSxPQUFRLENBQUNKLFFBQVFDLE1BQUssSUFBSztJQUNqQyxNQUFNSSxVQUFVUCxRQUFRSSxLQUFLQyxHQUFHLENBQUMsSUFBSVAsSUFBSSxPQUFVLDBCQUEwQjtJQUU3RSw0Q0FBNEM7SUFDNUMsTUFBTVUsSUFBSTtRQUNSO1lBQUVDLEdBQUdQO1lBQVFRLEdBQUdWO1FBQU07UUFDdEI7WUFBRVMsR0FBR1A7WUFBUVEsR0FBR1Q7UUFBTTtRQUN0QjtZQUFFUSxHQUFHSDtZQUFRSSxHQUFHSDtRQUFRO1FBQ3hCO1lBQUVFLEdBQUdOO1lBQVFPLEdBQUdUO1FBQU07UUFDdEI7WUFBRVEsR0FBR047WUFBUU8sR0FBR1Y7UUFBTTtLQUN2QjtJQUVELE1BQU1XLFdBQVc7UUFDZjtZQUFFQyxHQUFHSixDQUFDLENBQUMsRUFBRTtZQUFFSyxHQUFHTCxDQUFDLENBQUMsRUFBRTtRQUFDO1FBQ25CO1lBQUVJLEdBQUdKLENBQUMsQ0FBQyxF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YUFBYTtRQUN2RCxNQUFNa0MsU0FBU25ELEtBQUtnQixLQUFLLENBQUNpQyxJQUFJUjtRQUM5QixNQUFPSyxRQUFRSyxVQUFVTCxRQUFRTCxPQUFPSyxRQUFTO1lBQy9DLE1BQU1QLElBQUlyQixJQUFJLENBQUM0QixNQUFNO1lBQ3JCQyxRQUFRUixFQUFFbEMsQ0FBQyxFQUFFa0MsRUFBRWpDLENBQUMsRUFBRUk7UUFDcEI7UUFDQSxJQUFJb0MsUUFBUUwsT0FBT1csc0JBQXNCSjtJQUMzQztJQUNBSSxzQkFBc0JKO0lBRXRCLFNBQVNELFFBQVExQyxDQUFTLEVBQUVDLENBQVMsRUFBRXlCLENBQVM7UUFDOUNoRCxJQUFJc0UsU0FBUztRQUNidEUsSUFBSXVFLEdBQUcsQ0FBQ2pELEdBQUdDLEdBQUd5QixHQUFHLEdBQUcvQixLQUFLdUQsRUFBRSxHQUFHO1FBQzlCLG9CQUFvQjtRQUNwQnhFLElBQUl5RSxTQUFTLEdBQUc7UUFDaEJ6RSxJQUFJMEUsV0FBVyxHQUFHLDZCQUE2QixzQkFBc0I7UUFDckUxRSxJQUFJMkUsVUFBVSxHQUFHO1FBQ2pCM0UsSUFBSTRFLElBQUk7SUFDVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHM/NDZjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzXG50eXBlIFhZID0geyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuXG4vKipcbiAqIERvdHRlZC1NLCBtYWplc3TDpHRpc2NoOlxuICogLSBWZXJ0aWthbGUgQXXDn2VuLVPDpHVsZW4gKHggbGlua3MvcmVjaHRzIGV4YWt0IHZlcnRpa2FsKVxuICogLSBTZWhyIGhvaGUgUHVua3RkaWNodGUgKyBkb3BwZWx0ZSBCcmVpdGUsIGFiZXIgbWl0IGtsYXJlbiBBYnN0w6RuZGVuXG4gKiAtIFNlcXVlbnppZWxsZXIgQXVmYmF1IFAw4oaSUDHihpJQMuKGklAz4oaSUDQgaW4gfjUgcyAoRlBTLXVuYWJow6RuZ2lnKVxuICogLSBFbGVrdHJpc2NoZXMgQmxhdSBtaXQgR2xvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRDcnlzdGFsTShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYW5jaG9yOiBYWSkge1xuICBjb25zdCBpc01vYmlsZSA9IC9Nb2JpfEFuZHJvaWR8aVBob25lfGlQYWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIC8vIENhbnZhcyBpbiBDU1MtUGl4ZWxuXG4gIGNvbnN0IHJlY3QgPSBjdHguY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB3ID0gcmVjdC53aWR0aCwgaCA9IHJlY3QuaGVpZ2h0O1xuXG4gIC8vIFByb3BvcnRpb25lbjogYnJlaXRlciAmIGjDtmhlciBmw7xyIFwiZXJoYWJlblwiXG4gIGNvbnN0IGJhc2VZID0gaCAqIDAuNzQ7ICAgICAgICAgICAgICAgICAvLyBCYXNlbGluZSBldHdhcyB0aWVmZXJcbiAgY29uc3QgdG9wWSAgPSBoICogMC4zNjsgICAgICAgICAgICAgICAgIC8vIFNwaXR6ZW5ow7ZoZVxuICBjb25zdCBsZWZ0WCA9IHcgKiAwLjI4O1xuICBjb25zdCByaWdodFggPSB3ICogMC4yOCArIE1hdGgubWF4KDM2MCwgdyAqIDAuMzIpOyAvLyBrcsOkZnRpZ2UgU3Bhbm53ZWl0ZVxuICBjb25zdCBtaWRYICA9IChsZWZ0WCArIHJpZ2h0WCkgLyAyO1xuICBjb25zdCB2YWxsZXlZID0gYmFzZVkgLSBNYXRoLm1heCg5MCwgaCAqIDAuMTQpOyAgICAvLyBUYWwgZXR3YXMgw7xiZXIgQmFzZWxpbmVcblxuICAvLyBLb250cm9sbHB1bmt0ZSBtaXQgVkVSVElLQUxFTiBBdcOfZW5rYW50ZW5cbiAgY29uc3QgUCA9IFtcbiAgICB7IHg6IGxlZnRYLCAgeTogYmFzZVkgfSwgLy8gMCB1bnRlbiBsaW5rcyAoQW5jaG9yKVxuICAgIHsgeDogbGVmdFgsICB5OiB0b3BZICB9LCAvLyAxIG9iZW4gbGlua3MgKHZlcnRpa2FsKVxuICAgIHsgeDogbWlkWCwgICB5OiB2YWxsZXlZIH0sLy8gMiBUYWxcbiAgICB7IHg6IHJpZ2h0WCwgeTogdG9wWSAgfSwgLy8gMyBvYmVuIHJlY2h0cyAodmVydGlrYWwpXG4gICAgeyB4OiByaWdodFgsIHk6IGJhc2VZIH0sIC8vIDQgdW50ZW4gcmVjaHRzXG4gIF0gYXMgY29uc3Q7XG5cbiAgY29uc3Qgc2VnbWVudHMgPSBbXG4gICAgeyBhOiBQWzBdLCBiOiBQWzFdIH0sIC8vIHZlcnRpa2FsIGhvY2hcbiAgICB7IGE6IFBbMV0sIGI6IFBbMl0gfSwgLy8gZGlhZyBydW50ZXJcbiAgICB7IGE6IFBbMl0sIGI6IFBbM10gfSwgLy8gZGlhZyBob2NoXG4gICAgeyBhOiBQWzNdLCBiOiBQWzRdIH0sIC8vIHZlcnRpa2FsIHJ1bnRlclxuICBdO1xuXG4gIC8vIC0tLS0gTG9vayAmIEFic3RhbmRza29udHJvbGxlIChkb3BwZWx0IHNvIGRpY2h0ICYgYnJlaXQpIC0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbnN0IGRvdFJhZGl1cyAgID0gaXNNb2JpbGUgPyAxLjMgOiAxLjY7ICAgLy8gUHVua3RncsO2w59lXG4gIGNvbnN0IG1pbkdhcCAgICAgID0gaXNNb2JpbGUgPyAxLjggOiAyLjI7ICAgLy8gTWluZGVzdGFic3RhbmQgendpc2NoZW4gUHVua3RlblxuICBjb25zdCBhbG9uZ0dhcCAgICA9IE1hdGgubWF4KGlzTW9iaWxlID8gMi40IDogMi4wLCBkb3RSYWRpdXMgKiAyICsgKG1pbkdhcCAtIDAuNikpO1xuICBjb25zdCBhY3Jvc3NHYXAgICA9IE1hdGgubWF4KGlzTW9iaWxlID8gNC44IDogNC4yLCBkb3RSYWRpdXMgKiAyICsgbWluR2FwKTtcbiAgY29uc3QgdGFyZ2V0V2lkdGggPSAoaXNNb2JpbGUgPyAyOCA6IDU2KTsgICAvLyBkb3BwZWx0ZSBvcHRpc2NoZSBEaWNrZVxuICBjb25zdCBtYXhSb3dzICAgICA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGFyZ2V0V2lkdGggLyBhY3Jvc3NHYXApKTtcbiAgY29uc3QgZHVyYXRpb25TZWMgPSA1O1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFB1bmt0ZSBlcnpldWdlbiAobWl0IGdhcmFudGllcnRlbSBBYnN0YW5kKVxuICB0eXBlIERvdCA9IFhZICYgeyBzOiBudW1iZXIgfTtcbiAgY29uc3QgZG90czogRG90W10gPSBbXTtcbiAgbGV0IHBhdGhPZmZzZXQgPSAwO1xuXG4gIGZvciAoY29uc3QgeyBhLCBiIH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnk7XG4gICAgY29uc3QgbGVuID0gTWF0aC5oeXBvdChkeCwgZHkpO1xuICAgIGlmIChsZW4gPD0gMCkgY29udGludWU7XG5cbiAgICBjb25zdCB0eCA9IGR4IC8gbGVuLCB0eSA9IGR5IC8gbGVuOyAvLyBUYW5nZW50ZVxuICAgIGNvbnN0IG54ID0gIHR5LCAgICAgICBueSA9IC10eDsgICAgIC8vIE5vcm1hbGUgKGxpbmtzKVxuXG4gICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIG1heFJvd3MpO1xuICAgIGNvbnN0IGhhbGYgPSAocm93cyAtIDEpIC8gMjtcbiAgICBjb25zdCBzdGVwcyA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IobGVuIC8gYWxvbmdHYXApKTtcblxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAociAtIGhhbGYpICogYWNyb3NzR2FwO1xuICAgICAgY29uc3Qgc3RhZ2dlciA9IChyICUgMikgKiAoYWxvbmdHYXAgKiAwLjUpOyAvLyBSYXN0ZXJnZWbDvGhsXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGkgKiBhbG9uZ0dhcCArIHN0YWdnZXI7XG4gICAgICAgIGlmIChkID4gbGVuKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgeCA9IGEueCArIHR4ICogZCArIG54ICogb2Zmc2V0O1xuICAgICAgICBjb25zdCB5ID0gYS55ICsgdHkgKiBkICsgbnkgKiBvZmZzZXQ7XG4gICAgICAgIGRvdHMucHVzaCh7IHgsIHksIHM6IHBhdGhPZmZzZXQgKyBkIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoT2Zmc2V0ICs9IGxlbjtcbiAgfVxuXG4gIC8vIFN0cmlrdCBlbnRsYW5nIGRlciBTdHJ1a3R1ciAobGlua3Mg4oaSIHJlY2h0cylcbiAgZG90cy5zb3J0KChwLCBxKSA9PiBwLnMgLSBxLnMpO1xuXG4gIC8vIFplaXRnZXN0ZXVlcnRlciBBdWZiYXUgKH41IHMpLCBGUFMtdW5hYmjDpG5naWdcbiAgY29uc3QgdG90YWwgPSBkb3RzLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgbGV0IGRyYXduID0gMDtcblxuICAvLyBFcnN0ZXIgUHVua3QgPSBNZXRlb3ItQW5jaG9yIChibGF1KVxuICBkcmF3RG90KGFuY2hvci54LCBhbmNob3IueSwgZG90UmFkaXVzICsgMC45KTtcblxuICBmdW5jdGlvbiB0aWNrKG5vdzogbnVtYmVyKSB7XG4gICAgY29uc3QgdCA9IE1hdGgubWluKChub3cgLSBzdGFydCkgLyAxMDAwIC8gZHVyYXRpb25TZWMsIDEpO1xuICAgIGNvbnN0IHRhcmdldCA9IE1hdGguZmxvb3IodCAqIHRvdGFsKTtcbiAgICBmb3IgKDsgZHJhd24gPCB0YXJnZXQgJiYgZHJhd24gPCB0b3RhbDsgZHJhd24rKykge1xuICAgICAgY29uc3QgcCA9IGRvdHNbZHJhd25dO1xuICAgICAgZHJhd0RvdChwLngsIHAueSwgZG90UmFkaXVzKTtcbiAgICB9XG4gICAgaWYgKGRyYXduIDwgdG90YWwpIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgfVxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG5cbiAgZnVuY3Rpb24gZHJhd0RvdCh4OiBudW1iZXIsIHk6IG51bWJlciwgcjogbnVtYmVyKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpO1xuICAgIC8vIEVsZWt0cmlzY2hlcyBCbGF1XG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjNkJENUZGJztcbiAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgxMDcsIDIxMywgMjU1LCAwLjU1KSc7IC8vIHdlaWNoZXIgYmxhdWVyIEdsb3dcbiAgICBjdHguc2hhZG93Qmx1ciA9IDQ7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImJ1aWxkQ3J5c3RhbE0iLCJjdHgiLCJhbmNob3IiLCJpc01vYmlsZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJyZWN0IiwiY2FudmFzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsImJhc2VZIiwidG9wWSIsImxlZnRYIiwicmlnaHRYIiwiTWF0aCIsIm1heCIsIm1pZFgiLCJ2YWxsZXlZIiwiUCIsIngiLCJ5Iiwic2VnbWVudHMiLCJhIiwiYiIsImRvdFJhZGl1cyIsIm1pbkdhcCIsImFsb25nR2FwIiwiYWNyb3NzR2FwIiwidGFyZ2V0V2lkdGgiLCJtYXhSb3dzIiwiZmxvb3IiLCJkdXJhdGlvblNlYyIsImRvdHMiLCJwYXRoT2Zmc2V0IiwiZHgiLCJkeSIsImxlbiIsImh5cG90IiwidHgiLCJ0eSIsIm54IiwibnkiLCJyb3dzIiwiaGFsZiIsInN0ZXBzIiwiciIsIm9mZnNldCIsInN0YWdnZXIiLCJpIiwiZCIsInB1c2giLCJzIiwic29ydCIsInAiLCJxIiwidG90YWwiLCJsZW5ndGgiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwibm93IiwiZHJhd24iLCJkcmF3RG90IiwidGljayIsInQiLCJtaW4iLCJ0YXJnZXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGxTdHlsZSIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsImZpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});