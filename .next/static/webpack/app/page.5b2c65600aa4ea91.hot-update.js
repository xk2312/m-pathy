"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; },\n/* harmony export */   computeMAnchor: function() { return /* binding */ computeMAnchor; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n/** Liefert den exakten Anchor (linker unterer M-Punkt) für gegebene Maße */ function computeMAnchor(w, h) {\n    const leftX = w * 0.28;\n    const baseY = h * 0.74;\n    return {\n        x: leftX,\n        y: baseY\n    };\n}\n/**\n * Dotted-M, majestätisch & blau:\n * - Vertikale Säulen, diagonale Schenkel\n * - Caps füllen Ecken (oben, Tal, unten)\n * - Sequenzieller Aufbau P0→P1→P2→P3→P4 (~5s)\n * - Hohe Dichte + doppelte Breite, aber mit klaren Abständen\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    const rect = ctx.canvas.getBoundingClientRect();\n    const w = rect.width, h = rect.height;\n    // Proportionen (erhaben)\n    const baseY = h * 0.74;\n    const topY = h * 0.36;\n    const leftX = w * 0.28;\n    const rightX = w * 0.28 + Math.max(360, w * 0.32);\n    const midX = (leftX + rightX) / 2;\n    const valleyY = baseY - Math.max(90, h * 0.14);\n    const P = [\n        {\n            x: leftX,\n            y: baseY\n        },\n        {\n            x: leftX,\n            y: topY\n        },\n        {\n            x: midX,\n            y: valleyY\n        },\n        {\n            x: rightX,\n            y: topY\n        },\n        {\n            x: rightX,\n            y: baseY\n        }\n    ];\n    const segments = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ];\n    // Look & Abstände\n    const dotRadius = isMobile ? 1.3 : 1.6;\n    const minGap = isMobile ? 1.8 : 2.2;\n    const alongGap = Math.max(isMobile ? 2.4 : 2.0, dotRadius * 2 + (minGap - 0.6));\n    const acrossGap = Math.max(isMobile ? 4.8 : 4.2, dotRadius * 2 + minGap);\n    const targetWidth = isMobile ? 28 : 56;\n    const maxRows = Math.max(1, Math.floor(targetWidth / acrossGap));\n    const durationSec = 5;\n    const dots = [];\n    let pathOffset = 0;\n    // Linienpunkte\n    for (const { a, b } of segments){\n        const dx = b.x - a.x, dy = b.y - a.y;\n        const len = Math.hypot(dx, dy);\n        if (len <= 0) continue;\n        const tx = dx / len, ty = dy / len;\n        const nx = ty, ny = -tx;\n        const rows = Math.max(1, maxRows);\n        const half = (rows - 1) / 2;\n        const steps = Math.max(2, Math.floor(len / alongGap));\n        for(let r = 0; r < rows; r++){\n            const offset = (r - half) * acrossGap;\n            const stagger = r % 2 * (alongGap * 0.5);\n            for(let i = 0; i <= steps; i++){\n                const d = i * alongGap + stagger;\n                if (d > len) continue;\n                const x = a.x + tx * d + nx * offset;\n                const y = a.y + ty * d + ny * offset;\n                dots.push({\n                    x,\n                    y,\n                    s: pathOffset + d\n                });\n            }\n        }\n        pathOffset += len;\n    }\n    // Caps an Ecken (oben links/rechts, Tal) + Endkappen unten\n    const capRadius = (maxRows - 1) * acrossGap * 0.55 + dotRadius;\n    addCap(P[1], capRadius);\n    addCap(P[2], capRadius);\n    addCap(P[3], capRadius);\n    addCap(P[0], capRadius * 0.85);\n    addCap(P[4], capRadius * 0.85);\n    function addCap(center, radius) {\n        const step = Math.max(dotRadius * 2 + minGap, acrossGap * 0.9);\n        const rings = Math.max(1, Math.floor(radius / step));\n        for(let r = 0; r <= rings; r++){\n            const rad = r * step;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const n = Math.max(6, Math.floor(circ / step));\n            for(let i = 0; i < n; i++){\n                const a = i / n * Math.PI * 2;\n                const x = center.x + Math.cos(a) * rad;\n                const y = center.y + Math.sin(a) * rad;\n                // s = Position entlang Pfad nahe der Ecke -> mit kleiner Verschiebung\n                dots.push({\n                    x,\n                    y,\n                    s: pathOffset + r * 0.001 + i * 0.0001\n                });\n            }\n        }\n    }\n    // Strikt entlang der Struktur (links -> rechts)\n    dots.sort((p, q)=>p.s - q.s);\n    // Zeitgesteuerter Aufbau (~5 s)\n    const total = dots.length;\n    const start = performance.now();\n    let drawn = 0;\n    // Erster Punkt (Meteor/Anchor) blau\n    drawDot(anchor.x, anchor.y, dotRadius + 0.9);\n    function tick(now) {\n        const t = Math.min((now - start) / 1000 / durationSec, 1);\n        const target = Math.floor(t * total);\n        for(; drawn < target && drawn < total; drawn++){\n            const p = dots[drawn];\n            drawDot(p.x, p.y, dotRadius);\n        }\n        if (drawn < total) requestAnimationFrame(tick);\n    }\n    requestAnimationFrame(tick);\n    function drawDot(x, y, r) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#6BD5FF\";\n        ctx.shadowColor = \"rgba(107, 213, 255, 0.55)\";\n        ctx.shadowBlur = 4;\n        ctx.fill();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQkFBK0I7QUFHL0IsMEVBQTBFLEdBQ25FLFNBQVNBLGVBQWVDLENBQVMsRUFBRUMsQ0FBUztJQUNqRCxNQUFNQyxRQUFRRixJQUFJO0lBQ2xCLE1BQU1HLFFBQVFGLElBQUk7SUFDbEIsT0FBTztRQUFFRyxHQUFHRjtRQUFPRyxHQUFHRjtJQUFNO0FBQzlCO0FBRUE7Ozs7OztDQU1DLEdBQ00sU0FBU0csY0FBY0MsR0FBNkIsRUFBRUMsTUFBVTtJQUNyRSxNQUFNQyxXQUFXLDRCQUE0QkMsSUFBSSxDQUFDQyxVQUFVQyxTQUFTO0lBRXJFLE1BQU1DLE9BQU9OLElBQUlPLE1BQU0sQ0FBQ0MscUJBQXFCO0lBQzdDLE1BQU1mLElBQUlhLEtBQUtHLEtBQUssRUFBRWYsSUFBSVksS0FBS0ksTUFBTTtJQUVyQyx5QkFBeUI7SUFDekIsTUFBTWQsUUFBUUYsSUFBSTtJQUNsQixNQUFNaUIsT0FBUWpCLElBQUk7SUFDbEIsTUFBTUMsUUFBUUYsSUFBSTtJQUNsQixNQUFNbUIsU0FBU25CLElBQUksT0FBT29CLEtBQUtDLEdBQUcsQ0FBQyxLQUFLckIsSUFBSTtJQUM1QyxNQUFNc0IsT0FBUSxDQUFDcEIsUUFBUWlCLE1BQUssSUFBSztJQUNqQyxNQUFNSSxVQUFVcEIsUUFBUWlCLEtBQUtDLEdBQUcsQ0FBQyxJQUFJcEIsSUFBSTtJQUV6QyxNQUFNdUIsSUFBSTtRQUNSO1lBQUVwQixHQUFHRjtZQUFRRyxHQUFHRjtRQUFNO1FBQ3RCO1lBQUVDLEdBQUdGO1lBQVFHLEdBQUdhO1FBQUs7UUFDckI7WUFBRWQsR0FBR2tCO1lBQVFqQixHQUFHa0I7UUFBUTtRQUN4QjtZQUFFbkIsR0FBR2U7WUFBUWQsR0FBR2E7UUFBSztRQUNyQjtZQUFFZCxHQUFHZTtZQUFRZCxHQUFHRjtRQUFNO0tBQ3ZCO0lBRUQsTUFBTXNCLFdBQVc7UUFDZjtZQUFFQyxHQUFHRixDQUFDLENBQUMsRUFBRTtZQUFFRyxHQUFHSCxDQUFDLENBQUMsRUFBRTtRQUFDO1FBQ25CO1lBQUVFLEdBQUdGLENBQUMsQ0FBQyxFQUFFO1lBQUVHLEdBQUdILENBQUMsQ0FBQyxFQUFFO1FBQUM7UUFDbkI7WUFBRUUsR0FBR0YsQ0FBQyxDQUFDLEVBQUU7WUFBRUcsR0FBR0gsQ0FBQyxDQUFDLEVBQUU7UUFBQztRQUNuQjtZQUFFRSxHQUFHRixDQUFDLENBQUMsRUFBRTtZQUFFRyxHQUFHSCxDQUFDLENBQUMsRUFBRTtRQUFDO0tBQ3BCO0lBRUQsa0JBQWtCO0lBQ2xCLE1BQU1JLFlBQWNuQixXQUFXLE1BQU07SUFDckMsTUFBTW9CLFNBQWNwQixXQUFXLE1BQU07SUFDckMsTUFBTXFCLFdBQWNWLEtBQUtDLEdBQUcsQ0FBQ1osV0FBVyxNQUFNLEtBQUttQixZQUFZLElBQUtDLENBQUFBLFNBQVMsR0FBRTtJQUMvRSxNQUFNRSxZQUFjWCxLQUFLQyxHQUFHLENBQUNaLFdBQVcsTUFBTSxLQUFLbUIsWUFBWSxJQUFJQztJQUNuRSxNQUFNRyxjQUFldkIsV0FBVyxLQUFLO0lBQ3JDLE1BQU13QixVQUFjYixLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS2MsS0FBSyxDQUFDRixjQUFjRDtJQUN6RCxNQUFNSSxjQUFjO0lBR3BCLE1BQU1DLE9BQWMsRUFBRTtJQUN0QixJQUFJQyxhQUFhO0lBRWpCLGVBQWU7SUFDZixLQUFLLE1BQU0sRUFBRVgsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsSUFBSUYsU0FBVTtRQUMvQixNQUFNYSxLQUFLWCxFQUFFdkIsQ0FBQyxHQUFHc0IsRUFBRXRCLENBQUMsRUFBRW1DLEtBQUtaLEVBQUV0QixDQUFDLEdBQUdxQixFQUFFckIsQ0FBQztRQUNwQyxNQUFNbUMsTUFBTXBCLEtBQUtxQixLQUFLLENBQUNILElBQUlDO1FBQUssSUFBSUMsT0FBTyxHQUFHO1FBQzlDLE1BQU1FLEtBQUtKLEtBQUtFLEtBQUtHLEtBQUtKLEtBQUtDO1FBQy9CLE1BQU1JLEtBQU1ELElBQVVFLEtBQUssQ0FBQ0g7UUFDNUIsTUFBTUksT0FBTzFCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHWTtRQUN6QixNQUFNYyxPQUFPLENBQUNELE9BQU8sS0FBSztRQUMxQixNQUFNRSxRQUFRNUIsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtjLEtBQUssQ0FBQ00sTUFBTVY7UUFFM0MsSUFBSyxJQUFJbUIsSUFBSSxHQUFHQSxJQUFJSCxNQUFNRyxJQUFLO1lBQzdCLE1BQU1DLFNBQVMsQ0FBQ0QsSUFBSUYsSUFBRyxJQUFLaEI7WUFDNUIsTUFBTW9CLFVBQVUsSUFBSyxJQUFNckIsQ0FBQUEsV0FBVyxHQUFFO1lBQ3hDLElBQUssSUFBSXNCLElBQUksR0FBR0EsS0FBS0osT0FBT0ksSUFBSztnQkFDL0IsTUFBTUMsSUFBSUQsSUFBSXRCLFdBQVdxQjtnQkFDekIsSUFBSUUsSUFBSWIsS0FBSztnQkFDYixNQUFNcEMsSUFBSXNCLEVBQUV0QixDQUFDLEdBQUdzQyxLQUFLVyxJQUFJVCxLQUFLTTtnQkFDOUIsTUFBTTdDLElBQUlxQixFQUFFckIsQ0FBQyxHQUFHc0MsS0FBS1UsSUFBSVIsS0FBS0s7Z0JBQzlCZCxLQUFLa0IsSUFBSSxDQUFDO29CQUFFbEQ7b0JBQUdDO29CQUFHa0QsR0FBR2xCLGFBQWFnQjtnQkFBRTtZQUN0QztRQUNGO1FBQ0FoQixjQUFjRztJQUNoQjtJQUVBLDJEQUEyRDtJQUMzRCxNQUFNZ0IsWUFBWSxDQUFDdkIsVUFBVSxLQUFLRixZQUFZLE9BQU9IO0lBQ3JENkIsT0FBT2pDLENBQUMsQ0FBQyxFQUFFLEVBQUVnQztJQUNiQyxPQUFPakMsQ0FBQyxDQUFDLEVBQUUsRUFBRWdDO0lBQ2JDLE9BQU9qQyxDQUFDLENBQUMsRUFBRSxFQUFFZ0M7SUFDYkMsT0FBT2pDLENBQUMsQ0FBQyxFQUFFLEVBQUVnQyxZQUFZO0lBQ3pCQyxPQUFPakMsQ0FBQyxDQUFDLEVBQUUsRUFBRWdDLFlBQVk7SUFFekIsU0FBU0MsT0FBT0MsTUFBVSxFQUFFQyxNQUFjO1FBQ3hDLE1BQU1DLE9BQU94QyxLQUFLQyxHQUFHLENBQUNPLFlBQVksSUFBSUMsUUFBUUUsWUFBWTtRQUMxRCxNQUFNOEIsUUFBUXpDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLYyxLQUFLLENBQUN5QixTQUFTQztRQUM5QyxJQUFLLElBQUlYLElBQUksR0FBR0EsS0FBS1ksT0FBT1osSUFBSztZQUMvQixNQUFNYSxNQUFNYixJQUFJVztZQUNoQixNQUFNRyxPQUFPLElBQUkzQyxLQUFLNEMsRUFBRSxHQUFHNUMsS0FBS0MsR0FBRyxDQUFDeUMsS0FBSztZQUN6QyxNQUFNRyxJQUFJN0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtjLEtBQUssQ0FBQzZCLE9BQU9IO1lBQ3hDLElBQUssSUFBSVIsSUFBSSxHQUFHQSxJQUFJYSxHQUFHYixJQUFLO2dCQUMxQixNQUFNMUIsSUFBSSxJQUFLdUMsSUFBSzdDLEtBQUs0QyxFQUFFLEdBQUc7Z0JBQzlCLE1BQU01RCxJQUFJc0QsT0FBT3RELENBQUMsR0FBR2dCLEtBQUs4QyxHQUFHLENBQUN4QyxLQUFLb0M7Z0JBQ25DLE1BQU16RCxJQUFJcUQsT0FBT3JELENBQUMsR0FBR2UsS0FBSytDLEdBQUcsQ0FBQ3pDLEtBQUtvQztnQkFDbkMsc0VBQXNFO2dCQUN0RTFCLEtBQUtrQixJQUFJLENBQUM7b0JBQUVsRDtvQkFBR0M7b0JBQUdrRCxHQUFHbEIsYUFBYVksSUFBSSxRQUFRRyxJQUFJO2dCQUFPO1lBQzNEO1FBQ0Y7SUFDRjtJQUVBLGdEQUFnRDtJQUNoRGhCLEtBQUtnQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRWQsQ0FBQyxHQUFHZSxFQUFFZixDQUFDO0lBRTdCLGdDQUFnQztJQUNoQyxNQUFNZ0IsUUFBUW5DLEtBQUtvQyxNQUFNO0lBQ3pCLE1BQU1DLFFBQVFDLFlBQVlDLEdBQUc7SUFDN0IsSUFBSUMsUUFBUTtJQUVaLG9DQUFvQztJQUNwQ0MsUUFBUXJFLE9BQU9KLENBQUMsRUFBRUksT0FBT0gsQ0FBQyxFQUFFdUIsWUFBWTtJQUV4QyxTQUFTa0QsS0FBS0gsR0FBVztRQUN2QixNQUFNSSxJQUFJM0QsS0FBSzRELEdBQUcsQ0FBQyxDQUFDTCxNQUFNRixLQUFJLElBQUssT0FBT3RDLGFBQWE7UUFDdkQsTUFBTThDLFNBQVM3RCxLQUFLYyxLQUFLLENBQUM2QyxJQUFJUjtRQUM5QixNQUFPSyxRQUFRSyxVQUFVTCxRQUFRTCxPQUFPSyxRQUFTO1lBQy9DLE1BQU1QLElBQUlqQyxJQUFJLENBQUN3QyxNQUFNO1lBQ3JCQyxRQUFRUixFQUFFakUsQ0FBQyxFQUFFaUUsRUFBRWhFLENBQUMsRUFBRXVCO1FBQ3BCO1FBQ0EsSUFBSWdELFFBQVFMLE9BQU9XLHNCQUFzQko7SUFDM0M7SUFDQUksc0JBQXNCSjtJQUV0QixTQUFTRCxRQUFRekUsQ0FBUyxFQUFFQyxDQUFTLEVBQUU0QyxDQUFTO1FBQzlDMUMsSUFBSTRFLFNBQVM7UUFDYjVFLElBQUk2RSxHQUFHLENBQUNoRixHQUFHQyxHQUFHNEMsR0FBRyxHQUFHN0IsS0FBSzRDLEVBQUUsR0FBRztRQUM5QnpELElBQUk4RSxTQUFTLEdBQUc7UUFDaEI5RSxJQUFJK0UsV0FBVyxHQUFHO1FBQ2xCL0UsSUFBSWdGLFVBQVUsR0FBRztRQUNqQmhGLElBQUlpRixJQUFJO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzPzQ2YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXBwL21vZHVsZXMvY3J5c3RhbEVuZ2luZS50c1xudHlwZSBYWSA9IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuXG4vKiogTGllZmVydCBkZW4gZXhha3RlbiBBbmNob3IgKGxpbmtlciB1bnRlcmVyIE0tUHVua3QpIGbDvHIgZ2VnZWJlbmUgTWHDn2UgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTUFuY2hvcih3OiBudW1iZXIsIGg6IG51bWJlcik6IFhZIHtcbiAgY29uc3QgbGVmdFggPSB3ICogMC4yOFxuICBjb25zdCBiYXNlWSA9IGggKiAwLjc0XG4gIHJldHVybiB7IHg6IGxlZnRYLCB5OiBiYXNlWSB9XG59XG5cbi8qKlxuICogRG90dGVkLU0sIG1hamVzdMOkdGlzY2ggJiBibGF1OlxuICogLSBWZXJ0aWthbGUgU8OkdWxlbiwgZGlhZ29uYWxlIFNjaGVua2VsXG4gKiAtIENhcHMgZsO8bGxlbiBFY2tlbiAob2JlbiwgVGFsLCB1bnRlbilcbiAqIC0gU2VxdWVuemllbGxlciBBdWZiYXUgUDDihpJQMeKGklAy4oaSUDPihpJQNCAofjVzKVxuICogLSBIb2hlIERpY2h0ZSArIGRvcHBlbHRlIEJyZWl0ZSwgYWJlciBtaXQga2xhcmVuIEFic3TDpG5kZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ3J5c3RhbE0oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFuY2hvcjogWFkpIHtcbiAgY29uc3QgaXNNb2JpbGUgPSAvTW9iaXxBbmRyb2lkfGlQaG9uZXxpUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuXG4gIGNvbnN0IHJlY3QgPSBjdHguY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGNvbnN0IHcgPSByZWN0LndpZHRoLCBoID0gcmVjdC5oZWlnaHRcblxuICAvLyBQcm9wb3J0aW9uZW4gKGVyaGFiZW4pXG4gIGNvbnN0IGJhc2VZID0gaCAqIDAuNzRcbiAgY29uc3QgdG9wWSAgPSBoICogMC4zNlxuICBjb25zdCBsZWZ0WCA9IHcgKiAwLjI4XG4gIGNvbnN0IHJpZ2h0WCA9IHcgKiAwLjI4ICsgTWF0aC5tYXgoMzYwLCB3ICogMC4zMilcbiAgY29uc3QgbWlkWCAgPSAobGVmdFggKyByaWdodFgpIC8gMlxuICBjb25zdCB2YWxsZXlZID0gYmFzZVkgLSBNYXRoLm1heCg5MCwgaCAqIDAuMTQpXG5cbiAgY29uc3QgUCA9IFtcbiAgICB7IHg6IGxlZnRYLCAgeTogYmFzZVkgfSwgIC8vIDAgKEFuY2hvcilcbiAgICB7IHg6IGxlZnRYLCAgeTogdG9wWSB9LCAgIC8vIDEgdmVydGlrYWwgaG9jaFxuICAgIHsgeDogbWlkWCwgICB5OiB2YWxsZXlZIH0sLy8gMiBUYWxcbiAgICB7IHg6IHJpZ2h0WCwgeTogdG9wWSB9LCAgIC8vIDNcbiAgICB7IHg6IHJpZ2h0WCwgeTogYmFzZVkgfSwgIC8vIDQgdmVydGlrYWwgcnVudGVyXG4gIF0gYXMgY29uc3RcblxuICBjb25zdCBzZWdtZW50cyA9IFtcbiAgICB7IGE6IFBbMF0sIGI6IFBbMV0gfSxcbiAgICB7IGE6IFBbMV0sIGI6IFBbMl0gfSxcbiAgICB7IGE6IFBbMl0sIGI6IFBbM10gfSxcbiAgICB7IGE6IFBbM10sIGI6IFBbNF0gfSxcbiAgXVxuXG4gIC8vIExvb2sgJiBBYnN0w6RuZGVcbiAgY29uc3QgZG90UmFkaXVzICAgPSBpc01vYmlsZSA/IDEuMyA6IDEuNlxuICBjb25zdCBtaW5HYXAgICAgICA9IGlzTW9iaWxlID8gMS44IDogMi4yXG4gIGNvbnN0IGFsb25nR2FwICAgID0gTWF0aC5tYXgoaXNNb2JpbGUgPyAyLjQgOiAyLjAsIGRvdFJhZGl1cyAqIDIgKyAobWluR2FwIC0gMC42KSlcbiAgY29uc3QgYWNyb3NzR2FwICAgPSBNYXRoLm1heChpc01vYmlsZSA/IDQuOCA6IDQuMiwgZG90UmFkaXVzICogMiArIG1pbkdhcClcbiAgY29uc3QgdGFyZ2V0V2lkdGggPSAoaXNNb2JpbGUgPyAyOCA6IDU2KVxuICBjb25zdCBtYXhSb3dzICAgICA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGFyZ2V0V2lkdGggLyBhY3Jvc3NHYXApKVxuICBjb25zdCBkdXJhdGlvblNlYyA9IDVcblxuICB0eXBlIERvdCA9IFhZICYgeyBzOiBudW1iZXIgfVxuICBjb25zdCBkb3RzOiBEb3RbXSA9IFtdXG4gIGxldCBwYXRoT2Zmc2V0ID0gMFxuXG4gIC8vIExpbmllbnB1bmt0ZVxuICBmb3IgKGNvbnN0IHsgYSwgYiB9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3QgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55XG4gICAgY29uc3QgbGVuID0gTWF0aC5oeXBvdChkeCwgZHkpOyBpZiAobGVuIDw9IDApIGNvbnRpbnVlXG4gICAgY29uc3QgdHggPSBkeCAvIGxlbiwgdHkgPSBkeSAvIGxlblxuICAgIGNvbnN0IG54ID0gIHR5LCAgICAgICBueSA9IC10eFxuICAgIGNvbnN0IHJvd3MgPSBNYXRoLm1heCgxLCBtYXhSb3dzKVxuICAgIGNvbnN0IGhhbGYgPSAocm93cyAtIDEpIC8gMlxuICAgIGNvbnN0IHN0ZXBzID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcihsZW4gLyBhbG9uZ0dhcCkpXG5cbiAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKHIgLSBoYWxmKSAqIGFjcm9zc0dhcFxuICAgICAgY29uc3Qgc3RhZ2dlciA9IChyICUgMikgKiAoYWxvbmdHYXAgKiAwLjUpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzdGVwczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBpICogYWxvbmdHYXAgKyBzdGFnZ2VyXG4gICAgICAgIGlmIChkID4gbGVuKSBjb250aW51ZVxuICAgICAgICBjb25zdCB4ID0gYS54ICsgdHggKiBkICsgbnggKiBvZmZzZXRcbiAgICAgICAgY29uc3QgeSA9IGEueSArIHR5ICogZCArIG55ICogb2Zmc2V0XG4gICAgICAgIGRvdHMucHVzaCh7IHgsIHksIHM6IHBhdGhPZmZzZXQgKyBkIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHBhdGhPZmZzZXQgKz0gbGVuXG4gIH1cblxuICAvLyBDYXBzIGFuIEVja2VuIChvYmVuIGxpbmtzL3JlY2h0cywgVGFsKSArIEVuZGthcHBlbiB1bnRlblxuICBjb25zdCBjYXBSYWRpdXMgPSAobWF4Um93cyAtIDEpICogYWNyb3NzR2FwICogMC41NSArIGRvdFJhZGl1c1xuICBhZGRDYXAoUFsxXSwgY2FwUmFkaXVzKVxuICBhZGRDYXAoUFsyXSwgY2FwUmFkaXVzKVxuICBhZGRDYXAoUFszXSwgY2FwUmFkaXVzKVxuICBhZGRDYXAoUFswXSwgY2FwUmFkaXVzICogMC44NSlcbiAgYWRkQ2FwKFBbNF0sIGNhcFJhZGl1cyAqIDAuODUpXG5cbiAgZnVuY3Rpb24gYWRkQ2FwKGNlbnRlcjogWFksIHJhZGl1czogbnVtYmVyKSB7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KGRvdFJhZGl1cyAqIDIgKyBtaW5HYXAsIGFjcm9zc0dhcCAqIDAuOSlcbiAgICBjb25zdCByaW5ncyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmFkaXVzIC8gc3RlcCkpXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gcmluZ3M7IHIrKykge1xuICAgICAgY29uc3QgcmFkID0gciAqIHN0ZXBcbiAgICAgIGNvbnN0IGNpcmMgPSAyICogTWF0aC5QSSAqIE1hdGgubWF4KHJhZCwgMSlcbiAgICAgIGNvbnN0IG4gPSBNYXRoLm1heCg2LCBNYXRoLmZsb29yKGNpcmMgLyBzdGVwKSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSAoaSAvIG4pICogTWF0aC5QSSAqIDJcbiAgICAgICAgY29uc3QgeCA9IGNlbnRlci54ICsgTWF0aC5jb3MoYSkgKiByYWRcbiAgICAgICAgY29uc3QgeSA9IGNlbnRlci55ICsgTWF0aC5zaW4oYSkgKiByYWRcbiAgICAgICAgLy8gcyA9IFBvc2l0aW9uIGVudGxhbmcgUGZhZCBuYWhlIGRlciBFY2tlIC0+IG1pdCBrbGVpbmVyIFZlcnNjaGllYnVuZ1xuICAgICAgICBkb3RzLnB1c2goeyB4LCB5LCBzOiBwYXRoT2Zmc2V0ICsgciAqIDAuMDAxICsgaSAqIDAuMDAwMSB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0cmlrdCBlbnRsYW5nIGRlciBTdHJ1a3R1ciAobGlua3MgLT4gcmVjaHRzKVxuICBkb3RzLnNvcnQoKHAsIHEpID0+IHAucyAtIHEucylcblxuICAvLyBaZWl0Z2VzdGV1ZXJ0ZXIgQXVmYmF1ICh+NSBzKVxuICBjb25zdCB0b3RhbCA9IGRvdHMubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgbGV0IGRyYXduID0gMFxuXG4gIC8vIEVyc3RlciBQdW5rdCAoTWV0ZW9yL0FuY2hvcikgYmxhdVxuICBkcmF3RG90KGFuY2hvci54LCBhbmNob3IueSwgZG90UmFkaXVzICsgMC45KVxuXG4gIGZ1bmN0aW9uIHRpY2sobm93OiBudW1iZXIpIHtcbiAgICBjb25zdCB0ID0gTWF0aC5taW4oKG5vdyAtIHN0YXJ0KSAvIDEwMDAgLyBkdXJhdGlvblNlYywgMSlcbiAgICBjb25zdCB0YXJnZXQgPSBNYXRoLmZsb29yKHQgKiB0b3RhbClcbiAgICBmb3IgKDsgZHJhd24gPCB0YXJnZXQgJiYgZHJhd24gPCB0b3RhbDsgZHJhd24rKykge1xuICAgICAgY29uc3QgcCA9IGRvdHNbZHJhd25dXG4gICAgICBkcmF3RG90KHAueCwgcC55LCBkb3RSYWRpdXMpXG4gICAgfVxuICAgIGlmIChkcmF3biA8IHRvdGFsKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljaylcbiAgfVxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljaylcblxuICBmdW5jdGlvbiBkcmF3RG90KHg6IG51bWJlciwgeTogbnVtYmVyLCByOiBudW1iZXIpIHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKVxuICAgIGN0eC5maWxsU3R5bGUgPSAnIzZCRDVGRidcbiAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgxMDcsIDIxMywgMjU1LCAwLjU1KSdcbiAgICBjdHguc2hhZG93Qmx1ciA9IDRcbiAgICBjdHguZmlsbCgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjb21wdXRlTUFuY2hvciIsInciLCJoIiwibGVmdFgiLCJiYXNlWSIsIngiLCJ5IiwiYnVpbGRDcnlzdGFsTSIsImN0eCIsImFuY2hvciIsImlzTW9iaWxlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInJlY3QiLCJjYW52YXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInRvcFkiLCJyaWdodFgiLCJNYXRoIiwibWF4IiwibWlkWCIsInZhbGxleVkiLCJQIiwic2VnbWVudHMiLCJhIiwiYiIsImRvdFJhZGl1cyIsIm1pbkdhcCIsImFsb25nR2FwIiwiYWNyb3NzR2FwIiwidGFyZ2V0V2lkdGgiLCJtYXhSb3dzIiwiZmxvb3IiLCJkdXJhdGlvblNlYyIsImRvdHMiLCJwYXRoT2Zmc2V0IiwiZHgiLCJkeSIsImxlbiIsImh5cG90IiwidHgiLCJ0eSIsIm54IiwibnkiLCJyb3dzIiwiaGFsZiIsInN0ZXBzIiwiciIsIm9mZnNldCIsInN0YWdnZXIiLCJpIiwiZCIsInB1c2giLCJzIiwiY2FwUmFkaXVzIiwiYWRkQ2FwIiwiY2VudGVyIiwicmFkaXVzIiwic3RlcCIsInJpbmdzIiwicmFkIiwiY2lyYyIsIlBJIiwibiIsImNvcyIsInNpbiIsInNvcnQiLCJwIiwicSIsInRvdGFsIiwibGVuZ3RoIiwic3RhcnQiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImRyYXduIiwiZHJhd0RvdCIsInRpY2siLCJ0IiwibWluIiwidGFyZ2V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYmVnaW5QYXRoIiwiYXJjIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});