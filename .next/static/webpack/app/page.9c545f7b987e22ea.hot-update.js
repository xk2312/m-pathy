"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n// Kristalline Entfaltung als PFAD (nicht Stern):\n// 0→1 → 1→2 → 2→3 → 3→4\nfunction buildCrystalM(ctx) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    // in CSS-Pixeln planen (Canvas ist via setTransform DPR-korrigiert)\n    const rect = ctx.canvas.getBoundingClientRect();\n    const w = rect.width;\n    const h = rect.height;\n    // Geometrie\n    const baseX = w * 0.30;\n    const baseY = h * 0.70;\n    const spanX = Math.max(160, w * 0.22);\n    const peakY = Math.min(baseY - h * 0.28, h * 0.42);\n    // 5 Schlüssel-Punkte des M\n    const P = [\n        {\n            x: baseX,\n            y: baseY\n        },\n        {\n            x: baseX + spanX * 0.25,\n            y: peakY\n        },\n        {\n            x: baseX + spanX * 0.50,\n            y: baseY * 0.93\n        },\n        {\n            x: baseX + spanX * 0.75,\n            y: peakY\n        },\n        {\n            x: baseX + spanX,\n            y: baseY\n        } // 4 unten rechts\n    ];\n    const segments = [\n        {\n            sx: P[0].x,\n            sy: P[0].y,\n            tx: P[1].x,\n            ty: P[1].y,\n            t: 0,\n            done: false\n        },\n        {\n            sx: P[1].x,\n            sy: P[1].y,\n            tx: P[2].x,\n            ty: P[2].y,\n            t: 0,\n            done: false\n        },\n        {\n            sx: P[2].x,\n            sy: P[2].y,\n            tx: P[3].x,\n            ty: P[3].y,\n            t: 0,\n            done: false\n        },\n        {\n            sx: P[3].x,\n            sy: P[3].y,\n            tx: P[4].x,\n            ty: P[4].y,\n            t: 0,\n            done: false\n        }\n    ];\n    const maxProgress = isMobile ? 30 : 42;\n    let rafId = 0;\n    const drawGold = (x, y, r)=>{\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#ffd700\";\n        ctx.shadowColor = \"rgba(255,215,0,1)\";\n        ctx.shadowBlur = 18;\n        ctx.fill();\n    };\n    function frame() {\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        // Punkte, die bereits „erreicht“ wurden, leuchten\n        drawGold(P[0].x, P[0].y, isMobile ? 3 : 4);\n        let allDone = true;\n        segments.forEach((seg, i)=>{\n            if (!seg.done) {\n                seg.t++;\n                const p = Math.min(seg.t / maxProgress, 1);\n                const nx = seg.sx + (seg.tx - seg.sx) * p;\n                const ny = seg.sy + (seg.ty - seg.sy) * p;\n                // Kristalllinie\n                ctx.beginPath();\n                ctx.moveTo(seg.sx, seg.sy);\n                ctx.lineTo(nx, ny);\n                ctx.strokeStyle = \"rgba(173,216,230,0.95)\";\n                ctx.lineWidth = isMobile ? 1.6 : 2.2;\n                ctx.shadowColor = \"rgba(173,216,230,1)\";\n                ctx.shadowBlur = 14;\n                ctx.stroke();\n                if (p === 1) {\n                    seg.done = true;\n                    // Endpunkt dieses Segments wird „fixiert“\n                    drawGold(seg.tx, seg.ty, isMobile ? 2.6 : 3.2);\n                }\n            }\n            if (!seg.done) allDone = false;\n            // Startpunkte fertiger Segmente fixieren\n            if (seg.t > 0) drawGold(seg.sx, seg.sy, isMobile ? 2.6 : 3.2);\n        });\n        if (!allDone) {\n            rafId = requestAnimationFrame(frame);\n        } else {\n            // Finales Aufglühen aller Punkte\n            P.forEach((pt)=>drawGold(pt.x, pt.y, isMobile ? 3 : 4));\n        // cancelAnimationFrame(rafId) // nicht nötig, Loop endet\n        }\n    }\n    rafId = requestAnimationFrame(frame);\n// optional: return () => cancelAnimationFrame(rafId)\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLCtCQUErQjtBQUMvQixpREFBaUQ7QUFDakQsd0JBQXdCO0FBRWpCLFNBQVNBLGNBQWNDLEdBQTZCO0lBQ3pELE1BQU1DLFdBQVcsNEJBQTRCQyxJQUFJLENBQUNDLFVBQVVDLFNBQVM7SUFFckUsb0VBQW9FO0lBQ3BFLE1BQU1DLE9BQU9MLElBQUlNLE1BQU0sQ0FBQ0MscUJBQXFCO0lBQzdDLE1BQU1DLElBQUlILEtBQUtJLEtBQUs7SUFDcEIsTUFBTUMsSUFBSUwsS0FBS00sTUFBTTtJQUVyQixZQUFZO0lBQ1osTUFBTUMsUUFBUUosSUFBSTtJQUNsQixNQUFNSyxRQUFRSCxJQUFJO0lBQ2xCLE1BQU1JLFFBQVFDLEtBQUtDLEdBQUcsQ0FBQyxLQUFLUixJQUFJO0lBQ2hDLE1BQU1TLFFBQVFGLEtBQUtHLEdBQUcsQ0FBQ0wsUUFBUUgsSUFBSSxNQUFNQSxJQUFJO0lBRTdDLDJCQUEyQjtJQUMzQixNQUFNUyxJQUFJO1FBQ1I7WUFBRUMsR0FBR1I7WUFBcUJTLEdBQUdSO1FBQU07UUFDbkM7WUFBRU8sR0FBR1IsUUFBUUUsUUFBTTtZQUFPTyxHQUFHSjtRQUFNO1FBQ25DO1lBQUVHLEdBQUdSLFFBQVFFLFFBQU07WUFBT08sR0FBR1IsUUFBUTtRQUFLO1FBQzFDO1lBQUVPLEdBQUdSLFFBQVFFLFFBQU07WUFBT08sR0FBR0o7UUFBTTtRQUNuQztZQUFFRyxHQUFHUixRQUFRRTtZQUFhTyxHQUFHUjtRQUFNLEVBQVcsaUJBQWlCO0tBQ2hFO0lBSUQsTUFBTVMsV0FBc0I7UUFDMUI7WUFBRUMsSUFBR0osQ0FBQyxDQUFDLEVBQUUsQ0FBQ0MsQ0FBQztZQUFFSSxJQUFHTCxDQUFDLENBQUMsRUFBRSxDQUFDRSxDQUFDO1lBQUVJLElBQUdOLENBQUMsQ0FBQyxFQUFFLENBQUNDLENBQUM7WUFBRU0sSUFBR1AsQ0FBQyxDQUFDLEVBQUUs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QUFDMkMsSUFBSWhCLElBQUksRUFBRWMsVUFBVTtZQUN6Qix5Q0FBeUM7WUFDekMsSUFBSUUsSUFBSWpCLENBQUMsR0FBRyxHQUFHSSxTQUFTYSxJQUFJckIsRUFBRSxFQUFFcUIsSUFBSXBCLEVBQUUsRUFBRXZCLFdBQVcsTUFBTTtRQUMzRDtRQUVBLElBQUksQ0FBQ3lDLFNBQVM7WUFDWlosUUFBUXdCLHNCQUFzQmQ7UUFDaEMsT0FBTztZQUNMLGlDQUFpQztZQUNqQ3JCLEVBQUV3QixPQUFPLENBQUNZLENBQUFBLEtBQU14QixTQUFTd0IsR0FBR25DLENBQUMsRUFBRW1DLEdBQUdsQyxDQUFDLEVBQUVwQixXQUFXLElBQUk7UUFDcEQseURBQXlEO1FBQzNEO0lBQ0Y7SUFFQTZCLFFBQVF3QixzQkFBc0JkO0FBQzlCLHFEQUFxRDtBQUN2RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbW9kdWxlcy9jcnlzdGFsRW5naW5lLnRzPzQ2YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXBwL21vZHVsZXMvY3J5c3RhbEVuZ2luZS50c1xuLy8gS3Jpc3RhbGxpbmUgRW50ZmFsdHVuZyBhbHMgUEZBRCAobmljaHQgU3Rlcm4pOlxuLy8gMOKGkjEg4oaSIDHihpIyIOKGkiAy4oaSMyDihpIgM+KGkjRcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ3J5c3RhbE0oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgY29uc3QgaXNNb2JpbGUgPSAvTW9iaXxBbmRyb2lkfGlQaG9uZXxpUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuXG4gIC8vIGluIENTUy1QaXhlbG4gcGxhbmVuIChDYW52YXMgaXN0IHZpYSBzZXRUcmFuc2Zvcm0gRFBSLWtvcnJpZ2llcnQpXG4gIGNvbnN0IHJlY3QgPSBjdHguY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGNvbnN0IHcgPSByZWN0LndpZHRoXG4gIGNvbnN0IGggPSByZWN0LmhlaWdodFxuXG4gIC8vIEdlb21ldHJpZVxuICBjb25zdCBiYXNlWCA9IHcgKiAwLjMwXG4gIGNvbnN0IGJhc2VZID0gaCAqIDAuNzBcbiAgY29uc3Qgc3BhblggPSBNYXRoLm1heCgxNjAsIHcgKiAwLjIyKVxuICBjb25zdCBwZWFrWSA9IE1hdGgubWluKGJhc2VZIC0gaCAqIDAuMjgsIGggKiAwLjQyKVxuXG4gIC8vIDUgU2NobMO8c3NlbC1QdW5rdGUgZGVzIE1cbiAgY29uc3QgUCA9IFtcbiAgICB7IHg6IGJhc2VYLCAgICAgICAgICAgICAgIHk6IGJhc2VZIH0sICAgICAgICAgLy8gMCB1bnRlbiBsaW5rc1xuICAgIHsgeDogYmFzZVggKyBzcGFuWCowLjI1LCAgeTogcGVha1kgfSwgICAgICAgICAvLyAxIGxpbmtlciBQZWFrXG4gICAgeyB4OiBiYXNlWCArIHNwYW5YKjAuNTAsICB5OiBiYXNlWSAqIDAuOTMgfSwgIC8vIDIgVGFsIE1pdHRlXG4gICAgeyB4OiBiYXNlWCArIHNwYW5YKjAuNzUsICB5OiBwZWFrWSB9LCAgICAgICAgIC8vIDMgcmVjaHRlciBQZWFrXG4gICAgeyB4OiBiYXNlWCArIHNwYW5YLCAgICAgICB5OiBiYXNlWSB9ICAgICAgICAgIC8vIDQgdW50ZW4gcmVjaHRzXG4gIF0gYXMgY29uc3RcblxuICAvLyBTZWdtZW50ZSBudXIgendpc2NoZW4gYXVmZWluYW5kZXJmb2xnZW5kZW4gUHVua3RlblxuICB0eXBlIFNlZ21lbnQgPSB7IHN4Om51bWJlcjsgc3k6bnVtYmVyOyB0eDpudW1iZXI7IHR5Om51bWJlcjsgdDpudW1iZXI7IGRvbmU6Ym9vbGVhbiB9XG4gIGNvbnN0IHNlZ21lbnRzOiBTZWdtZW50W10gPSBbXG4gICAgeyBzeDpQWzBdLngsIHN5OlBbMF0ueSwgdHg6UFsxXS54LCB0eTpQWzFdLnksIHQ6MCwgZG9uZTpmYWxzZSB9LFxuICAgIHsgc3g6UFsxXS54LCBzeTpQWzFdLnksIHR4OlBbMl0ueCwgdHk6UFsyXS55LCB0OjAsIGRvbmU6ZmFsc2UgfSxcbiAgICB7IHN4OlBbMl0ueCwgc3k6UFsyXS55LCB0eDpQWzNdLngsIHR5OlBbM10ueSwgdDowLCBkb25lOmZhbHNlIH0sXG4gICAgeyBzeDpQWzNdLngsIHN5OlBbM10ueSwgdHg6UFs0XS54LCB0eTpQWzRdLnksIHQ6MCwgZG9uZTpmYWxzZSB9LFxuICBdXG5cbiAgY29uc3QgbWF4UHJvZ3Jlc3MgPSBpc01vYmlsZSA/IDMwIDogNDJcbiAgbGV0IHJhZklkID0gMFxuXG4gIGNvbnN0IGRyYXdHb2xkID0gKHg6bnVtYmVyLCB5Om51bWJlciwgcjpudW1iZXIpID0+IHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKVxuICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZDcwMCdcbiAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgyNTUsMjE1LDAsMSknXG4gICAgY3R4LnNoYWRvd0JsdXIgPSAxOFxuICAgIGN0eC5maWxsKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyYW1lKCkge1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpXG5cbiAgICAvLyBQdW5rdGUsIGRpZSBiZXJlaXRzIOKAnmVycmVpY2h04oCcIHd1cmRlbiwgbGV1Y2h0ZW5cbiAgICBkcmF3R29sZChQWzBdLngsIFBbMF0ueSwgaXNNb2JpbGUgPyAzIDogNClcblxuICAgIGxldCBhbGxEb25lID0gdHJ1ZVxuXG4gICAgc2VnbWVudHMuZm9yRWFjaCgoc2VnLCBpKSA9PiB7XG4gICAgICBpZiAoIXNlZy5kb25lKSB7XG4gICAgICAgIHNlZy50KytcbiAgICAgICAgY29uc3QgcCA9IE1hdGgubWluKHNlZy50IC8gbWF4UHJvZ3Jlc3MsIDEpXG4gICAgICAgIGNvbnN0IG54ID0gc2VnLnN4ICsgKHNlZy50eCAtIHNlZy5zeCkgKiBwXG4gICAgICAgIGNvbnN0IG55ID0gc2VnLnN5ICsgKHNlZy50eSAtIHNlZy5zeSkgKiBwXG5cbiAgICAgICAgLy8gS3Jpc3RhbGxsaW5pZVxuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgY3R4Lm1vdmVUbyhzZWcuc3gsIHNlZy5zeSlcbiAgICAgICAgY3R4LmxpbmVUbyhueCwgbnkpXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDE3MywyMTYsMjMwLDAuOTUpJ1xuICAgICAgICBjdHgubGluZVdpZHRoID0gaXNNb2JpbGUgPyAxLjYgOiAyLjJcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMTczLDIxNiwyMzAsMSknXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMTRcbiAgICAgICAgY3R4LnN0cm9rZSgpXG5cbiAgICAgICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgICBzZWcuZG9uZSA9IHRydWVcbiAgICAgICAgICAvLyBFbmRwdW5rdCBkaWVzZXMgU2VnbWVudHMgd2lyZCDigJ5maXhpZXJ04oCcXG4gICAgICAgICAgZHJhd0dvbGQoc2VnLnR4LCBzZWcudHksIGlzTW9iaWxlID8gMi42IDogMy4yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VnLmRvbmUpIGFsbERvbmUgPSBmYWxzZVxuICAgICAgLy8gU3RhcnRwdW5rdGUgZmVydGlnZXIgU2VnbWVudGUgZml4aWVyZW5cbiAgICAgIGlmIChzZWcudCA+IDApIGRyYXdHb2xkKHNlZy5zeCwgc2VnLnN5LCBpc01vYmlsZSA/IDIuNiA6IDMuMilcbiAgICB9KVxuXG4gICAgaWYgKCFhbGxEb25lKSB7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluYWxlcyBBdWZnbMO8aGVuIGFsbGVyIFB1bmt0ZVxuICAgICAgUC5mb3JFYWNoKHB0ID0+IGRyYXdHb2xkKHB0LngsIHB0LnksIGlzTW9iaWxlID8gMyA6IDQpKVxuICAgICAgLy8gY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpIC8vIG5pY2h0IG7DtnRpZywgTG9vcCBlbmRldFxuICAgIH1cbiAgfVxuXG4gIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKVxuICAvLyBvcHRpb25hbDogcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKVxufVxuIl0sIm5hbWVzIjpbImJ1aWxkQ3J5c3RhbE0iLCJjdHgiLCJpc01vYmlsZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJyZWN0IiwiY2FudmFzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsImJhc2VYIiwiYmFzZVkiLCJzcGFuWCIsIk1hdGgiLCJtYXgiLCJwZWFrWSIsIm1pbiIsIlAiLCJ4IiwieSIsInNlZ21lbnRzIiwic3giLCJzeSIsInR4IiwidHkiLCJ0IiwiZG9uZSIsIm1heFByb2dyZXNzIiwicmFmSWQiLCJkcmF3R29sZCIsInIiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGxTdHlsZSIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsImZpbGwiLCJmcmFtZSIsImNsZWFyUmVjdCIsImFsbERvbmUiLCJmb3JFYWNoIiwic2VnIiwiaSIsInAiLCJueCIsIm55IiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});