"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; },\n/* harmony export */   computeMAnchor: function() { return /* binding */ computeMAnchor; }\n/* harmony export */ });\n// app/modules/crystalEngine.ts\n/** Linker unterer Anker exakt wie im M */ function computeMAnchor(w, h) {\n    const leftX = w * 0.28;\n    const baseY = h * 0.74;\n    return {\n        x: leftX,\n        y: baseY\n    };\n}\n/**\n * Pen-Sweep: Ein „digitaler Stift“ fährt den M-Pfad in ~5 s ab und setzt\n * unterwegs Punkte (mehrere parallele Reihen = Strichbreite) mit Mindestabstand.\n * So wirkt es wie EIN Zug „aus einem Guss“.\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    const rect = ctx.canvas.getBoundingClientRect();\n    const w = rect.width, h = rect.height;\n    // Erhabene Proportionen (vertikale Säulen)\n    const baseY = h * 0.74;\n    const topY = h * 0.36;\n    const leftX = w * 0.28;\n    const rightX = w * 0.28 + Math.max(360, w * 0.32);\n    const midX = (leftX + rightX) / 2;\n    const valleyY = baseY - Math.max(90, h * 0.14);\n    const P = [\n        {\n            x: leftX,\n            y: baseY\n        },\n        {\n            x: leftX,\n            y: topY\n        },\n        {\n            x: midX,\n            y: valleyY\n        },\n        {\n            x: rightX,\n            y: topY\n        },\n        {\n            x: rightX,\n            y: baseY\n        }\n    ];\n    // Pfadsegmente\n    const segs = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ].map((s)=>({\n            ...s,\n            dx: s.b.x - s.a.x,\n            dy: s.b.y - s.a.y,\n            len: Math.hypot(s.b.x - s.a.x, s.b.y - s.a.y)\n        }));\n    const totalLen = segs.reduce((s, g)=>s + g.len, 0);\n    // Look & Abstand\n    const dotR = isMobile ? 1.3 : 1.6;\n    const minGap = isMobile ? 1.8 : 2.2;\n    const stepAlong = Math.max(isMobile ? 2.4 : 2.0, dotR * 2 + (minGap - 0.6)) // Abstand auf der Linie\n    ;\n    const gapAcross = Math.max(isMobile ? 4.8 : 4.2, dotR * 2 + minGap) // Abstand zwischen Reihen\n    ;\n    const widthPx = isMobile ? 28 : 56;\n    const rows = Math.max(1, Math.floor(widthPx / gapAcross)) // parallele Reihen (Dicke)\n    ;\n    const durationSec = 5;\n    // Pen-Progress (sweep) zeitgesteuert (FPS-unabhängig)\n    const start = performance.now();\n    let prevS = 0;\n    let raf = 0;\n    // Abstands-Garantie: Spatial Hash\n    const cell = Math.min(stepAlong, gapAcross) * 0.9;\n    const placed = new Set();\n    const key = (x, y)=>\"\".concat(Math.round(x / cell), \":\").concat(Math.round(y / cell));\n    // Ersten Punkt (Anchor) sofort setzen\n    drawDot(anchor.x, anchor.y, dotR + 0.9);\n    placed.add(key(anchor.x, anchor.y));\n    function tick(now) {\n        const t = Math.min((now - start) / (durationSec * 1000), 1) // 0..1\n        ;\n        const sTarget = t * totalLen;\n        // In Schrittweite entlang des Pfads voranschreiten\n        for(let s = prevS; s <= sTarget; s += stepAlong){\n            const pos = pointAtLength(s);\n            if (!pos) continue;\n            // Normale und Tangente an aktueller Stelle\n            const { x, y, nx, ny } = pos;\n            // Parallele Reihen (Pinselbreite), symmetrisch um Mittelachse\n            const half = (rows - 1) / 2;\n            for(let r = 0; r < rows; r++){\n                const offset = (r - half) * gapAcross;\n                const px = x + nx * offset;\n                const py = y + ny * offset;\n                const k = key(px, py);\n                if (!placed.has(k)) {\n                    placed.add(k);\n                    drawDot(px, py, dotR);\n                }\n            }\n        }\n        prevS = sTarget;\n        if (t < 1) {\n            raf = requestAnimationFrame(tick);\n        } else {\n            cancelAnimationFrame(raf);\n        }\n    }\n    raf = requestAnimationFrame(tick);\n    // optional Cleanup: return () => cancelAnimationFrame(raf)\n    // Hilfsfunktionen ----------------------------------------------------------\n    // Punkt + Normale an Pfadlänge s\n    function pointAtLength(s) {\n        let acc = 0;\n        for (const g of segs){\n            if (s <= acc + g.len) {\n                const ls = s - acc;\n                const t = g.len === 0 ? 0 : ls / g.len;\n                const x = g.a.x + g.dx * t;\n                const y = g.a.y + g.dy * t;\n                const tx = g.len === 0 ? 0 : g.dx / g.len;\n                const ty = g.len === 0 ? 0 : g.dy / g.len;\n                const nx = ty;\n                const ny = -tx;\n                return {\n                    x,\n                    y,\n                    nx,\n                    ny\n                };\n            }\n            acc += g.len;\n        }\n        // s exakt am Ende\n        const last = segs[segs.length - 1];\n        const tx = last.len === 0 ? 0 : last.dx / last.len;\n        const ty = last.len === 0 ? 0 : last.dy / last.len;\n        return {\n            x: last.b.x,\n            y: last.b.y,\n            nx: ty,\n            ny: -tx\n        };\n    }\n    function drawDot(x, y, r) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#6BD5FF\" // elektrisches Blau\n        ;\n        ctx.shadowColor = \"rgba(107, 213, 255, 0.55)\";\n        ctx.shadowBlur = 4;\n        ctx.fill();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQkFBK0I7QUFHL0Isd0NBQXdDLEdBQ2pDLFNBQVNBLGVBQWVDLENBQVMsRUFBRUMsQ0FBUztJQUNqRCxNQUFNQyxRQUFRRixJQUFJO0lBQ2xCLE1BQU1HLFFBQVFGLElBQUk7SUFDbEIsT0FBTztRQUFFRyxHQUFHRjtRQUFPRyxHQUFHRjtJQUFNO0FBQzlCO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNHLGNBQWNDLEdBQTZCLEVBQUVDLE1BQVU7SUFDckUsTUFBTUMsV0FBVyw0QkFBNEJDLElBQUksQ0FBQ0MsVUFBVUMsU0FBUztJQUNyRSxNQUFNQyxPQUFPTixJQUFJTyxNQUFNLENBQUNDLHFCQUFxQjtJQUM3QyxNQUFNZixJQUFJYSxLQUFLRyxLQUFLLEVBQUVmLElBQUlZLEtBQUtJLE1BQU07SUFFckMsMkNBQTJDO0lBQzNDLE1BQU1kLFFBQVFGLElBQUk7SUFDbEIsTUFBTWlCLE9BQVFqQixJQUFJO0lBQ2xCLE1BQU1DLFFBQVFGLElBQUk7SUFDbEIsTUFBTW1CLFNBQVNuQixJQUFJLE9BQU9vQixLQUFLQyxHQUFHLENBQUMsS0FBS3JCLElBQUk7SUFDNUMsTUFBTXNCLE9BQVEsQ0FBQ3BCLFFBQVFpQixNQUFLLElBQUs7SUFDakMsTUFBTUksVUFBVXBCLFFBQVFpQixLQUFLQyxHQUFHLENBQUMsSUFBSXBCLElBQUk7SUFFekMsTUFBTXVCLElBQUk7UUFDUjtZQUFFcEIsR0FBR0Y7WUFBUUcsR0FBR0Y7UUFBTTtRQUN0QjtZQUFFQyxHQUFHRjtZQUFRRyxHQUFHYTtRQUFNO1FBQ3RCO1lBQUVkLEdBQUdrQjtZQUFRakIsR0FBR2tCO1FBQVE7UUFDeEI7WUFBRW5CLEdBQUdlO1lBQVFkLEdBQUdhO1FBQU07UUFDdEI7WUFBRWQsR0FBR2U7WUFBUWQsR0FBR0Y7UUFBTTtLQUN2QjtJQUVELGVBQWU7SUFDZixNQUFNc0IsT0FBTztR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QyxNQUFNNkMsS0FBS3pDLEVBQUVKLEdBQUcsS0FBSyxJQUFJLElBQUlJLEVBQUVMLEVBQUUsR0FBR0ssRUFBRUosR0FBRztnQkFDekMsTUFBTStCLEtBQU1jO2dCQUNaLE1BQU1iLEtBQUssQ0FBQ1k7Z0JBQ1osT0FBTztvQkFBRXhFO29CQUFHQztvQkFBRzBEO29CQUFJQztnQkFBRztZQUN4QjtZQUNBVSxPQUFPdEMsRUFBRUosR0FBRztRQUNkO1FBQ0Esa0JBQWtCO1FBQ2xCLE1BQU04QyxPQUFPckQsSUFBSSxDQUFDQSxLQUFLc0QsTUFBTSxHQUFHLEVBQUU7UUFDbEMsTUFBTUgsS0FBS0UsS0FBSzlDLEdBQUcsS0FBSyxJQUFJLElBQUk4QyxLQUFLaEQsRUFBRSxHQUFHZ0QsS0FBSzlDLEdBQUc7UUFDbEQsTUFBTTZDLEtBQUtDLEtBQUs5QyxHQUFHLEtBQUssSUFBSSxJQUFJOEMsS0FBSy9DLEVBQUUsR0FBRytDLEtBQUs5QyxHQUFHO1FBQ2xELE9BQU87WUFBRTVCLEdBQUcwRSxLQUFLbkQsQ0FBQyxDQUFDdkIsQ0FBQztZQUFFQyxHQUFHeUUsS0FBS25ELENBQUMsQ0FBQ3RCLENBQUM7WUFBRTBELElBQUljO1lBQUliLElBQUksQ0FBQ1k7UUFBRztJQUNyRDtJQUVBLFNBQVNwQixRQUFRcEQsQ0FBUyxFQUFFQyxDQUFTLEVBQUU2RCxDQUFTO1FBQzlDM0QsSUFBSXlFLFNBQVM7UUFDYnpFLElBQUkwRSxHQUFHLENBQUM3RSxHQUFHQyxHQUFHNkQsR0FBRyxHQUFHOUMsS0FBSzhELEVBQUUsR0FBRztRQUM5QjNFLElBQUk0RSxTQUFTLEdBQUcsVUFBVSxvQkFBb0I7O1FBQzlDNUUsSUFBSTZFLFdBQVcsR0FBRztRQUNsQjdFLElBQUk4RSxVQUFVLEdBQUc7UUFDakI5RSxJQUFJK0UsSUFBSTtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL21vZHVsZXMvY3J5c3RhbEVuZ2luZS50cz80NmM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGFwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHNcbnR5cGUgWFkgPSB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cblxuLyoqIExpbmtlciB1bnRlcmVyIEFua2VyIGV4YWt0IHdpZSBpbSBNICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZU1BbmNob3IodzogbnVtYmVyLCBoOiBudW1iZXIpOiBYWSB7XG4gIGNvbnN0IGxlZnRYID0gdyAqIDAuMjhcbiAgY29uc3QgYmFzZVkgPSBoICogMC43NFxuICByZXR1cm4geyB4OiBsZWZ0WCwgeTogYmFzZVkgfVxufVxuXG4vKipcbiAqIFBlbi1Td2VlcDogRWluIOKAnmRpZ2l0YWxlciBTdGlmdOKAnCBmw6RocnQgZGVuIE0tUGZhZCBpbiB+NSBzIGFiIHVuZCBzZXR6dFxuICogdW50ZXJ3ZWdzIFB1bmt0ZSAobWVocmVyZSBwYXJhbGxlbGUgUmVpaGVuID0gU3RyaWNoYnJlaXRlKSBtaXQgTWluZGVzdGFic3RhbmQuXG4gKiBTbyB3aXJrdCBlcyB3aWUgRUlOIFp1ZyDigJ5hdXMgZWluZW0gR3Vzc+KAnC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ3J5c3RhbE0oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFuY2hvcjogWFkpIHtcbiAgY29uc3QgaXNNb2JpbGUgPSAvTW9iaXxBbmRyb2lkfGlQaG9uZXxpUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuICBjb25zdCByZWN0ID0gY3R4LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCB3ID0gcmVjdC53aWR0aCwgaCA9IHJlY3QuaGVpZ2h0XG5cbiAgLy8gRXJoYWJlbmUgUHJvcG9ydGlvbmVuICh2ZXJ0aWthbGUgU8OkdWxlbilcbiAgY29uc3QgYmFzZVkgPSBoICogMC43NFxuICBjb25zdCB0b3BZICA9IGggKiAwLjM2XG4gIGNvbnN0IGxlZnRYID0gdyAqIDAuMjhcbiAgY29uc3QgcmlnaHRYID0gdyAqIDAuMjggKyBNYXRoLm1heCgzNjAsIHcgKiAwLjMyKVxuICBjb25zdCBtaWRYICA9IChsZWZ0WCArIHJpZ2h0WCkgLyAyXG4gIGNvbnN0IHZhbGxleVkgPSBiYXNlWSAtIE1hdGgubWF4KDkwLCBoICogMC4xNClcblxuICBjb25zdCBQID0gW1xuICAgIHsgeDogbGVmdFgsICB5OiBiYXNlWSB9LCAgIC8vIDBcbiAgICB7IHg6IGxlZnRYLCAgeTogdG9wWSAgfSwgICAvLyAxXG4gICAgeyB4OiBtaWRYLCAgIHk6IHZhbGxleVkgfSwgLy8gMlxuICAgIHsgeDogcmlnaHRYLCB5OiB0b3BZICB9LCAgIC8vIDNcbiAgICB7IHg6IHJpZ2h0WCwgeTogYmFzZVkgfSwgICAvLyA0XG4gIF0gYXMgY29uc3RcblxuICAvLyBQZmFkc2VnbWVudGVcbiAgY29uc3Qgc2VncyA9IFtcbiAgICB7IGE6IFBbMF0sIGI6IFBbMV0gfSxcbiAgICB7IGE6IFBbMV0sIGI6IFBbMl0gfSxcbiAgICB7IGE6IFBbMl0sIGI6IFBbM10gfSxcbiAgICB7IGE6IFBbM10sIGI6IFBbNF0gfSxcbiAgXS5tYXAocyA9PiAoe1xuICAgIC4uLnMsXG4gICAgZHg6IHMuYi54IC0gcy5hLngsXG4gICAgZHk6IHMuYi55IC0gcy5hLnksXG4gICAgbGVuOiBNYXRoLmh5cG90KHMuYi54IC0gcy5hLngsIHMuYi55IC0gcy5hLnkpLFxuICB9KSlcblxuICBjb25zdCB0b3RhbExlbiA9IHNlZ3MucmVkdWNlKChzLCBnKSA9PiBzICsgZy5sZW4sIDApXG5cbiAgLy8gTG9vayAmIEFic3RhbmRcbiAgY29uc3QgZG90UiAgICAgICAgPSBpc01vYmlsZSA/IDEuMyA6IDEuNlxuICBjb25zdCBtaW5HYXAgICAgICA9IGlzTW9iaWxlID8gMS44IDogMi4yXG4gIGNvbnN0IHN0ZXBBbG9uZyAgID0gTWF0aC5tYXgoaXNNb2JpbGUgPyAyLjQgOiAyLjAsIGRvdFIgKiAyICsgKG1pbkdhcCAtIDAuNikpIC8vIEFic3RhbmQgYXVmIGRlciBMaW5pZVxuICBjb25zdCBnYXBBY3Jvc3MgICA9IE1hdGgubWF4KGlzTW9iaWxlID8gNC44IDogNC4yLCBkb3RSICogMiArIG1pbkdhcCkgICAgICAgICAvLyBBYnN0YW5kIHp3aXNjaGVuIFJlaWhlblxuICBjb25zdCB3aWR0aFB4ICAgICA9IGlzTW9iaWxlID8gMjggOiA1NlxuICBjb25zdCByb3dzICAgICAgICA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3Iod2lkdGhQeCAvIGdhcEFjcm9zcykpICAgICAgICAgICAgICAvLyBwYXJhbGxlbGUgUmVpaGVuIChEaWNrZSlcbiAgY29uc3QgZHVyYXRpb25TZWMgPSA1XG5cbiAgLy8gUGVuLVByb2dyZXNzIChzd2VlcCkgemVpdGdlc3RldWVydCAoRlBTLXVuYWJow6RuZ2lnKVxuICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIGxldCBwcmV2UyA9IDBcbiAgbGV0IHJhZiA9IDBcblxuICAvLyBBYnN0YW5kcy1HYXJhbnRpZTogU3BhdGlhbCBIYXNoXG4gIGNvbnN0IGNlbGwgPSBNYXRoLm1pbihzdGVwQWxvbmcsIGdhcEFjcm9zcykgKiAwLjlcbiAgY29uc3QgcGxhY2VkID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3Qga2V5ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PlxuICAgIGAke01hdGgucm91bmQoeCAvIGNlbGwpfToke01hdGgucm91bmQoeSAvIGNlbGwpfWBcblxuICAvLyBFcnN0ZW4gUHVua3QgKEFuY2hvcikgc29mb3J0IHNldHplblxuICBkcmF3RG90KGFuY2hvci54LCBhbmNob3IueSwgZG90UiArIDAuOSlcbiAgcGxhY2VkLmFkZChrZXkoYW5jaG9yLngsIGFuY2hvci55KSlcblxuICBmdW5jdGlvbiB0aWNrKG5vdzogbnVtYmVyKSB7XG4gICAgY29uc3QgdCA9IE1hdGgubWluKChub3cgLSBzdGFydCkgLyAoZHVyYXRpb25TZWMgKiAxMDAwKSwgMSkgLy8gMC4uMVxuICAgIGNvbnN0IHNUYXJnZXQgPSB0ICogdG90YWxMZW5cblxuICAgIC8vIEluIFNjaHJpdHR3ZWl0ZSBlbnRsYW5nIGRlcyBQZmFkcyB2b3JhbnNjaHJlaXRlblxuICAgIGZvciAobGV0IHMgPSBwcmV2UzsgcyA8PSBzVGFyZ2V0OyBzICs9IHN0ZXBBbG9uZykge1xuICAgICAgY29uc3QgcG9zID0gcG9pbnRBdExlbmd0aChzKVxuICAgICAgaWYgKCFwb3MpIGNvbnRpbnVlXG5cbiAgICAgIC8vIE5vcm1hbGUgdW5kIFRhbmdlbnRlIGFuIGFrdHVlbGxlciBTdGVsbGVcbiAgICAgIGNvbnN0IHsgeCwgeSwgbngsIG55IH0gPSBwb3NcblxuICAgICAgLy8gUGFyYWxsZWxlIFJlaWhlbiAoUGluc2VsYnJlaXRlKSwgc3ltbWV0cmlzY2ggdW0gTWl0dGVsYWNoc2VcbiAgICAgIGNvbnN0IGhhbGYgPSAocm93cyAtIDEpIC8gMlxuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHIgLSBoYWxmKSAqIGdhcEFjcm9zc1xuICAgICAgICBjb25zdCBweCA9IHggKyBueCAqIG9mZnNldFxuICAgICAgICBjb25zdCBweSA9IHkgKyBueSAqIG9mZnNldFxuICAgICAgICBjb25zdCBrID0ga2V5KHB4LCBweSlcbiAgICAgICAgaWYgKCFwbGFjZWQuaGFzKGspKSB7XG4gICAgICAgICAgcGxhY2VkLmFkZChrKVxuICAgICAgICAgIGRyYXdEb3QocHgsIHB5LCBkb3RSKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldlMgPSBzVGFyZ2V0XG5cbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpXG4gICAgfVxuICB9XG5cbiAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXG4gIC8vIG9wdGlvbmFsIENsZWFudXA6IHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpXG5cbiAgLy8gSGlsZnNmdW5rdGlvbmVuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBQdW5rdCArIE5vcm1hbGUgYW4gUGZhZGzDpG5nZSBzXG4gIGZ1bmN0aW9uIHBvaW50QXRMZW5ndGgoczogbnVtYmVyKTpcbiAgICB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IG54OiBudW1iZXI7IG55OiBudW1iZXIgfVxuICAgIHwgbnVsbCB7XG4gICAgbGV0IGFjYyA9IDBcbiAgICBmb3IgKGNvbnN0IGcgb2Ygc2Vncykge1xuICAgICAgaWYgKHMgPD0gYWNjICsgZy5sZW4pIHtcbiAgICAgICAgY29uc3QgbHMgPSBzIC0gYWNjXG4gICAgICAgIGNvbnN0IHQgPSBnLmxlbiA9PT0gMCA/IDAgOiBscyAvIGcubGVuXG4gICAgICAgIGNvbnN0IHggPSBnLmEueCArIGcuZHggKiB0XG4gICAgICAgIGNvbnN0IHkgPSBnLmEueSArIGcuZHkgKiB0XG4gICAgICAgIGNvbnN0IHR4ID0gZy5sZW4gPT09IDAgPyAwIDogZy5keCAvIGcubGVuXG4gICAgICAgIGNvbnN0IHR5ID0gZy5sZW4gPT09IDAgPyAwIDogZy5keSAvIGcubGVuXG4gICAgICAgIGNvbnN0IG54ID0gIHR5XG4gICAgICAgIGNvbnN0IG55ID0gLXR4XG4gICAgICAgIHJldHVybiB7IHgsIHksIG54LCBueSB9XG4gICAgICB9XG4gICAgICBhY2MgKz0gZy5sZW5cbiAgICB9XG4gICAgLy8gcyBleGFrdCBhbSBFbmRlXG4gICAgY29uc3QgbGFzdCA9IHNlZ3Nbc2Vncy5sZW5ndGggLSAxXVxuICAgIGNvbnN0IHR4ID0gbGFzdC5sZW4gPT09IDAgPyAwIDogbGFzdC5keCAvIGxhc3QubGVuXG4gICAgY29uc3QgdHkgPSBsYXN0LmxlbiA9PT0gMCA/IDAgOiBsYXN0LmR5IC8gbGFzdC5sZW5cbiAgICByZXR1cm4geyB4OiBsYXN0LmIueCwgeTogbGFzdC5iLnksIG54OiB0eSwgbnk6IC10eCB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3RG90KHg6IG51bWJlciwgeTogbnVtYmVyLCByOiBudW1iZXIpIHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKVxuICAgIGN0eC5maWxsU3R5bGUgPSAnIzZCRDVGRicgLy8gZWxla3RyaXNjaGVzIEJsYXVcbiAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgxMDcsIDIxMywgMjU1LCAwLjU1KSdcbiAgICBjdHguc2hhZG93Qmx1ciA9IDRcbiAgICBjdHguZmlsbCgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjb21wdXRlTUFuY2hvciIsInciLCJoIiwibGVmdFgiLCJiYXNlWSIsIngiLCJ5IiwiYnVpbGRDcnlzdGFsTSIsImN0eCIsImFuY2hvciIsImlzTW9iaWxlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInJlY3QiLCJjYW52YXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInRvcFkiLCJyaWdodFgiLCJNYXRoIiwibWF4IiwibWlkWCIsInZhbGxleVkiLCJQIiwic2VncyIsImEiLCJiIiwibWFwIiwicyIsImR4IiwiZHkiLCJsZW4iLCJoeXBvdCIsInRvdGFsTGVuIiwicmVkdWNlIiwiZyIsImRvdFIiLCJtaW5HYXAiLCJzdGVwQWxvbmciLCJnYXBBY3Jvc3MiLCJ3aWR0aFB4Iiwicm93cyIsImZsb29yIiwiZHVyYXRpb25TZWMiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwibm93IiwicHJldlMiLCJyYWYiLCJjZWxsIiwibWluIiwicGxhY2VkIiwiU2V0Iiwia2V5Iiwicm91bmQiLCJkcmF3RG90IiwiYWRkIiwidGljayIsInQiLCJzVGFyZ2V0IiwicG9zIiwicG9pbnRBdExlbmd0aCIsIm54IiwibnkiLCJoYWxmIiwiciIsIm9mZnNldCIsInB4IiwicHkiLCJrIiwiaGFzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJhY2MiLCJscyIsInR4IiwidHkiLCJsYXN0IiwibGVuZ3RoIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJmaWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});