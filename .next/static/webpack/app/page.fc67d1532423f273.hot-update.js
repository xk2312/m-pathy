"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/modules/crystalEngine.ts":
/*!**************************************!*\
  !*** ./app/modules/crystalEngine.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildCrystalM: function() { return /* binding */ buildCrystalM; },\n/* harmony export */   computeMAnchor: function() { return /* binding */ computeMAnchor; }\n/* harmony export */ });\nfunction computeMAnchor(w, h) {\n    const leftX = w * 0.28;\n    const baseY = h * 0.74;\n    return {\n        x: leftX,\n        y: baseY\n    };\n}\n/**\n * Phase A: Kontur (nur äußere Reihen + Caps) – sequenziell P0→P4\n * Phase B: Füllen (innere Reihen) – weicher Strom, ebenfalls entlang der Segmente\n */ function buildCrystalM(ctx, anchor) {\n    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);\n    const { width: w, height: h } = ctx.canvas.getBoundingClientRect();\n    // Proportionen – aufrechte Säulen\n    const baseY = h * 0.74;\n    const topY = h * 0.36;\n    const leftX = w * 0.28;\n    const rightX = w * 0.28 + Math.max(360, w * 0.32);\n    const midX = (leftX + rightX) / 2;\n    const valleyY = baseY - Math.max(90, h * 0.14);\n    const P = [\n        {\n            x: leftX,\n            y: baseY\n        },\n        {\n            x: leftX,\n            y: topY\n        },\n        {\n            x: midX,\n            y: valleyY\n        },\n        {\n            x: rightX,\n            y: topY\n        },\n        {\n            x: rightX,\n            y: baseY\n        }\n    ];\n    const segments = [\n        {\n            a: P[0],\n            b: P[1]\n        },\n        {\n            a: P[1],\n            b: P[2]\n        },\n        {\n            a: P[2],\n            b: P[3]\n        },\n        {\n            a: P[3],\n            b: P[4]\n        }\n    ];\n    // Look & Abstände\n    const dotR = isMobile ? 1.3 : 1.6;\n    const minGap = isMobile ? 1.8 : 2.2;\n    const gapAlong = Math.max(isMobile ? 2.4 : 2.0, dotR * 2 + (minGap - 0.6));\n    const gapAcross = Math.max(isMobile ? 4.8 : 4.2, dotR * 2 + minGap);\n    const widthPx = isMobile ? 28 : 56;\n    const maxRows = Math.max(1, Math.floor(widthPx / gapAcross));\n    const outlineRows = Math.max(1, Math.min(2, maxRows)) // Kontur = nur äußere 1–2 Reihen\n    ;\n    const duration = 5 // Sekunden\n    ;\n    // Hilfen\n    const draw = (x, y, r)=>{\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = \"#6BD5FF\";\n        ctx.shadowColor = \"rgba(107,213,255,0.55)\";\n        ctx.shadowBlur = 4;\n        ctx.fill();\n    };\n    const pushRowDots = (dots, a, b, rowIndex, rows, sOffset)=>{\n        const dx = b.x - a.x, dy = b.y - a.y, len = Math.hypot(dx, dy);\n        if (len <= 0) return;\n        const tx = dx / len, ty = dy / len, nx = ty, ny = -tx;\n        const half = (rows - 1) / 2;\n        const offset = (rowIndex - half) * gapAcross;\n        const steps = Math.max(2, Math.floor(len / gapAlong));\n        // KEIN Stagger in der ersten Dot des ersten Segments → Anchor exakt\n        for(let i = 0; i <= steps; i++){\n            const d = i * gapAlong;\n            if (d > len) continue;\n            const x = a.x + tx * d + nx * offset;\n            const y = a.y + ty * d + ny * offset;\n            dots.push({\n                x,\n                y,\n                s: sOffset + d + rowIndex * 0.001\n            });\n        }\n    };\n    // Phase A: äußere Reihen (Kontur)\n    const outlineDots = [];\n    let sAccum = 0;\n    for (const seg of segments){\n        const len = Math.hypot(seg.b.x - seg.a.x, seg.b.y - seg.a.y);\n        for(let r = 0; r < outlineRows; r++){\n            pushRowDots(outlineDots, seg.a, seg.b, r === 0 ? 0 : maxRows - 1, maxRows, sAccum);\n        }\n        sAccum += len;\n    }\n    // Caps (Ecken + Enden) nur in Phase A\n    addCap(outlineDots, P[1]);\n    addCap(outlineDots, P[2]);\n    addCap(outlineDots, P[3]);\n    addCap(outlineDots, P[0], 0.85);\n    addCap(outlineDots, P[4], 0.85);\n    // Phase B: innere Reihen (Füllung)\n    const fillDots = [];\n    sAccum = 0;\n    for (const seg of segments){\n        const len = Math.hypot(seg.b.x - seg.a.x, seg.b.y - seg.a.y);\n        for(let r = 1; r < maxRows - 1; r++){\n            pushRowDots(fillDots, seg.a, seg.b, r, maxRows, sAccum);\n        }\n        sAccum += len;\n    }\n    // Sortierung: streng entlang des Pfads\n    outlineDots.sort((p, q)=>p.s - q.s);\n    fillDots.sort((p, q)=>p.s - q.s);\n    // Animation: 1s Delay nach Meteor, dann 60% Zeit Kontur, 40% Füllung\n    const start = performance.now() + 1000;\n    const outlineEnd = start + duration * 1000 * 0.60;\n    const finish = start + duration * 1000;\n    // Erster Punkt (Anchor) sofort setzen\n    draw(anchor.x, anchor.y, dotR + 0.9);\n    let iA = 0, iB = 0;\n    function tick(now) {\n        if (now >= start) {\n            if (now <= outlineEnd) {\n                // Kontur-Phase\n                const t = (now - start) / (outlineEnd - start);\n                const target = Math.floor(t * outlineDots.length);\n                for(; iA < target; iA++)draw(outlineDots[iA].x, outlineDots[iA].y, dotR);\n            } else {\n                // Füllphase\n                for(; iA < outlineDots.length; iA++)draw(outlineDots[iA].x, outlineDots[iA].y, dotR);\n                const t = (now - outlineEnd) / (finish - outlineEnd);\n                const target = Math.floor(t * fillDots.length);\n                for(; iB < target; iB++)draw(fillDots[iB].x, fillDots[iB].y, dotR);\n            }\n        }\n        if (now < finish || iB < fillDots.length) requestAnimationFrame(tick);\n    }\n    requestAnimationFrame(tick);\n    function addCap(list, C) {\n        let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const capR = ((maxRows - 1) * gapAcross * 0.55 + dotR) * scale;\n        const step = Math.max(dotR * 2 + minGap, gapAcross * 0.9);\n        const rings = Math.max(1, Math.floor(capR / step));\n        let localS = 0;\n        for(let r = 0; r <= rings; r++){\n            const rad = r * step;\n            const circ = 2 * Math.PI * Math.max(rad, 1);\n            const n = Math.max(6, Math.floor(circ / step));\n            for(let i = 0; i < n; i++){\n                const a = i / n * Math.PI * 2;\n                list.push({\n                    x: C.x + Math.cos(a) * rad,\n                    y: C.y + Math.sin(a) * rad,\n                    s: Number.MAX_SAFE_INTEGER - 1000 + localS++ // Caps am Ende der Konturphase\n                });\n            }\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9tb2R1bGVzL2NyeXN0YWxFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFTyxTQUFTQSxlQUFlQyxDQUFRLEVBQUNDLENBQVE7SUFDOUMsTUFBTUMsUUFBUUYsSUFBSTtJQUNsQixNQUFNRyxRQUFRRixJQUFJO0lBQ2xCLE9BQU87UUFBRUcsR0FBR0Y7UUFBT0csR0FBR0Y7SUFBTTtBQUM5QjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNHLGNBQWNDLEdBQTZCLEVBQUVDLE1BQVU7SUFDckUsTUFBTUMsV0FBVyw0QkFBNEJDLElBQUksQ0FBQ0MsVUFBVUMsU0FBUztJQUNyRSxNQUFNLEVBQUVDLE9BQU1iLENBQUMsRUFBRWMsUUFBT2IsQ0FBQyxFQUFFLEdBQUdNLElBQUlRLE1BQU0sQ0FBQ0MscUJBQXFCO0lBRTlELGtDQUFrQztJQUNsQyxNQUFNYixRQUFTRixJQUFJO0lBQ25CLE1BQU1nQixPQUFTaEIsSUFBSTtJQUNuQixNQUFNQyxRQUFTRixJQUFJO0lBQ25CLE1BQU1rQixTQUFTbEIsSUFBSSxPQUFPbUIsS0FBS0MsR0FBRyxDQUFDLEtBQUtwQixJQUFJO0lBQzVDLE1BQU1xQixPQUFTLENBQUNuQixRQUFRZ0IsTUFBSyxJQUFLO0lBQ2xDLE1BQU1JLFVBQVNuQixRQUFRZ0IsS0FBS0MsR0FBRyxDQUFDLElBQUluQixJQUFJO0lBRXhDLE1BQU1zQixJQUFJO1FBQ1I7WUFBRW5CLEdBQUVGO1lBQVFHLEdBQUVGO1FBQU07UUFDcEI7WUFBRUMsR0FBRUY7WUFBUUcsR0FBRVk7UUFBTTtRQUNwQjtZQUFFYixHQUFFaUI7WUFBUWhCLEdBQUVpQjtRQUFRO1FBQ3RCO1lBQUVsQixHQUFFYztZQUFRYixHQUFFWTtRQUFNO1FBQ3BCO1lBQUViLEdBQUVjO1lBQVFiLEdBQUVGO1FBQU07S0FDckI7SUFDRCxNQUFNcUIsV0FBVztRQUNmO1lBQUVDLEdBQUVGLENBQUMsQ0FBQyxFQUFFO1lBQUVHLEdBQUVILENBQUMsQ0FB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c3RhbEVuZ2luZS50cz80NmM5Il0sInNvdXJjZXNDb250ZW50IjpbInR5cGUgWFkgPSB7IHg6bnVtYmVyOyB5Om51bWJlciB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTUFuY2hvcih3Om51bWJlcixoOm51bWJlcik6IFhZIHtcbiAgY29uc3QgbGVmdFggPSB3ICogMC4yOFxuICBjb25zdCBiYXNlWSA9IGggKiAwLjc0XG4gIHJldHVybiB7IHg6IGxlZnRYLCB5OiBiYXNlWSB9XG59XG5cbi8qKlxuICogUGhhc2UgQTogS29udHVyIChudXIgw6R1w59lcmUgUmVpaGVuICsgQ2Fwcykg4oCTIHNlcXVlbnppZWxsIFAw4oaSUDRcbiAqIFBoYXNlIEI6IEbDvGxsZW4gKGlubmVyZSBSZWloZW4pIOKAkyB3ZWljaGVyIFN0cm9tLCBlYmVuZmFsbHMgZW50bGFuZyBkZXIgU2VnbWVudGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ3J5c3RhbE0oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFuY2hvcjogWFkpIHtcbiAgY29uc3QgaXNNb2JpbGUgPSAvTW9iaXxBbmRyb2lkfGlQaG9uZXxpUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuICBjb25zdCB7IHdpZHRoOncsIGhlaWdodDpoIH0gPSBjdHguY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgLy8gUHJvcG9ydGlvbmVuIOKAkyBhdWZyZWNodGUgU8OkdWxlblxuICBjb25zdCBiYXNlWSAgPSBoICogMC43NFxuICBjb25zdCB0b3BZICAgPSBoICogMC4zNlxuICBjb25zdCBsZWZ0WCAgPSB3ICogMC4yOFxuICBjb25zdCByaWdodFggPSB3ICogMC4yOCArIE1hdGgubWF4KDM2MCwgdyAqIDAuMzIpXG4gIGNvbnN0IG1pZFggICA9IChsZWZ0WCArIHJpZ2h0WCkgLyAyXG4gIGNvbnN0IHZhbGxleVk9IGJhc2VZIC0gTWF0aC5tYXgoOTAsIGggKiAwLjE0KVxuXG4gIGNvbnN0IFAgPSBbXG4gICAgeyB4OmxlZnRYLCAgeTpiYXNlWSB9LCAgIC8vIDBcbiAgICB7IHg6bGVmdFgsICB5OnRvcFkgIH0sICAgLy8gMVxuICAgIHsgeDptaWRYLCAgIHk6dmFsbGV5WSB9LCAvLyAyXG4gICAgeyB4OnJpZ2h0WCwgeTp0b3BZICB9LCAgIC8vIDNcbiAgICB7IHg6cmlnaHRYLCB5OmJhc2VZIH0sICAgLy8gNFxuICBdIGFzIGNvbnN0XG4gIGNvbnN0IHNlZ21lbnRzID0gW1xuICAgIHsgYTpQWzBdLCBiOlBbMV0gfSwgeyBhOlBbMV0sIGI6UFsyXSB9LFxuICAgIHsgYTpQWzJdLCBiOlBbM10gfSwgeyBhOlBbM10sIGI6UFs0XSB9LFxuICBdXG5cbiAgLy8gTG9vayAmIEFic3TDpG5kZVxuICBjb25zdCBkb3RSICAgICAgID0gaXNNb2JpbGUgPyAxLjMgOiAxLjZcbiAgY29uc3QgbWluR2FwICAgICA9IGlzTW9iaWxlID8gMS44IDogMi4yXG4gIGNvbnN0IGdhcEFsb25nICAgPSBNYXRoLm1heChpc01vYmlsZSA/IDIuNCA6IDIuMCwgZG90UioyICsgKG1pbkdhcC0wLjYpKVxuICBjb25zdCBnYXBBY3Jvc3MgID0gTWF0aC5tYXgoaXNNb2JpbGUgPyA0LjggOiA0LjIsIGRvdFIqMiArIG1pbkdhcClcbiAgY29uc3Qgd2lkdGhQeCAgICA9IGlzTW9iaWxlID8gMjggOiA1NlxuICBjb25zdCBtYXhSb3dzICAgID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih3aWR0aFB4IC8gZ2FwQWNyb3NzKSlcbiAgY29uc3Qgb3V0bGluZVJvd3M9IE1hdGgubWF4KDEsIE1hdGgubWluKDIsIG1heFJvd3MpKSAgLy8gS29udHVyID0gbnVyIMOkdcOfZXJlIDHigJMyIFJlaWhlblxuICBjb25zdCBkdXJhdGlvbiAgID0gNSAvLyBTZWt1bmRlblxuXG4gIC8vIEhpbGZlblxuICBjb25zdCBkcmF3ID0gKHg6bnVtYmVyLHk6bnVtYmVyLHI6bnVtYmVyKSA9PiB7XG4gICAgY3R4LmJlZ2luUGF0aCgpOyBjdHguYXJjKHgseSxyLDAsTWF0aC5QSSoyKVxuICAgIGN0eC5maWxsU3R5bGUgPSAnIzZCRDVGRidcbiAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgxMDcsMjEzLDI1NSwwLjU1KSdcbiAgICBjdHguc2hhZG93Qmx1ciA9IDRcbiAgICBjdHguZmlsbCgpXG4gIH1cbiAgY29uc3QgcHVzaFJvd0RvdHMgPSAoZG90czogKFhZICYge3M6bnVtYmVyfSlbXSwgYTpYWSwgYjpYWSwgcm93SW5kZXg6bnVtYmVyLCByb3dzOm51bWJlciwgc09mZnNldDpudW1iZXIpID0+IHtcbiAgICBjb25zdCBkeD1iLngtYS54LCBkeT1iLnktYS55LCBsZW49TWF0aC5oeXBvdChkeCxkeSk7IGlmIChsZW48PTApIHJldHVyblxuICAgIGNvbnN0IHR4PWR4L2xlbiwgdHk9ZHkvbGVuLCBueD10eSwgbnk9LXR4XG4gICAgY29uc3QgaGFsZj0ocm93cy0xKS8yXG4gICAgY29uc3Qgb2Zmc2V0ID0gKHJvd0luZGV4IC0gaGFsZikgKiBnYXBBY3Jvc3NcbiAgICBjb25zdCBzdGVwcyA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IobGVuIC8gZ2FwQWxvbmcpKVxuICAgIC8vIEtFSU4gU3RhZ2dlciBpbiBkZXIgZXJzdGVuIERvdCBkZXMgZXJzdGVuIFNlZ21lbnRzIOKGkiBBbmNob3IgZXhha3RcbiAgICBmb3IgKGxldCBpPTA7aTw9c3RlcHM7aSsrKXtcbiAgICAgIGNvbnN0IGQgPSBpICogZ2FwQWxvbmdcbiAgICAgIGlmIChkPmxlbikgY29udGludWVcbiAgICAgIGNvbnN0IHggPSBhLnggKyB0eCpkICsgbngqb2Zmc2V0XG4gICAgICBjb25zdCB5ID0gYS55ICsgdHkqZCArIG55Km9mZnNldFxuICAgICAgZG90cy5wdXNoKHsgeCwgeSwgczogc09mZnNldCArIGQgKyByb3dJbmRleCowLjAwMSB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIFBoYXNlIEE6IMOkdcOfZXJlIFJlaWhlbiAoS29udHVyKVxuICBjb25zdCBvdXRsaW5lRG90czogKFhZICYge3M6bnVtYmVyfSlbXSA9IFtdXG4gIGxldCBzQWNjdW0gPSAwXG4gIGZvciAoY29uc3Qgc2VnIG9mIHNlZ21lbnRzKXtcbiAgICBjb25zdCBsZW4gPSBNYXRoLmh5cG90KHNlZy5iLngtc2VnLmEueCwgc2VnLmIueS1zZWcuYS55KVxuICAgIGZvciAobGV0IHI9MDsgcjxvdXRsaW5lUm93czsgcisrKXtcbiAgICAgIHB1c2hSb3dEb3RzKG91dGxpbmVEb3RzLCBzZWcuYSwgc2VnLmIsIHI9PT0wID8gMCA6IG1heFJvd3MtMSwgbWF4Um93cywgc0FjY3VtKVxuICAgIH1cbiAgICBzQWNjdW0gKz0gbGVuXG4gIH1cbiAgLy8gQ2FwcyAoRWNrZW4gKyBFbmRlbikgbnVyIGluIFBoYXNlIEFcbiAgYWRkQ2FwKG91dGxpbmVEb3RzLCBQWzFdKTsgYWRkQ2FwKG91dGxpbmVEb3RzLCBQWzJdKTsgYWRkQ2FwKG91dGxpbmVEb3RzLCBQWzNdKVxuICBhZGRDYXAob3V0bGluZURvdHMsIFBbMF0sIDAuODUpOyBhZGRDYXAob3V0bGluZURvdHMsIFBbNF0sIDAuODUpXG5cbiAgLy8gUGhhc2UgQjogaW5uZXJlIFJlaWhlbiAoRsO8bGx1bmcpXG4gIGNvbnN0IGZpbGxEb3RzOiAoWFkgJiB7czpudW1iZXJ9KVtdID0gW11cbiAgc0FjY3VtID0gMFxuICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cyl7XG4gICAgY29uc3QgbGVuID0gTWF0aC5oeXBvdChzZWcuYi54LXNlZy5hLngsIHNlZy5iLnktc2VnLmEueSlcbiAgICBmb3IgKGxldCByPTE7IHI8bWF4Um93cy0xOyByKyspe1xuICAgICAgcHVzaFJvd0RvdHMoZmlsbERvdHMsIHNlZy5hLCBzZWcuYiwgciwgbWF4Um93cywgc0FjY3VtKVxuICAgIH1cbiAgICBzQWNjdW0gKz0gbGVuXG4gIH1cblxuICAvLyBTb3J0aWVydW5nOiBzdHJlbmcgZW50bGFuZyBkZXMgUGZhZHNcbiAgb3V0bGluZURvdHMuc29ydCgocCxxKT0+cC5zLXEucylcbiAgZmlsbERvdHMuc29ydCgocCxxKT0+cC5zLXEucylcblxuICAvLyBBbmltYXRpb246IDFzIERlbGF5IG5hY2ggTWV0ZW9yLCBkYW5uIDYwJSBaZWl0IEtvbnR1ciwgNDAlIEbDvGxsdW5nXG4gIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCkgKyAxMDAwXG4gIGNvbnN0IG91dGxpbmVFbmQgPSBzdGFydCArIGR1cmF0aW9uKjEwMDAqMC42MFxuICBjb25zdCBmaW5pc2ggPSBzdGFydCArIGR1cmF0aW9uKjEwMDBcblxuICAvLyBFcnN0ZXIgUHVua3QgKEFuY2hvcikgc29mb3J0IHNldHplblxuICBkcmF3KGFuY2hvci54LCBhbmNob3IueSwgZG90UiArIDAuOSlcblxuICBsZXQgaUEgPSAwLCBpQiA9IDBcbiAgZnVuY3Rpb24gdGljayhub3c6bnVtYmVyKXtcbiAgICBpZiAobm93ID49IHN0YXJ0KXtcbiAgICAgIGlmIChub3cgPD0gb3V0bGluZUVuZCl7XG4gICAgICAgIC8vIEtvbnR1ci1QaGFzZVxuICAgICAgICBjb25zdCB0ID0gKG5vdyAtIHN0YXJ0KSAvIChvdXRsaW5lRW5kIC0gc3RhcnQpXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IE1hdGguZmxvb3IodCAqIG91dGxpbmVEb3RzLmxlbmd0aClcbiAgICAgICAgZm9yICg7IGlBIDwgdGFyZ2V0OyBpQSsrKSBkcmF3KG91dGxpbmVEb3RzW2lBXS54LCBvdXRsaW5lRG90c1tpQV0ueSwgZG90UilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEbDvGxscGhhc2VcbiAgICAgICAgZm9yICg7IGlBIDwgb3V0bGluZURvdHMubGVuZ3RoOyBpQSsrKSBkcmF3KG91dGxpbmVEb3RzW2lBXS54LCBvdXRsaW5lRG90c1tpQV0ueSwgZG90UilcbiAgICAgICAgY29uc3QgdCA9IChub3cgLSBvdXRsaW5lRW5kKSAvIChmaW5pc2ggLSBvdXRsaW5lRW5kKVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBNYXRoLmZsb29yKHQgKiBmaWxsRG90cy5sZW5ndGgpXG4gICAgICAgIGZvciAoOyBpQiA8IHRhcmdldDsgaUIrKykgZHJhdyhmaWxsRG90c1tpQl0ueCwgZmlsbERvdHNbaUJdLnksIGRvdFIpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3cgPCBmaW5pc2ggfHwgaUIgPCBmaWxsRG90cy5sZW5ndGgpIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKVxuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKVxuXG4gIGZ1bmN0aW9uIGFkZENhcChsaXN0OihYWSAmIHtzOm51bWJlcn0pW10sIEM6WFksIHNjYWxlPTEpe1xuICAgIGNvbnN0IGNhcFIgPSAoKG1heFJvd3MtMSkqZ2FwQWNyb3NzKjAuNTUgKyBkb3RSKSAqIHNjYWxlXG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KGRvdFIqMittaW5HYXAsIGdhcEFjcm9zcyowLjkpXG4gICAgY29uc3QgcmluZ3MgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGNhcFIgLyBzdGVwKSlcbiAgICBsZXQgbG9jYWxTID0gMFxuICAgIGZvciAobGV0IHI9MDsgcjw9cmluZ3M7IHIrKyl7XG4gICAgICBjb25zdCByYWQgPSByICogc3RlcFxuICAgICAgY29uc3QgY2lyYyA9IDIqTWF0aC5QSSpNYXRoLm1heChyYWQsMSlcbiAgICAgIGNvbnN0IG4gPSBNYXRoLm1heCg2LCBNYXRoLmZsb29yKGNpcmMgLyBzdGVwKSlcbiAgICAgIGZvciAobGV0IGk9MDtpPG47aSsrKXtcbiAgICAgICAgY29uc3QgYSA9IChpL24pKk1hdGguUEkqMlxuICAgICAgICBsaXN0LnB1c2goe1xuICAgICAgICAgIHg6IEMueCArIE1hdGguY29zKGEpKnJhZCxcbiAgICAgICAgICB5OiBDLnkgKyBNYXRoLnNpbihhKSpyYWQsXG4gICAgICAgICAgczogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLSAxMDAwICsgbG9jYWxTKysgLy8gQ2FwcyBhbSBFbmRlIGRlciBLb250dXJwaGFzZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImNvbXB1dGVNQW5jaG9yIiwidyIsImgiLCJsZWZ0WCIsImJhc2VZIiwieCIsInkiLCJidWlsZENyeXN0YWxNIiwiY3R4IiwiYW5jaG9yIiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJjYW52YXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3BZIiwicmlnaHRYIiwiTWF0aCIsIm1heCIsIm1pZFgiLCJ2YWxsZXlZIiwiUCIsInNlZ21lbnRzIiwiYSIsImIiLCJkb3RSIiwibWluR2FwIiwiZ2FwQWxvbmciLCJnYXBBY3Jvc3MiLCJ3aWR0aFB4IiwibWF4Um93cyIsImZsb29yIiwib3V0bGluZVJvd3MiLCJtaW4iLCJkdXJhdGlvbiIsImRyYXciLCJyIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJmaWxsIiwicHVzaFJvd0RvdHMiLCJkb3RzIiwicm93SW5kZXgiLCJyb3dzIiwic09mZnNldCIsImR4IiwiZHkiLCJsZW4iLCJoeXBvdCIsInR4IiwidHkiLCJueCIsIm55IiwiaGFsZiIsIm9mZnNldCIsInN0ZXBzIiwiaSIsImQiLCJwdXNoIiwicyIsIm91dGxpbmVEb3RzIiwic0FjY3VtIiwic2VnIiwiYWRkQ2FwIiwiZmlsbERvdHMiLCJzb3J0IiwicCIsInEiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwibm93Iiwib3V0bGluZUVuZCIsImZpbmlzaCIsImlBIiwiaUIiLCJ0aWNrIiwidCIsInRhcmdldCIsImxlbmd0aCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImxpc3QiLCJDIiwic2NhbGUiLCJjYXBSIiwic3RlcCIsInJpbmdzIiwibG9jYWxTIiwicmFkIiwiY2lyYyIsIm4iLCJjb3MiLCJzaW4iLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/modules/crystalEngine.ts\n"));

/***/ })

});